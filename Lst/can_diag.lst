C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 1   


C166 COMPILER V7.57.0, COMPILATION OF MODULE CAN_DIAG
OBJECT MODULE PLACED IN .\Obj\can_diag.obj
COMPILER INVOKED BY: C:\Keil_v5\C166\BIN\C166.EXE src\app\can\can_diag.c MODV2 LARGE BROWSE INCDIR(.\src;.\src\bsw;.\src
                    -\driver;.\src\interaction;.\src\app\adc;.\src\app\alogrithm;.\src\app\can;.\src\app\ccp;.\src\app\diagnostic;.\src\app\m
                    -ode control;.\src\app\task;.\src\app\Fun;.\src\app\rtos;.\src\bsw\can;.\src\bsw\desc;.\src\bsw\nm;.\src\app\time measure
                    -;.\src\app\rte) MODV2 DEBUG PRINT(.\Lst\can_diag.lst) OBJECT(.\Obj\can_diag.obj) 

 stmt lvl     source

    1         //****************************************************************************
    2         // @Module        Project Settings
    3         // @Filename      can_diag.c
    4         // @Project       P300.dav
    5         //----------------------------------------------------------------------------
    6         // @Controller    Infineon XC2365B-40F80
    7         //
    8         // @Compiler      Keil
    9         //
   10         // @Codegenerator 2.0
   11         //
   12         // @Description   This file contains the project initialization function.
   13         //
   14         //----------------------------------------------------------------------------
   15         // @Date          2020-03-04 15:47:42
   16         //
   17         //****************************************************************************
   18         
   19         // USER CODE BEGIN (MAIN_General,1)
   20         
   21         // USER CODE END
   22         
   23         
   24         
   25         //****************************************************************************
   26         // @Project Includes
   27         //****************************************************************************
   28         
   29         // USER CODE BEGIN (MAIN_General,2)
   30         
   31         #include <string.h>
   32         
   33         #include "can.h"
   34         #include "can_com.h"
   35         #include "can_diag.h"
   36         #include "desc_mgr.h"
   37         #include "Nm.h"
   38         #include "FLTD.h"
   39         
   40         #define CAN_DIAG_GLOBALS
   41         
   42         // USER CODE END
   43         
   44         
   45         //****************************************************************************
   46         // @Macros
   47         //****************************************************************************
   48         
   49         // USER CODE BEGIN (MAIN_General,3)
   50         
   51         // USER CODE END
   52         
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 2   

   53         
   54         //****************************************************************************
   55         // @Defines
   56         //****************************************************************************
   57         
   58         // USER CODE BEGIN (MAIN_General,4)
   59         
   60         // USER CODE END
   61         
   62         
   63         //****************************************************************************
   64         // @Typedefs
   65         //****************************************************************************
   66         
   67         // USER CODE BEGIN (MAIN_General,5)
   68         
   69         // USER CODE END
   70         
   71         
   72         //****************************************************************************
   73         // @Imported Global Variables
   74         //****************************************************************************
   75         
   76         // USER CODE BEGIN (MAIN_General,6)
   77         
   78         // USER CODE END
   79         
   80         
   81         //****************************************************************************
   82         // @Global Variables
   83         //****************************************************************************
   84         
   85         // USER CODE BEGIN (MAIN_General,7)
   86         
   87         INT16U  uCanVoltageValue;
   88         
   89         CAN_DIAG_STAT CAN_DTC_ERR t_canDtcErr = {0u};
   90         CAN_MSG_LOST_FLAG t_canMsgLostFlag = {0u};
   91         
   92         
   93         // USER CODE END
   94         
   95         
   96         //****************************************************************************
   97         // @External Prototypes
   98         //****************************************************************************
   99         
  100         // USER CODE BEGIN (MAIN_General,8)
  101         
  102         // USER CODE END
  103         
  104         
  105         //****************************************************************************
  106         // @Prototypes Of Local Functions
  107         //****************************************************************************
  108         
  109         // USER CODE BEGIN (MAIN_General,9)
  110         CAN_DIAG_STAT void CanDiag_DTC_VCU_0x505MsgLost(void);
  111         CAN_DIAG_STAT void CanDiag_DTC_VCU_0x101MsgLost(void);
  112         CAN_DIAG_STAT void CanDiag_DTC_MCU_0x202MsgLost(void);
  113         CAN_DIAG_STAT void CanDiag_DTC_MCU_0x206MsgLost(void);
  114         CAN_DIAG_STAT void CanDiag_DTC_ABS_0x454MsgLost(void);
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 3   

  115         CAN_DIAG_STAT void CanDiag_DTC_ElectricalFaultCheck(void);
  116         
  117         
  118         // USER CODE END
  119         
  120         //****************************************************************************
  121         // @Function      void CanDiag_DTC_NmCheckTask()
  122         //
  123         //----------------------------------------------------------------------------
  124         // @Description   This function is cyclic task for network dtc check.
  125         //                                cycle time: 10ms
  126         //----------------------------------------------------------------------------
  127         // @Returnvalue   None
  128         //
  129         //----------------------------------------------------------------------------
  130         // @Parameters    None 
  131         //
  132         //----------------------------------------------------------------------------
  133         // @Date          2020-11-18
  134         //
  135         //****************************************************************************
  136         void CanDiag_DTC_NmCheckTask(void)
  137         {
  138  1              CanDiag_DTC_VCU_0x505MsgLost();
  139  1              CanDiag_DTC_VCU_0x101MsgLost();
  140  1              CanDiag_DTC_MCU_0x202MsgLost();
  141  1              CanDiag_DTC_MCU_0x206MsgLost();
  142  1              CanDiag_DTC_ABS_0x454MsgLost();
  143  1              CanDiag_DTC_ElectricalFaultCheck();
  144  1      }
  145         
  146         
  147         
  148         //****************************************************************************
  149         // @Function      void CanDiag_DTC_VCU_0x505MsgLost()
  150         //
  151         //----------------------------------------------------------------------------
  152         // @Description   This function check 0x505 message lost.
  153         //                                0x505 cycle time: 10ms
  154         //----------------------------------------------------------------------------
  155         // @Returnvalue   None
  156         //
  157         //----------------------------------------------------------------------------
  158         // @Parameters    None 
  159         //
  160         //----------------------------------------------------------------------------
  161         // @Date          2020-11-18
  162         //
  163         //****************************************************************************
  164         CAN_DIAG_STAT INT8U u0x505MsgLostRecoverCnt = 0u;
  165         CAN_DIAG_STAT void CanDiag_DTC_VCU_0x505MsgLost(void)
  166         {
  167  1              if(FALSE == t_canMsgLostFlag.b0x505MsgLostErr)
  168  1              {
  169  2                      u0x505MsgLostRecoverCnt++;
  170  2                      if(u0x505MsgLostRecoverCnt >= MESSAGE_RECOVER_CYCLE)
  171  2                      {
  172  3                              u0x505MsgLostRecoverCnt = MESSAGE_RECOVER_CYCLE;
  173  3                              if ((TRUE == DescMgr_CanDiagDtcRecordNmEnableCheck())&&(FALSE == t_canMsgLostFlag.b0x101MsgLostErr))
  174  3                      {
  175  4                                      DescMgr_DtcStatusDataReport(DTC_CAN_NODE_VCU_LOST_ERR, DTC_TEST_PASSED);
  176  4                      }
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 4   

  177  3                      }
  178  2              }
  179  1              else
  180  1              {
  181  2                      u0x505MsgLostRecoverCnt = 0u;
  182  2                      if (TRUE == DescMgr_CanDiagDtcRecordNmEnableCheck())
  183  2                  {
  184  3                              DescMgr_DtcStatusDataReport(DTC_CAN_NODE_VCU_LOST_ERR, DTC_TEST_FAILED);
  185  3                  }
  186  2              }
  187  1      }
  188         
  189         //****************************************************************************
  190         // @Function      void CanDiag_DTC_VCU_0x101MsgLost()
  191         //
  192         //----------------------------------------------------------------------------
  193         // @Description   This function check 0x101 message lost.
  194         //                                0x101 cycle time: 10ms
  195         //----------------------------------------------------------------------------
  196         // @Returnvalue   None
  197         //
  198         //----------------------------------------------------------------------------
  199         // @Parameters    None 
  200         //
  201         //----------------------------------------------------------------------------
  202         // @Date          2020-11-18
  203         //
  204         //****************************************************************************
  205         CAN_DIAG_STAT INT8U u0x101MsgLostRecoverCnt = 0u;
  206         CAN_DIAG_STAT void CanDiag_DTC_VCU_0x101MsgLost(void)
  207         {
  208  1              if(FALSE == t_canMsgLostFlag.b0x101MsgLostErr)
  209  1              {
  210  2                      u0x101MsgLostRecoverCnt++;
  211  2                      if(u0x101MsgLostRecoverCnt >= MESSAGE_RECOVER_CYCLE)
  212  2                      {
  213  3                              u0x101MsgLostRecoverCnt = MESSAGE_RECOVER_CYCLE;
  214  3                              if ((TRUE == DescMgr_CanDiagDtcRecordNmEnableCheck())&&(FALSE == t_canMsgLostFlag.b0x505MsgLostErr))
  215  3                      {
  216  4                                      DescMgr_DtcStatusDataReport(DTC_CAN_NODE_VCU_LOST_ERR, DTC_TEST_PASSED);
  217  4                      }
  218  3                      }
  219  2              }
  220  1              else
  221  1              {
  222  2                      u0x101MsgLostRecoverCnt = 0u;
  223  2                      if (TRUE == DescMgr_CanDiagDtcRecordNmEnableCheck())
  224  2                  {
  225  3                              DescMgr_DtcStatusDataReport(DTC_CAN_NODE_VCU_LOST_ERR, DTC_TEST_FAILED);
  226  3                  }
  227  2              }
  228  1      }
  229         
  230         //****************************************************************************
  231         // @Function      void CanDiag_DTC_MCU_0x202MsgLost()
  232         //
  233         //----------------------------------------------------------------------------
  234         // @Description   This function check 0x202 message lost.
  235         //                                0x202 cycle time: 10ms
  236         //----------------------------------------------------------------------------
  237         // @Returnvalue   None
  238         //
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 5   

  239         //----------------------------------------------------------------------------
  240         // @Parameters    None 
  241         //
  242         //----------------------------------------------------------------------------
  243         // @Date          2020-11-18
  244         //
  245         //****************************************************************************
  246         CAN_DIAG_STAT INT8U u0x202MsgLostRecoverCnt = 0u;
  247         CAN_DIAG_STAT void CanDiag_DTC_MCU_0x202MsgLost(void)
  248         {
  249  1              if(FALSE == t_canMsgLostFlag.b0x202MsgLostErr)
  250  1              {
  251  2                      u0x202MsgLostRecoverCnt++;
  252  2                      if(u0x202MsgLostRecoverCnt >= MESSAGE_RECOVER_CYCLE)
  253  2                      {
  254  3                              u0x202MsgLostRecoverCnt = MESSAGE_RECOVER_CYCLE;
  255  3                              if ((TRUE == DescMgr_CanDiagDtcRecordNmEnableCheck())&&(FALSE == t_canMsgLostFlag.b0x206MsgLostErr))
  256  3                      {
  257  4                                      DescMgr_DtcStatusDataReport(DTC_CAN_NODE_MCU_LOST_ERR, DTC_TEST_PASSED);
  258  4                      }
  259  3                      }
  260  2              }
  261  1              else
  262  1              {
  263  2                      u0x202MsgLostRecoverCnt = 0u;
  264  2                      if (TRUE == DescMgr_CanDiagDtcRecordNmEnableCheck())
  265  2                  {
  266  3                              DescMgr_DtcStatusDataReport(DTC_CAN_NODE_MCU_LOST_ERR, DTC_TEST_FAILED);
  267  3                  }
  268  2              }
  269  1      }
  270         
  271         //****************************************************************************
  272         // @Function      void CanDiag_DTC_MCU_0x206MsgLost()
  273         //
  274         //----------------------------------------------------------------------------
  275         // @Description   This function check 0x206 message lost.
  276         //                                0x206 cycle time: 100ms
  277         //----------------------------------------------------------------------------
  278         // @Returnvalue   None
  279         //
  280         //----------------------------------------------------------------------------
  281         // @Parameters    None 
  282         //
  283         //----------------------------------------------------------------------------
  284         // @Date          2020-11-18
  285         //
  286         //****************************************************************************
  287         CAN_DIAG_STAT INT8U u0x206MsgLostRecoverCnt = 0u;
  288         CAN_DIAG_STAT void CanDiag_DTC_MCU_0x206MsgLost(void)
  289         {
  290  1              INT8U tempRecoverCyc;
  291  1              tempRecoverCyc = MESSAGE_RECOVER_CYCLE*10;  // recover time 5*10*10ms=500ms
  292  1              if(FALSE == t_canMsgLostFlag.b0x206MsgLostErr)
  293  1              {
  294  2                      u0x206MsgLostRecoverCnt++;
  295  2                      if(u0x206MsgLostRecoverCnt >= tempRecoverCyc)
  296  2                      {
  297  3                              u0x206MsgLostRecoverCnt = tempRecoverCyc;
  298  3                              if ((TRUE == DescMgr_CanDiagDtcRecordNmEnableCheck())&&(FALSE == t_canMsgLostFlag.b0x202MsgLostErr))
  299  3                      {
  300  4                                      DescMgr_DtcStatusDataReport(DTC_CAN_NODE_MCU_LOST_ERR, DTC_TEST_PASSED);
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 6   

  301  4                      }
  302  3                      }
  303  2              }
  304  1              else
  305  1              {
  306  2                      u0x206MsgLostRecoverCnt = 0u;
  307  2                      if (TRUE == DescMgr_CanDiagDtcRecordNmEnableCheck())
  308  2                  {
  309  3                              DescMgr_DtcStatusDataReport(DTC_CAN_NODE_MCU_LOST_ERR, DTC_TEST_FAILED);
  310  3                  }
  311  2              }
  312  1      }
  313         
  314         //****************************************************************************
  315         // @Function      void CanDiag_DTC_ABS_0x454MsgLost()
  316         //
  317         //----------------------------------------------------------------------------
  318         // @Description   This function check 0x454 message lost.
  319         //                                0x454 cycle time: 100ms
  320         //----------------------------------------------------------------------------
  321         // @Returnvalue   None
  322         //
  323         //----------------------------------------------------------------------------
  324         // @Parameters    None 
  325         //
  326         //----------------------------------------------------------------------------
  327         // @Date          2020-11-18
  328         //
  329         //****************************************************************************
  330         CAN_DIAG_STAT INT8U u0x454MsgLostRecoverCnt = 0u;
  331         CAN_DIAG_STAT void CanDiag_DTC_ABS_0x454MsgLost(void)
  332         {
  333  1              INT8U tempRecoverCyc;
  334  1              tempRecoverCyc = MESSAGE_RECOVER_CYCLE*10;  // recover time 5*10*10ms=500ms
  335  1              if(FALSE == t_canMsgLostFlag.b0x454MsgLostErr)
  336  1              {
  337  2                      u0x454MsgLostRecoverCnt++;
  338  2                      if(u0x454MsgLostRecoverCnt >= tempRecoverCyc)
  339  2                      {
  340  3                              u0x454MsgLostRecoverCnt = tempRecoverCyc;
  341  3                              if (TRUE == DescMgr_CanDiagDtcRecordNmEnableCheck())
  342  3                      {
  343  4                                      DescMgr_DtcStatusDataReport(DTC_CAN_NODE_ABS_LOST_ERR, DTC_TEST_PASSED);
  344  4                      }
  345  3                      }
  346  2              }
  347  1              else
  348  1              {
  349  2                      u0x454MsgLostRecoverCnt = 0u;
  350  2                      if (TRUE == DescMgr_CanDiagDtcRecordNmEnableCheck())
  351  2                  {
  352  3                              DescMgr_DtcStatusDataReport(DTC_CAN_NODE_ABS_LOST_ERR, DTC_TEST_FAILED);
  353  3                  }
  354  2              }
  355  1      }
  356         
  357         //****************************************************************************
  358         // @Function      void CanDiag_DTC_ElectricalFaultCheck()
  359         //
  360         //----------------------------------------------------------------------------
  361         // @Description   This function check 0x454 message lost.
  362         //                                0x454 cycle time: 100ms
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 7   

  363         //----------------------------------------------------------------------------
  364         // @Returnvalue   None
  365         //
  366         //----------------------------------------------------------------------------
  367         // @Parameters    None 
  368         //
  369         //----------------------------------------------------------------------------
  370         // @Date          2020-11-21
  371         //
  372         //****************************************************************************
  373         CAN_DIAG_STAT void CanDiag_DTC_ElectricalFaultCheck(void)
  374         {
  375  1              const FLTD_faultFlagType *ptr_FltFlg = FLTD_FltFlgData();
  376  1      
  377  1              /*ECU voltage high*/
  378  1              if(ptr_FltFlg->ecuVoltageHighFlg)
  379  1                      DescMgr_DtcStatusDataReport(DTC_VEHICLE_POWER_VOLTAGE_HIGH, DTC_TEST_FAILED);
  380  1              else
  381  1                      DescMgr_DtcStatusDataReport(DTC_VEHICLE_POWER_VOLTAGE_HIGH, DTC_TEST_PASSED);
  382  1      
  383  1              /*ECU voltage low*/
  384  1              if(ptr_FltFlg->ecuVoltagelowFlg)
  385  1                      DescMgr_DtcStatusDataReport(DTC_VEHICLE_POWER_VOLTAGE_LOW, DTC_TEST_FAILED);
  386  1              else
  387  1                      DescMgr_DtcStatusDataReport(DTC_VEHICLE_POWER_VOLTAGE_LOW, DTC_TEST_PASSED);
  388  1      
  389  1              /*ECU temperature high*/
  390  1              if(ptr_FltFlg->temperatureHighFlg)
  391  1                      DescMgr_DtcStatusDataReport(DTC_ECU_TEMPERATURE_HIGH, DTC_TEST_FAILED);
  392  1              else
  393  1                      DescMgr_DtcStatusDataReport(DTC_ECU_TEMPERATURE_HIGH, DTC_TEST_PASSED);
  394  1      
  395  1              /*ECU temperature low*/
  396  1              if(ptr_FltFlg->temperatureLowFlg)
  397  1                      DescMgr_DtcStatusDataReport(DTC_ECU_TEMPERATURE_LOW, DTC_TEST_FAILED);
  398  1              else
  399  1                      DescMgr_DtcStatusDataReport(DTC_ECU_TEMPERATURE_LOW, DTC_TEST_PASSED);
  400  1      
  401  1              /*ECU temperature sensor fault*/
  402  1              if(ptr_FltFlg->temperatureErrorFlg)
  403  1                      DescMgr_DtcStatusDataReport(DTC_TEMPERATURE_SENSOR_FAULT, DTC_TEST_FAILED);
  404  1              else
  405  1                      DescMgr_DtcStatusDataReport(DTC_TEMPERATURE_SENSOR_FAULT, DTC_TEST_PASSED);
  406  1      
  407  1              /*pedal travel sensor power voltage high*/
  408  1              if(ptr_FltFlg->pedalSensorVoltageHighFlg)
  409  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_POWER_VOLTAGE_HIGH, DTC_TEST_FAILED);
  410  1              else
  411  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_POWER_VOLTAGE_HIGH, DTC_TEST_PASSED);
  412  1      
  413  1              /*pedal travel sensor power voltage low*/
  414  1              if(ptr_FltFlg->pedalSensorVoltageLowFlg)
  415  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_POWER_VOLTAGE_LOW, DTC_TEST_FAILED);
  416  1              else
  417  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_POWER_VOLTAGE_LOW, DTC_TEST_PASSED);
  418  1      
  419  1              /*pedal travel sensor power short circuit*/
  420  1              if(ptr_FltFlg->pedalSensorShortFlg)
  421  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_POWER_SHORT_CIRCUIT, DTC_TEST_FAILED);
  422  1              else
  423  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_POWER_SHORT_CIRCUIT, DTC_TEST_PASSED);
  424  1      
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 8   

  425  1              /*pedal travel sensor power open circuit or fault*/
  426  1              if((ptr_FltFlg->pedalSensor1OpenFlg)||(ptr_FltFlg->pedalSensor2OpenFlg))
  427  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_POWER_OPEN_CIRCUIT, DTC_TEST_FAILED);
  428  1              else
  429  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_POWER_OPEN_CIRCUIT, DTC_TEST_PASSED);
  430  1      
  431  1              /*pedal travel sensor signal over range*/
  432  1              if((ptr_FltFlg->pedalSensor1OverRangFlg)||(ptr_FltFlg->pedalSensor2OverRangFlg))
  433  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_SIGNAL_OVER_RANGE, DTC_TEST_FAILED);
  434  1              else
  435  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_SIGNAL_OVER_RANGE, DTC_TEST_PASSED);
  436  1      
  437  1              /*pedal travel sensor signal check error*/
  438  1              if(ptr_FltFlg->pedalSensorCheckErrorFlg)
  439  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_SIGNAL_CHECK_ERR, DTC_TEST_FAILED);
  440  1              else
  441  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_SIGNAL_CHECK_ERR, DTC_TEST_PASSED);
  442  1      
  443  1              /*pedal travel sensor initial signal check abnormal*/
  444  1              if(ptr_FltFlg->pedalSensorInitAbnormalFlg)
  445  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_INITIAL_SIGNAL_ERR, DTC_TEST_FAILED);
  446  1              else
  447  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_INITIAL_SIGNAL_ERR, DTC_TEST_PASSED);
  448  1      
  449  1              /*pedal travel sensor signal check abnormal*/
  450  1              if(ptr_FltFlg->pedalSensorSignalAbnormalFlg)
  451  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_SIGNAL_ABNORMAL, DTC_TEST_FAILED);
  452  1              else
  453  1                      DescMgr_DtcStatusDataReport(DTC_PEDAL_SENSOR_SIGNAL_ABNORMAL, DTC_TEST_PASSED);
  454  1      
  455  1              /*cylinder travel sensor power voltage high*/
  456  1              if(ptr_FltFlg->cylinderSensorVolHighFlg)
  457  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_POWER_VOLTAGE_HIGH, DTC_TEST_FAILED);
  458  1              else
  459  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_POWER_VOLTAGE_HIGH, DTC_TEST_PASSED);
  460  1      
  461  1              /*cylinder travel sensor power voltage low*/
  462  1              if(ptr_FltFlg->cylinderSensorVolLowFlg)
  463  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_POWER_VOLTAGE_LOW, DTC_TEST_FAILED);
  464  1              else
  465  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_POWER_VOLTAGE_LOW, DTC_TEST_PASSED);
  466  1      
  467  1              /*cylinder travel sensor power short circuit*/
  468  1              if(ptr_FltFlg->cylinderSensorShortFlg)
  469  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_POWER_SHORT_CIRCUIT, DTC_TEST_FAILED);
  470  1              else
  471  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_POWER_SHORT_CIRCUIT, DTC_TEST_PASSED);
  472  1      
  473  1              /*cylinder travel sensor power open circuit or fault*/
  474  1              if((ptr_FltFlg->cylinderSensor1OpenFlg)||(ptr_FltFlg->cylinderSensor2OpenFlg))
  475  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_POWER_OPEN_CIRCUIT, DTC_TEST_FAILED);
  476  1              else
  477  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_POWER_OPEN_CIRCUIT, DTC_TEST_PASSED);
  478  1      
  479  1              /*cylinder travel sensor signal over range*/
  480  1              if((ptr_FltFlg->cylinderSensor1OverRangFlg)||(ptr_FltFlg->cylinderSensor2OverRangFlg))
  481  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_SIGNAL_OVER_RANGE, DTC_TEST_FAILED);
  482  1              else
  483  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_SIGNAL_OVER_RANGE, DTC_TEST_PASSED);
  484  1      
  485  1              /*cylinder travel sensor signal check error*/
  486  1              if(ptr_FltFlg->cylinderSensorCheckErrorFlg)
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 9   

  487  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_SIGNAL_CHECK_ERR, DTC_TEST_FAILED);
  488  1              else
  489  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_SIGNAL_CHECK_ERR, DTC_TEST_PASSED);
  490  1      
  491  1              /*cylinder travel sensor initial signal check abnormal*/
  492  1              if(ptr_FltFlg->cylinderSensorInitAbnormalFlg)
  493  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_INITIAL_SIGNAL_ERR, DTC_TEST_FAILED);
  494  1              else
  495  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_INITIAL_SIGNAL_ERR, DTC_TEST_PASSED);
  496  1      
  497  1              /*cylinder travel sensor signal check abnormal*/
  498  1              if(ptr_FltFlg->cylinderSensorSignalAbnormalFlg)
  499  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_SIGNAL_ABNORMAL, DTC_TEST_FAILED);
  500  1              else
  501  1                      DescMgr_DtcStatusDataReport(DTC_CYLINDER_SENSOR_SIGNAL_ABNORMAL, DTC_TEST_PASSED);
  502  1      
  503  1              /*current sensor signal over range*/
  504  1              if(ptr_FltFlg->currentSensorOverRangFlg)
  505  1                      DescMgr_DtcStatusDataReport(DTC_CURRENT_SENSOR_SIGNAL_OVER_RANGE, DTC_TEST_FAILED);
  506  1              else
  507  1                      DescMgr_DtcStatusDataReport(DTC_CURRENT_SENSOR_SIGNAL_OVER_RANGE, DTC_TEST_PASSED);
  508  1      
  509  1              /*current sensor initial signal abnormal*/
  510  1              if(ptr_FltFlg->currentSensorAbnormalFlg)
  511  1                      DescMgr_DtcStatusDataReport(DTC_CURRENT_SENSOR_INITIAL_SIGNAL_ERR, DTC_TEST_FAILED);
  512  1              else
  513  1                      DescMgr_DtcStatusDataReport(DTC_CURRENT_SENSOR_INITIAL_SIGNAL_ERR, DTC_TEST_PASSED);
  514  1      
  515  1              /*motor drive bus voltage high*/
  516  1              if(ptr_FltFlg->motorVlinkVolHighFlg)
  517  1                      DescMgr_DtcStatusDataReport(DTC_MOTOR_DRIVE_BUS_VOLTAGE_HIGH, DTC_TEST_FAILED);
  518  1              else
  519  1                      DescMgr_DtcStatusDataReport(DTC_MOTOR_DRIVE_BUS_VOLTAGE_HIGH, DTC_TEST_PASSED);
  520  1      
  521  1              /*motor drive bus voltage low*/
  522  1              if(ptr_FltFlg->motorVlinkVolLowFlg)
  523  1                      DescMgr_DtcStatusDataReport(DTC_MOTOR_DRIVE_BUS_VOLTAGE_LOW, DTC_TEST_FAILED);
  524  1              else
  525  1                      DescMgr_DtcStatusDataReport(DTC_MOTOR_DRIVE_BUS_VOLTAGE_LOW, DTC_TEST_PASSED);
  526  1      
  527  1              /*motor drive fault*/
  528  1              if(ptr_FltFlg->motorPredriveFaultFlg)
  529  1                      DescMgr_DtcStatusDataReport(DTC_MOTOR_DRIVER_FAULT, DTC_TEST_FAILED);
  530  1              else
  531  1                      DescMgr_DtcStatusDataReport(DTC_MOTOR_DRIVER_FAULT, DTC_TEST_PASSED);
  532  1      
  533  1              /*motor open circuit*/
  534  1              if(ptr_FltFlg->motorOpenFlg)
  535  1                      DescMgr_DtcStatusDataReport(DTC_MOTOR_OPEN_CIRCUIT, DTC_TEST_FAILED);
  536  1              else
  537  1                      DescMgr_DtcStatusDataReport(DTC_MOTOR_OPEN_CIRCUIT, DTC_TEST_PASSED);
  538  1      
  539  1              /*motor short circuit*/
  540  1              if(ptr_FltFlg->motorShortFlg)
  541  1                      DescMgr_DtcStatusDataReport(DTC_MOTOR_SHORT_CIRCUIT, DTC_TEST_FAILED);
  542  1              else
  543  1                      DescMgr_DtcStatusDataReport(DTC_MOTOR_SHORT_CIRCUIT, DTC_TEST_PASSED);
  544  1      }
  545         
  546         
  547         #if 0
              //****************************************************************************
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 10  

              // @Function      void CanDiag_DTC_VCU_0x118MsgRollingCount()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x118 message rolling counter.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x118MsgRollingTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x118MsgRollingRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_VCU_0x118MsgRollingCount(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
                
                      CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
                  CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
                      CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
              
                      INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
                      
                      if (FALSE == bFristMsgFlag)
                      {
                              bFristMsgFlag = TRUE;
                              uRollingContinuity = 0u;
                              uPreRollingValue = uCurRollingValue;
              
                              return FALSE;
                      }
                      else
                      {
                              uPreRollingValue++;
                              if (15u == uPreRollingValue)
                              {
                                      uPreRollingValue = 0u;
                              }
              
                              if (uPreRollingValue == uCurRollingValue)
                              {
                                      uRollingContinuity++;
                              }
                              else
                              {
                                      bFristMsgFlag = FALSE;
                                      uRollingContinuity = 0u;
                              }
              
                              if (FALSE == t_canDtcErr.b0x118MsgRollingCntErr)
                              {
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 11  

                                      if (uRollingContinuity < 10u)
                                      {
                                              u0x118MsgRollingRecoverCnt = 0u;
              
                                              u0x118MsgRollingTimeoutCnt++;
                                              if (u0x118MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                              {
                                                      u0x118MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                                      t_canDtcErr.b0x118MsgRollingCntErr = TRUE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x118_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x118MsgRollingTimeoutCnt = 0u;
                                              u0x118MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x118MsgRollingCntErr = FALSE;
                                      }
                              }
                              else
                              {
                                      if (uRollingContinuity >= 10u)
                                      {
                                              u0x118MsgRollingTimeoutCnt = 0u;
              
                                              u0x118MsgRollingRecoverCnt++;
                                              if (u0x118MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                              {
                                                      u0x118MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                                      t_canDtcErr.b0x118MsgRollingCntErr = FALSE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x118_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x118MsgRollingTimeoutCnt = 0u;
                                              u0x118MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x118MsgRollingCntErr = TRUE;                              
                                      }
                              }
              
                              if (uRollingContinuity >= 10u)
                              {
                                      uRollingContinuity = 10u;
                                      return TRUE;
                              }
                              else
                              {
                                      return FALSE;   
                              }
                      }
              
                // USER CODE END
              
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 12  

              } //  End of function CanDiag_DTC_VCU_0x118MsgRollingCount
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_VCU_0x119MsgRollingCount()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x119 message rolling counter.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x119MsgRollingTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x119MsgRollingRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_VCU_0x119MsgRollingCount(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
                
                      CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
                  CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
                      CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
              
                      INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
                      
                      if (FALSE == bFristMsgFlag)
                      {
                              bFristMsgFlag = TRUE;
                              uRollingContinuity = 0u;
                              uPreRollingValue = uCurRollingValue;
              
                              return FALSE;
                      }
                      else
                      {
                              uPreRollingValue++;
                              if (15u == uPreRollingValue)
                              {
                                      uPreRollingValue = 0u;
                              }
              
                              if (uPreRollingValue == uCurRollingValue)
                              {
                                      uRollingContinuity++;
                              }
                              else
                              {
                                      bFristMsgFlag = FALSE;
                                      uRollingContinuity = 0u;
                              }
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 13  

              
                              if (FALSE == t_canDtcErr.b0x119MsgRollingCntErr)
                              {
                                      if (uRollingContinuity < 10u)
                                      {
                                              u0x119MsgRollingRecoverCnt = 0u;
              
                                              u0x119MsgRollingTimeoutCnt++;
                                              if (u0x119MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                              {
                                                      u0x119MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                                      t_canDtcErr.b0x119MsgRollingCntErr = TRUE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x119_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x119MsgRollingTimeoutCnt = 0u;
                                              u0x119MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x119MsgRollingCntErr = FALSE;
                                      }
                              }
                              else
                              {
                                      if (uRollingContinuity >= 10u)
                                      {
                                              u0x119MsgRollingTimeoutCnt = 0u;
              
                                              u0x119MsgRollingRecoverCnt++;
                                              if (u0x119MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                              {
                                                      u0x119MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                                      t_canDtcErr.b0x119MsgRollingCntErr = FALSE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x119_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x119MsgRollingTimeoutCnt = 0u;
                                              u0x119MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x119MsgRollingCntErr = TRUE;                              
                                      }
                              }
              
                              if (uRollingContinuity >= 10u)
                              {
                                      uRollingContinuity = 10u;
                                      return TRUE;
                              }
                              else
                              {
                                      return FALSE;   
                              }
                      }
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 14  

              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_VCU_0x119MsgRollingCount
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_VCU_0x126MsgRollingCount()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x126 message rolling counter.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x126MsgRollingTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x126MsgRollingRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_VCU_0x126MsgRollingCount(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
                
                      CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
                  CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
                      CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
              
                      INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
                      
                      if (FALSE == bFristMsgFlag)
                      {
                              bFristMsgFlag = TRUE;
                              uRollingContinuity = 0u;
                              uPreRollingValue = uCurRollingValue;
              
                              return FALSE;
                      }
                      else
                      {
                              uPreRollingValue++;
                              if (15u == uPreRollingValue)
                              {
                                      uPreRollingValue = 0u;
                              }
              
                              if (uPreRollingValue == uCurRollingValue)
                              {
                                      uRollingContinuity++;
                              }
                              else
                              {
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 15  

                                      bFristMsgFlag = FALSE;
                                      uRollingContinuity = 0u;
                              }
              
                              if (FALSE == t_canDtcErr.b0x126MsgRollingCntErr)
                              {
                                      if (uRollingContinuity < 10u)
                                      {
                                              u0x126MsgRollingRecoverCnt = 0u;
              
                                              u0x126MsgRollingTimeoutCnt++;
                                              if (u0x126MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                              {
                                                      u0x126MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                                      t_canDtcErr.b0x126MsgRollingCntErr = TRUE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x126_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x126MsgRollingTimeoutCnt = 0u;
                                              u0x126MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x126MsgRollingCntErr = FALSE;
                                      }
                              }
                              else
                              {
                                      if (uRollingContinuity >= 10u)
                                      {
                                              u0x126MsgRollingTimeoutCnt = 0u;
              
                                              u0x126MsgRollingRecoverCnt++;
                                              if (u0x126MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                              {
                                                      u0x126MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                                      t_canDtcErr.b0x126MsgRollingCntErr = FALSE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x126_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x126MsgRollingTimeoutCnt = 0u;
                                              u0x126MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x126MsgRollingCntErr = TRUE;                              
                                      }
                              }
              
                              if (uRollingContinuity >= 10u)
                              {
                                      uRollingContinuity = 10u;
                                      return TRUE;
                              }
                              else
                              {
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 16  

                                      return FALSE;   
                              }
                      }
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_VCU_0x126MsgRollingCount
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_MCU_0x130MsgRollingCount()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x130 message rolling counter.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x130MsgRollingTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x130MsgRollingRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_MCU_0x130MsgRollingCount(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
                
                      CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
                  CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
                      CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
              
                      INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
                      
                      if (FALSE == bFristMsgFlag)
                      {
                              bFristMsgFlag = TRUE;
                              uRollingContinuity = 0u;
                              uPreRollingValue = uCurRollingValue;
              
                              return FALSE;
                      }
                      else
                      {
                              uPreRollingValue++;
                              if (15u == uPreRollingValue)
                              {
                                      uPreRollingValue = 0u;
                              }
              
                              if (uPreRollingValue == uCurRollingValue)
                              {
                                      uRollingContinuity++;
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 17  

                              }
                              else
                              {
                                      bFristMsgFlag = FALSE;
                                      uRollingContinuity = 0u;
                              }
              
                              if (FALSE == t_canDtcErr.b0x130MsgRollingCntErr)
                              {
                                      if (uRollingContinuity < 10u)
                                      {
                                              u0x130MsgRollingRecoverCnt = 0u;
              
                                              u0x130MsgRollingTimeoutCnt++;
                                              if (u0x130MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                              {
                                                      u0x130MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                                      t_canDtcErr.b0x130MsgRollingCntErr = TRUE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x130_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x130MsgRollingTimeoutCnt = 0u;
                                              u0x130MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x130MsgRollingCntErr = FALSE;
                                      }
                              }
                              else
                              {
                                      if (uRollingContinuity >= 10u)
                                      {
                                              u0x130MsgRollingTimeoutCnt = 0u;
              
                                              u0x130MsgRollingRecoverCnt++;
                                              if (u0x130MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                              {
                                                      u0x130MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                                      t_canDtcErr.b0x130MsgRollingCntErr = FALSE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x130_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x130MsgRollingTimeoutCnt = 0u;
                                              u0x130MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x130MsgRollingCntErr = TRUE;                              
                                      }
                              }
              
                              if (uRollingContinuity >= 10u)
                              {
                                      uRollingContinuity = 10u;
                                      return TRUE;
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 18  

                              }
                              else
                              {
                                      return FALSE;   
                              }
                      }
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_MCU_0x130MsgRollingCount
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_MCU_0x132MsgRollingCount()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x132 message rolling counter.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x132MsgRollingTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x132MsgRollingRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_MCU_0x132MsgRollingCount(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
                
                      CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
                  CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
                      CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
              
                      INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
                      
                      if (FALSE == bFristMsgFlag)
                      {
                              bFristMsgFlag = TRUE;
                              uRollingContinuity = 0u;
                              uPreRollingValue = uCurRollingValue;
              
                              return FALSE;
                      }
                      else
                      {
                              uPreRollingValue++;
                              if (15u == uPreRollingValue)
                              {
                                      uPreRollingValue = 0u;
                              }
              
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 19  

                              if (uPreRollingValue == uCurRollingValue)
                              {
                                      uRollingContinuity++;
                              }
                              else
                              {
                                      bFristMsgFlag = FALSE;
                                      uRollingContinuity = 0u;
                              }
              
                              if (FALSE == t_canDtcErr.b0x132MsgRollingCntErr)
                              {
                                      if (uRollingContinuity < 10u)
                                      {
                                              u0x132MsgRollingRecoverCnt = 0u;
              
                                              u0x132MsgRollingTimeoutCnt++;
                                              if (u0x132MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                              {
                                                      u0x132MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                                      t_canDtcErr.b0x132MsgRollingCntErr = TRUE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x132_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x132MsgRollingTimeoutCnt = 0u;
                                              u0x132MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x132MsgRollingCntErr = FALSE;
                                      }
                              }
                              else
                              {
                                      if (uRollingContinuity >= 10u)
                                      {
                                              u0x132MsgRollingTimeoutCnt = 0u;
              
                                              u0x132MsgRollingRecoverCnt++;
                                              if (u0x132MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                              {
                                                      u0x132MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                                      t_canDtcErr.b0x132MsgRollingCntErr = FALSE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x132_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x132MsgRollingTimeoutCnt = 0u;
                                              u0x132MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x132MsgRollingCntErr = TRUE;                              
                                      }
                              }
              
                              if (uRollingContinuity >= 10u)
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 20  

                              {
                                      uRollingContinuity = 10u;
                                      return TRUE;
                              }
                              else
                              {
                                      return FALSE;   
                              }
                      }
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_MCU_0x132MsgRollingCount
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_BMS_0x140MsgRollingCount()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x140 message rolling counter.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x140MsgRollingTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x140MsgRollingRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_BMS_0x140MsgRollingCount(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
                
                      CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
                  CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
                      CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
              
                      INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
                      
                      if (FALSE == bFristMsgFlag)
                      {
                              bFristMsgFlag = TRUE;
                              uRollingContinuity = 0u;
                              uPreRollingValue = uCurRollingValue;
              
                              return FALSE;
                      }
                      else
                      {
                              uPreRollingValue++;
                              if (15u == uPreRollingValue)
                              {
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 21  

                                      uPreRollingValue = 0u;
                              }
              
                              if (uPreRollingValue == uCurRollingValue)
                              {
                                      uRollingContinuity++;
                              }
                              else
                              {
                                      bFristMsgFlag = FALSE;
                                      uRollingContinuity = 0u;
                              }
              
                              if (FALSE == t_canDtcErr.b0x140MsgRollingCntErr)
                              {
                                      if (uRollingContinuity < 10u)
                                      {
                                              u0x140MsgRollingRecoverCnt = 0u;
              
                                              u0x140MsgRollingTimeoutCnt++;
                                              if (u0x140MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                              {
                                                      u0x140MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                                      t_canDtcErr.b0x140MsgRollingCntErr = TRUE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x140_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x140MsgRollingTimeoutCnt = 0u;
                                              u0x140MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x140MsgRollingCntErr = FALSE;
                                      }
                              }
                              else
                              {
                                      if (uRollingContinuity >= 10u)
                                      {
                                              u0x140MsgRollingTimeoutCnt = 0u;
              
                                              u0x140MsgRollingRecoverCnt++;
                                              if (u0x140MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                              {
                                                      u0x140MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                                      t_canDtcErr.b0x140MsgRollingCntErr = FALSE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x140_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x140MsgRollingTimeoutCnt = 0u;
                                              u0x140MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x140MsgRollingCntErr = TRUE;                              
                                      }
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 22  

                              }
              
                              if (uRollingContinuity >= 10u)
                              {
                                      uRollingContinuity = 10u;
                                      return TRUE;
                              }
                              else
                              {
                                      return FALSE;   
                              }
                      }
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_BMS_0x140MsgRollingCount
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_BMS_0x148MsgRollingCount()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x148 message rolling counter.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x148MsgRollingTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x148MsgRollingRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_BMS_0x148MsgRollingCount(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
                
                      CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
                  CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
                      CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
              
                      INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
                      
                      if (FALSE == bFristMsgFlag)
                      {
                              bFristMsgFlag = TRUE;
                              uRollingContinuity = 0u;
                              uPreRollingValue = uCurRollingValue;
              
                              return FALSE;
                      }
                      else
                      {
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 23  

                              uPreRollingValue++;
                              if (15u == uPreRollingValue)
                              {
                                      uPreRollingValue = 0u;
                              }
              
                              if (uPreRollingValue == uCurRollingValue)
                              {
                                      uRollingContinuity++;
                              }
                              else
                              {
                                      bFristMsgFlag = FALSE;
                                      uRollingContinuity = 0u;
                              }
              
                              if (FALSE == t_canDtcErr.b0x148MsgRollingCntErr)
                              {
                                      if (uRollingContinuity < 10u)
                                      {
                                              u0x148MsgRollingRecoverCnt = 0u;
              
                                              u0x148MsgRollingTimeoutCnt++;
                                              if (u0x148MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                              {
                                                      u0x148MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                                      t_canDtcErr.b0x148MsgRollingCntErr = TRUE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x148_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x148MsgRollingTimeoutCnt = 0u;
                                              u0x148MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x148MsgRollingCntErr = FALSE;
                                      }
                              }
                              else
                              {
                                      if (uRollingContinuity >= 10u)
                                      {
                                              u0x148MsgRollingTimeoutCnt = 0u;
              
                                              u0x148MsgRollingRecoverCnt++;
                                              if (u0x148MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                              {
                                                      u0x148MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                                      t_canDtcErr.b0x148MsgRollingCntErr = FALSE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x148_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x148MsgRollingTimeoutCnt = 0u;
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 24  

                                              u0x148MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x148MsgRollingCntErr = TRUE;                              
                                      }
                              }
              
                              if (uRollingContinuity >= 10u)
                              {
                                      uRollingContinuity = 10u;
                                      return TRUE;
                              }
                              else
                              {
                                      return FALSE;   
                              }
                      }
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_BMS_0x148MsgRollingCount
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_BMS_0x155MsgRollingCount()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x155 message rolling counter.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x155MsgRollingTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x155MsgRollingRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_BMS_0x155MsgRollingCount(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
                
                      CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
                  CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
                      CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
              
                      INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
                      
                      if (FALSE == bFristMsgFlag)
                      {
                              bFristMsgFlag = TRUE;
                              uRollingContinuity = 0u;
                              uPreRollingValue = uCurRollingValue;
              
                              return FALSE;
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 25  

                      }
                      else
                      {
                              uPreRollingValue++;
                              if (15u == uPreRollingValue)
                              {
                                      uPreRollingValue = 0u;
                              }
              
                              if (uPreRollingValue == uCurRollingValue)
                              {
                                      uRollingContinuity++;
                              }
                              else
                              {
                                      bFristMsgFlag = FALSE;
                                      uRollingContinuity = 0u;
                              }
              
                              if (FALSE == t_canDtcErr.b0x155MsgRollingCntErr)
                              {
                                      if (uRollingContinuity < 10u)
                                      {
                                              u0x155MsgRollingRecoverCnt = 0u;
              
                                              u0x155MsgRollingTimeoutCnt++;
                                              if (u0x155MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                              {
                                                      u0x155MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                                      t_canDtcErr.b0x155MsgRollingCntErr = TRUE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x155_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x155MsgRollingTimeoutCnt = 0u;
                                              u0x155MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x155MsgRollingCntErr = FALSE;
                                      }
                              }
                              else
                              {
                                      if (uRollingContinuity >= 10u)
                                      {
                                              u0x155MsgRollingTimeoutCnt = 0u;
              
                                              u0x155MsgRollingRecoverCnt++;
                                              if (u0x155MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                              {
                                                      u0x155MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                                      t_canDtcErr.b0x155MsgRollingCntErr = FALSE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x155_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                                      }
                                              }
                                      }
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 26  

                                      else
                                      {
                                              u0x155MsgRollingTimeoutCnt = 0u;
                                              u0x155MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x155MsgRollingCntErr = TRUE;                              
                                      }
                              }
              
                              if (uRollingContinuity >= 10u)
                              {
                                      uRollingContinuity = 10u;
                                      return TRUE;
                              }
                              else
                              {
                                      return FALSE;   
                              }
                      }
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_BMS_0x155MsgRollingCount
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_VCU_0x16eMsgRollingCount()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x16E message rolling counter.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x16eMsgRollingTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x16eMsgRollingRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_VCU_0x16eMsgRollingCount(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
                
                      CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
                  CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
                      CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
              
                      INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
                      
                      if (FALSE == bFristMsgFlag)
                      {
                              bFristMsgFlag = TRUE;
                              uRollingContinuity = 0u;
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 27  

                              uPreRollingValue = uCurRollingValue;
              
                              return FALSE;
                      }
                      else
                      {
                              uPreRollingValue++;
                              if (15u == uPreRollingValue)
                              {
                                      uPreRollingValue = 0u;
                              }
              
                              if (uPreRollingValue == uCurRollingValue)
                              {
                                      uRollingContinuity++;
                              }
                              else
                              {
                                      bFristMsgFlag = FALSE;
                                      uRollingContinuity = 0u;
                              }
              
                              if (FALSE == t_canDtcErr.b0x16eMsgRollingCntErr)
                              {
                                      if (uRollingContinuity < 10u)
                                      {
                                              u0x16eMsgRollingRecoverCnt = 0u;
              
                                              u0x16eMsgRollingTimeoutCnt++;
                                              if (u0x16eMsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                              {
                                                      u0x16eMsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                                      t_canDtcErr.b0x16eMsgRollingCntErr = TRUE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x16E_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x16eMsgRollingTimeoutCnt = 0u;
                                              u0x16eMsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x16eMsgRollingCntErr = FALSE;
                                      }
                              }
                              else
                              {
                                      if (uRollingContinuity >= 10u)
                                      {
                                              u0x16eMsgRollingTimeoutCnt = 0u;
              
                                              u0x16eMsgRollingRecoverCnt++;
                                              if (u0x16eMsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                              {
                                                      u0x16eMsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                                      t_canDtcErr.b0x16eMsgRollingCntErr = FALSE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x16E_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 28  

                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x16eMsgRollingTimeoutCnt = 0u;
                                              u0x16eMsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x16eMsgRollingCntErr = TRUE;                              
                                      }
                              }
              
                              if (uRollingContinuity >= 10u)
                              {
                                      uRollingContinuity = 10u;
                                      return TRUE;
                              }
                              else
                              {
                                      return FALSE;   
                              }
                      }
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_VCU_0x16eMsgRollingCount
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_VCU_0x16fMsgRollingCount()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x16F message rolling counter.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x16fMsgRollingTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x16fMsgRollingRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_VCU_0x16fMsgRollingCount(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
                
                      CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
                  CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
                      CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
              
                      INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
                      
                      if (FALSE == bFristMsgFlag)
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 29  

                      {
                              bFristMsgFlag = TRUE;
                              uRollingContinuity = 0u;
                              uPreRollingValue = uCurRollingValue;
              
                              return FALSE;
                      }
                      else
                      {
                              uPreRollingValue++;
                              if (15u == uPreRollingValue)
                              {
                                      uPreRollingValue = 0u;
                              }
              
                              if (uPreRollingValue == uCurRollingValue)
                              {
                                      uRollingContinuity++;
                              }
                              else
                              {
                                      bFristMsgFlag = FALSE;
                                      uRollingContinuity = 0u;
                              }
              
                              if (FALSE == t_canDtcErr.b0x16fMsgRollingCntErr)
                              {
                                      if (uRollingContinuity < 10u)
                                      {
                                              u0x16fMsgRollingRecoverCnt = 0u;
              
                                              u0x16fMsgRollingTimeoutCnt++;
                                              if (u0x16fMsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                              {
                                                      u0x16fMsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                                      t_canDtcErr.b0x16fMsgRollingCntErr = TRUE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x16F_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x16fMsgRollingTimeoutCnt = 0u;
                                              u0x16fMsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x16fMsgRollingCntErr = FALSE;
                                      }
                              }
                              else
                              {
                                      if (uRollingContinuity >= 10u)
                                      {
                                              u0x16fMsgRollingTimeoutCnt = 0u;
              
                                              u0x16fMsgRollingRecoverCnt++;
                                              if (u0x16fMsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                              {
                                                      u0x16fMsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                                      t_canDtcErr.b0x16fMsgRollingCntErr = FALSE;
              
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 30  

                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x16F_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x16fMsgRollingTimeoutCnt = 0u;
                                              u0x16fMsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x16fMsgRollingCntErr = TRUE;                              
                                      }
                              }
              
                              if (uRollingContinuity >= 10u)
                              {
                                      uRollingContinuity = 10u;
                                      return TRUE;
                              }
                              else
                              {
                                      return FALSE;   
                              }
                      }
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_VCU_0x16fMsgRollingCount
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_GW_0x278MsgRollingCount()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x278 message rolling counter.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x278MsgRollingTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x278MsgRollingRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_GW_0x278MsgRollingCount(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
                
                      CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
                  CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
                      CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
              
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 31  

                      INT8U uCurRollingValue = (INT8U)((rcvObject[6] & 0x0F) >> 4u);  
                      
                      if (FALSE == bFristMsgFlag)
                      {
                              bFristMsgFlag = TRUE;
                              uRollingContinuity = 0u;
                              uPreRollingValue = uCurRollingValue;
              
                              return FALSE;
                      }
                      else
                      {
                              uPreRollingValue++;
                              if (15u == uPreRollingValue)
                              {
                                      uPreRollingValue = 0u;
                              }
              
                              if (uPreRollingValue == uCurRollingValue)
                              {
                                      uRollingContinuity++;
                              }
                              else
                              {
                                      bFristMsgFlag = FALSE;
                                      uRollingContinuity = 0u;
                              }
              
                              if (FALSE == t_canDtcErr.b0x278MsgRollingCntErr)
                              {
                                      if (uRollingContinuity < 10u)
                                      {
                                              u0x278MsgRollingRecoverCnt = 0u;
              
                                              u0x278MsgRollingTimeoutCnt++;
                                              if (u0x278MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                              {
                                                      u0x278MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                                      t_canDtcErr.b0x278MsgRollingCntErr = TRUE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x278_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x278MsgRollingTimeoutCnt = 0u;
                                              u0x278MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x278MsgRollingCntErr = FALSE;
                                      }
                              }
                              else
                              {
                                      if (uRollingContinuity >= 10u)
                                      {
                                              u0x278MsgRollingTimeoutCnt = 0u;
              
                                              u0x278MsgRollingRecoverCnt++;
                                              if (u0x278MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                              {
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 32  

                                                      u0x278MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                                      t_canDtcErr.b0x278MsgRollingCntErr = FALSE;
              
                                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                                      {
                                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x278_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              u0x278MsgRollingTimeoutCnt = 0u;
                                              u0x278MsgRollingRecoverCnt = 0u;
                                              t_canDtcErr.b0x278MsgRollingCntErr = TRUE;                              
                                      }
                              }
              
                              if (uRollingContinuity >= 10u)
                              {
                                      uRollingContinuity = 10u;
                                      return TRUE;
                              }
                              else
                              {
                                      return FALSE;   
                              }
                      }
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_GW_0x278MsgRollingCount
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_VCU_0x118MsgChecksum()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x118 message checksum.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x118MsgChecksumTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x118MsgChecksumRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_VCU_0x118MsgChecksum(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
              
                      INT8U i;
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 33  

                      INT8U uChecksumValue = 0u;
              
                      for (i = 0u; i < 7; i++)
                      {
                              uChecksumValue ^= rcvObject[i]; 
                      }
              
                      if (FALSE == t_canDtcErr.b0x118MsgChecksumErr)
                      {
                              if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x118MsgChecksumRecoverCnt = 0u;
              
                                      u0x118MsgChecksumTimeoutCnt++;
                                      if (u0x118MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                      {
                                              u0x118MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                              t_canDtcErr.b0x118MsgChecksumErr = TRUE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x118_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                              }
                                      }
                              }
                              else
                              {
                                      u0x118MsgChecksumTimeoutCnt = 0u;
                                      u0x118MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x118MsgChecksumErr = FALSE;
                              }
                      }
                      else
                      {
                              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x118MsgChecksumTimeoutCnt = 0u;
              
                                      u0x118MsgChecksumRecoverCnt++;
                                      if (u0x118MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                      {
                                              u0x118MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                              t_canDtcErr.b0x118MsgChecksumErr = FALSE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x118_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                              }                               
                                      }
                              }
                              else
                              {
                                      u0x118MsgChecksumTimeoutCnt = 0u;
                                      u0x118MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x118MsgChecksumErr = TRUE;                        
                              }
                      }
              
                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                      {
                              return TRUE;
                      }
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 34  

                      else
                      {
                              return FALSE;
                      }       
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_VCU_0x118MsgChecksum
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_VCU_0x119MsgChecksum()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x119 message checksum.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x119MsgChecksumTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x119MsgChecksumRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_VCU_0x119MsgChecksum(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
              
                      INT8U i;
                      INT8U uChecksumValue = 0u;
              
                      for (i = 0u; i < 7; i++)
                      {
                              uChecksumValue ^= rcvObject[i]; 
                      }
              
                      if (FALSE == t_canDtcErr.b0x119MsgChecksumErr)
                      {
                              if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x119MsgChecksumRecoverCnt = 0u;
              
                                      u0x119MsgChecksumTimeoutCnt++;
                                      if (u0x119MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                      {
                                              u0x119MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                              t_canDtcErr.b0x119MsgChecksumErr = TRUE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x119_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                              }
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 35  

                                      }
                              }
                              else
                              {
                                      u0x119MsgChecksumTimeoutCnt = 0u;
                                      u0x119MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x119MsgChecksumErr = FALSE;
                              }
                      }
                      else
                      {
                              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x119MsgChecksumTimeoutCnt = 0u;
              
                                      u0x119MsgChecksumRecoverCnt++;
                                      if (u0x119MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                      {
                                              u0x119MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                              t_canDtcErr.b0x119MsgChecksumErr = FALSE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x119_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                              }                               
                                      }
                              }
                              else
                              {
                                      u0x119MsgChecksumTimeoutCnt = 0u;
                                      u0x119MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x119MsgChecksumErr = TRUE;                        
                              }
                      }
              
                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                      {
                              return TRUE;
                      }
                      else
                      {
                              return FALSE;
                      }       
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_VCU_0x119MsgChecksum
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_VCU_0x126MsgChecksum()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x126 message checksum.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 36  

              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x126MsgChecksumTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x126MsgChecksumRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_VCU_0x126MsgChecksum(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
              
                      INT8U i;
                      INT8U uChecksumValue = 0u;
              
                      for (i = 0u; i < 7; i++)
                      {
                              uChecksumValue ^= rcvObject[i]; 
                      }
              
                      if (FALSE == t_canDtcErr.b0x126MsgChecksumErr)
                      {
                              if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x126MsgChecksumRecoverCnt = 0u;
              
                                      u0x126MsgChecksumTimeoutCnt++;
                                      if (u0x126MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                      {
                                              u0x126MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                              t_canDtcErr.b0x126MsgChecksumErr = TRUE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x126_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                              }
                                      }
                              }
                              else
                              {
                                      u0x126MsgChecksumTimeoutCnt = 0u;
                                      u0x126MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x126MsgChecksumErr = FALSE;
                              }
                      }
                      else
                      {
                              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x126MsgChecksumTimeoutCnt = 0u;
              
                                      u0x126MsgChecksumRecoverCnt++;
                                      if (u0x126MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                      {
                                              u0x126MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                              t_canDtcErr.b0x126MsgChecksumErr = FALSE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 37  

                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x126_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                              }                               
                                      }
                              }
                              else
                              {
                                      u0x126MsgChecksumTimeoutCnt = 0u;
                                      u0x126MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x126MsgChecksumErr = TRUE;                        
                              }
                      }
              
                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                      {
                              return TRUE;
                      }
                      else
                      {
                              return FALSE;
                      }       
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_VCU_0x126MsgChecksum
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_MCU_0x130MsgChecksum()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x130 message checksum.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x130MsgChecksumTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x130MsgChecksumRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_MCU_0x130MsgChecksum(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
              
                      INT8U i;
                      INT8U uChecksumValue = 0u;
              
                      for (i = 0u; i < 7; i++)
                      {
                              uChecksumValue ^= rcvObject[i]; 
                      }
              
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 38  

                      if (FALSE == t_canDtcErr.b0x130MsgChecksumErr)
                      {
                              if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x130MsgChecksumRecoverCnt = 0u;
              
                                      u0x130MsgChecksumTimeoutCnt++;
                                      if (u0x130MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                      {
                                              u0x130MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                              t_canDtcErr.b0x130MsgChecksumErr = TRUE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x130_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                              }
                                      }
                              }
                              else
                              {
                                      u0x130MsgChecksumTimeoutCnt = 0u;
                                      u0x130MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x130MsgChecksumErr = FALSE;
                              }
                      }
                      else
                      {
                              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x130MsgChecksumTimeoutCnt = 0u;
              
                                      u0x130MsgChecksumRecoverCnt++;
                                      if (u0x130MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                      {
                                              u0x130MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                              t_canDtcErr.b0x130MsgChecksumErr = FALSE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x130_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                              }                               
                                      }
                              }
                              else
                              {
                                      u0x130MsgChecksumTimeoutCnt = 0u;
                                      u0x130MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x130MsgChecksumErr = TRUE;                        
                              }
                      }
              
                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                      {
                              return TRUE;
                      }
                      else
                      {
                              return FALSE;
                      }       
              
                // USER CODE END
              
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 39  

              } //  End of function CanDiag_DTC_MCU_0x130MsgChecksum
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_MCU_0x132MsgChecksum()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x132 message checksum.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x132MsgChecksumTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x132MsgChecksumRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_MCU_0x132MsgChecksum(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
              
                      INT8U i;
                      INT8U uChecksumValue = 0u;
              
                      for (i = 0u; i < 7; i++)
                      {
                              uChecksumValue ^= rcvObject[i]; 
                      }
              
                      if (FALSE == t_canDtcErr.b0x132MsgChecksumErr)
                      {
                              if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x132MsgChecksumRecoverCnt = 0u;
              
                                      u0x132MsgChecksumTimeoutCnt++;
                                      if (u0x132MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                      {
                                              u0x132MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                              t_canDtcErr.b0x132MsgChecksumErr = TRUE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x132_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                              }
                                      }
                              }
                              else
                              {
                                      u0x132MsgChecksumTimeoutCnt = 0u;
                                      u0x132MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x132MsgChecksumErr = FALSE;
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 40  

                              }
                      }
                      else
                      {
                              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x132MsgChecksumTimeoutCnt = 0u;
              
                                      u0x132MsgChecksumRecoverCnt++;
                                      if (u0x132MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                      {
                                              u0x132MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                              t_canDtcErr.b0x132MsgChecksumErr = FALSE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x132_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                              }                               
                                      }
                              }
                              else
                              {
                                      u0x132MsgChecksumTimeoutCnt = 0u;
                                      u0x132MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x132MsgChecksumErr = TRUE;                        
                              }
                      }
              
                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                      {
                              return TRUE;
                      }
                      else
                      {
                              return FALSE;
                      }       
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_MCU_0x132MsgChecksum
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_BMS_0x140MsgChecksum()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x140 message checksum.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x140MsgChecksumTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x140MsgChecksumRecoverCnt = 0u;
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 41  

              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_BMS_0x140MsgChecksum(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
              
                      INT8U i;
                      INT8U uChecksumValue = 0u;
              
                      for (i = 0u; i < 7; i++)
                      {
                              uChecksumValue ^= rcvObject[i]; 
                      }
              
                      if (FALSE == t_canDtcErr.b0x140MsgChecksumErr)
                      {
                              if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x140MsgChecksumRecoverCnt = 0u;
              
                                      u0x140MsgChecksumTimeoutCnt++;
                                      if (u0x140MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                      {
                                              u0x140MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                              t_canDtcErr.b0x140MsgChecksumErr = TRUE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x140_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                              }
                                      }
                              }
                              else
                              {
                                      u0x140MsgChecksumTimeoutCnt = 0u;
                                      u0x140MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x140MsgChecksumErr = FALSE;
                              }
                      }
                      else
                      {
                              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x140MsgChecksumTimeoutCnt = 0u;
              
                                      u0x140MsgChecksumRecoverCnt++;
                                      if (u0x140MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                      {
                                              u0x140MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                              t_canDtcErr.b0x140MsgChecksumErr = FALSE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x140_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                              }                               
                                      }
                              }
                              else
                              {
                                      u0x140MsgChecksumTimeoutCnt = 0u;
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 42  

                                      u0x140MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x140MsgChecksumErr = TRUE;                        
                              }
                      }
              
                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                      {
                              return TRUE;
                      }
                      else
                      {
                              return FALSE;
                      }       
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_BMS_0x140MsgChecksum
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_BMS_0x148MsgChecksum()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x148 message checksum.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x148MsgChecksumTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x148MsgChecksumRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_BMS_0x148MsgChecksum(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
              
                      INT8U i;
                      INT8U uChecksumValue = 0u;
              
                      for (i = 0u; i < 7; i++)
                      {
                              uChecksumValue ^= rcvObject[i]; 
                      }
              
                      if (FALSE == t_canDtcErr.b0x148MsgChecksumErr)
                      {
                              if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x148MsgChecksumRecoverCnt = 0u;
              
                                      u0x148MsgChecksumTimeoutCnt++;
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 43  

                                      if (u0x148MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                      {
                                              u0x148MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                              t_canDtcErr.b0x148MsgChecksumErr = TRUE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x148_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                              }
                                      }
                              }
                              else
                              {
                                      u0x148MsgChecksumTimeoutCnt = 0u;
                                      u0x148MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x148MsgChecksumErr = FALSE;
                              }
                      }
                      else
                      {
                              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x148MsgChecksumTimeoutCnt = 0u;
              
                                      u0x148MsgChecksumRecoverCnt++;
                                      if (u0x148MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                      {
                                              u0x148MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                              t_canDtcErr.b0x148MsgChecksumErr = FALSE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x148_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                              }                               
                                      }
                              }
                              else
                              {
                                      u0x148MsgChecksumTimeoutCnt = 0u;
                                      u0x148MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x148MsgChecksumErr = TRUE;                        
                              }
                      }
              
                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                      {
                              return TRUE;
                      }
                      else
                      {
                              return FALSE;
                      }       
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_BMS_0x148MsgChecksum
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_BMS_0x155MsgChecksum()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x155 message checksum.
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 44  

              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x155MsgChecksumTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x155MsgChecksumRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_BMS_0x155MsgChecksum(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
              
                      INT8U i;
                      INT8U uChecksumValue = 0u;
              
                      for (i = 0u; i < 7; i++)
                      {
                              uChecksumValue ^= rcvObject[i]; 
                      }
              
                      if (FALSE == t_canDtcErr.b0x155MsgChecksumErr)
                      {
                              if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x155MsgChecksumRecoverCnt = 0u;
              
                                      u0x155MsgChecksumTimeoutCnt++;
                                      if (u0x155MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                      {
                                              u0x155MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                              t_canDtcErr.b0x155MsgChecksumErr = TRUE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x155_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                              }
                                      }
                              }
                              else
                              {
                                      u0x155MsgChecksumTimeoutCnt = 0u;
                                      u0x155MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x155MsgChecksumErr = FALSE;
                              }
                      }
                      else
                      {
                              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x155MsgChecksumTimeoutCnt = 0u;
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 45  

              
                                      u0x155MsgChecksumRecoverCnt++;
                                      if (u0x155MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                      {
                                              u0x155MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                              t_canDtcErr.b0x155MsgChecksumErr = FALSE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x155_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                              }                               
                                      }
                              }
                              else
                              {
                                      u0x155MsgChecksumTimeoutCnt = 0u;
                                      u0x155MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x155MsgChecksumErr = TRUE;                        
                              }
                      }
              
                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                      {
                              return TRUE;
                      }
                      else
                      {
                              return FALSE;
                      }       
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_BMS_0x155MsgChecksum
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_VCU_0x16eMsgChecksum()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x16E message checksum.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x16eMsgChecksumTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x16eMsgChecksumRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_VCU_0x16eMsgChecksum(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 46  

              
                      INT8U i;
                      INT8U uChecksumValue = 0u;
              
                      for (i = 0u; i < 7; i++)
                      {
                              uChecksumValue ^= rcvObject[i]; 
                      }
              
                      if (FALSE == t_canDtcErr.b0x16eMsgChecksumErr)
                      {
                              if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x16eMsgChecksumRecoverCnt = 0u;
              
                                      u0x16eMsgChecksumTimeoutCnt++;
                                      if (u0x16eMsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                      {
                                              u0x16eMsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                              t_canDtcErr.b0x16eMsgChecksumErr = TRUE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x16E_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                              }
                                      }
                              }
                              else
                              {
                                      u0x16eMsgChecksumTimeoutCnt = 0u;
                                      u0x16eMsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x16eMsgChecksumErr = FALSE;
                              }
                      }
                      else
                      {
                              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x16eMsgChecksumTimeoutCnt = 0u;
              
                                      u0x16eMsgChecksumRecoverCnt++;
                                      if (u0x16eMsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                      {
                                              u0x16eMsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                              t_canDtcErr.b0x16eMsgChecksumErr = FALSE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x16E_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                              }                               
                                      }
                              }
                              else
                              {
                                      u0x16eMsgChecksumTimeoutCnt = 0u;
                                      u0x16eMsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x16eMsgChecksumErr = TRUE;                        
                              }
                      }
              
                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                      {
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 47  

                              return TRUE;
                      }
                      else
                      {
                              return FALSE;
                      }       
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_VCU_0x16eMsgChecksum
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_VCU_0x16fMsgChecksum()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x16F message checksum.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x16fMsgChecksumTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x16fMsgChecksumRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_VCU_0x16fMsgChecksum(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
              
                      INT8U i;
                      INT8U uChecksumValue = 0u;
              
                      for (i = 0u; i < 7; i++)
                      {
                              uChecksumValue ^= rcvObject[i]; 
                      }
              
                      if (FALSE == t_canDtcErr.b0x16fMsgChecksumErr)
                      {
                              if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x16fMsgChecksumRecoverCnt = 0u;
              
                                      u0x16fMsgChecksumTimeoutCnt++;
                                      if (u0x16fMsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                      {
                                              u0x16fMsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                              t_canDtcErr.b0x16fMsgChecksumErr = TRUE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 48  

                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x16F_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                              }
                                      }
                              }
                              else
                              {
                                      u0x16fMsgChecksumTimeoutCnt = 0u;
                                      u0x16fMsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x16fMsgChecksumErr = FALSE;
                              }
                      }
                      else
                      {
                              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                              {
                                      u0x16fMsgChecksumTimeoutCnt = 0u;
              
                                      u0x16fMsgChecksumRecoverCnt++;
                                      if (u0x16fMsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                      {
                                              u0x16fMsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                              t_canDtcErr.b0x16fMsgChecksumErr = FALSE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x16F_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                              }                               
                                      }
                              }
                              else
                              {
                                      u0x16fMsgChecksumTimeoutCnt = 0u;
                                      u0x16fMsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x16fMsgChecksumErr = TRUE;                        
                              }
                      }
              
                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
                      {
                              return TRUE;
                      }
                      else
                      {
                              return FALSE;
                      }       
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_VCU_0x16fMsgChecksum
              
              //****************************************************************************
              // @Function      void CanDiag_DTC_GW_0x278MsgChecksum()
              //
              //----------------------------------------------------------------------------
              // @Description   This function check 0x278 message checksum.
              //
              //----------------------------------------------------------------------------
              // @Returnvalue   None
              //
              //----------------------------------------------------------------------------
              // @Parameters    None 
              //
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 49  

              //----------------------------------------------------------------------------
              // @Date          2020-03-04
              //
              //****************************************************************************
              
              // USER CODE BEGIN (If_TxConfirmation,1)
              
              CAN_DIAG_STAT INT8U u0x278MsgChecksumTimeoutCnt = 0u;
              CAN_DIAG_STAT INT8U u0x278MsgChecksumRecoverCnt = 0u;
              
              // USER CODE END
              
              BOOLEAN CanDiag_DTC_GW_0x278MsgChecksum(CanReceiveHandle* rcvObject)
              {
              
                // USER CODE BEGIN (If_TxConfirmation,2)
              
                      INT8U i;
                      INT8U uChecksumValue = 0u;
              
                      for (i = 0u; i < 7; i++)
                      {
                              uChecksumValue ^= rcvObject[i]; 
                      }
              
                      if (FALSE == t_canDtcErr.b0x278MsgChecksumErr)
                      {
                              if (uChecksumValue != (INT8U)(rcvObject[7]))
                              {
                                      u0x278MsgChecksumRecoverCnt = 0u;
              
                                      u0x278MsgChecksumTimeoutCnt++;
                                      if (u0x278MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
                                      {
                                              u0x278MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
                                              t_canDtcErr.b0x278MsgChecksumErr = TRUE;
              
                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x278_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
                                              }
                                      }
                              }
                              else
                              {
                                      u0x278MsgChecksumTimeoutCnt = 0u;
                                      u0x278MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x278MsgChecksumErr = FALSE;
                              }
                      }
                      else
                      {
                              if (uChecksumValue == (INT8U)(rcvObject[7]))
                              {
                                      u0x278MsgChecksumTimeoutCnt = 0u;
              
                                      u0x278MsgChecksumRecoverCnt++;
                                      if (u0x278MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
                                      {
                                              u0x278MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
                                              t_canDtcErr.b0x278MsgChecksumErr = FALSE;
              
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 50  

                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
                                              {
                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x278_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
                                              }                               
                                      }
                              }
                              else
                              {
                                      u0x278MsgChecksumTimeoutCnt = 0u;
                                      u0x278MsgChecksumRecoverCnt = 0u;
                                      t_canDtcErr.b0x278MsgChecksumErr = TRUE;                        
                              }
                      }
              
                      if (uChecksumValue == (INT8U)(rcvObject[7]))
                      {
                              return TRUE;
                      }
                      else
                      {
                              return FALSE;
                      }       
              
                // USER CODE END
              
              } //  End of function CanDiag_DTC_GW_0x278MsgChecksum
              
              #endif
 3057         //****************************************************************************
 3058         // @Function      void CanDiag_DTC_BusOff()
 3059         //
 3060         //----------------------------------------------------------------------------
 3061         // @Description   This function check can bus off.
 3062         //
 3063         //----------------------------------------------------------------------------
 3064         // @Returnvalue   None
 3065         //
 3066         //----------------------------------------------------------------------------
 3067         // @Parameters    None 
 3068         //
 3069         //----------------------------------------------------------------------------
 3070         // @Date          2020-03-04
 3071         //
 3072         //****************************************************************************
 3073         
 3074         // USER CODE BEGIN (If_TxConfirmation,1)
 3075         
 3076         CAN_DIAG_STAT INT8U uCanBusOffTimeoutCnt = 0u;
 3077         CAN_DIAG_STAT INT8U uCanBusOffRecoverCnt = 0u;
 3078         
 3079         // USER CODE END
 3080         
 3081         BOOLEAN CanDiag_DTC_BusOff(void)
 3082         {
 3083  1      
 3084  1        // USER CODE BEGIN (If_TxConfirmation,2)
 3085  1              
 3086  1              if (FALSE == t_canDtcErr.bCanBusOffErr)
 3087  1              {
 3088  2                      uCanBusOffRecoverCnt = 0u;
 3089  2      
 3090  2                      if (BUSOFF_SHUTDOWN_ERR == CanNm_GetBusoffStatus())
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 51  

 3091  2                      {
 3092  3                              uCanBusOffTimeoutCnt++;
 3093  3                              if (uCanBusOffTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 3094  3                              {
 3095  4                                      uCanBusOffTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 3096  4                                      t_canDtcErr.bCanBusOffErr = TRUE;
 3097  4      
 3098  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 3099  4                                      {
 3100  5                                              DescMgr_DtcStatusDataReport(DTC_VEHICLE_CAN_BUS_OFF, DTC_TEST_FAILED);
 3101  5                                      }                               
 3102  4                              }
 3103  3                      }
 3104  2                      else
 3105  2                      {
 3106  3                              uCanBusOffTimeoutCnt = 0u;
 3107  3                              uCanBusOffRecoverCnt = 0u;
 3108  3                              t_canDtcErr.bCanBusOffErr = FALSE;
 3109  3                      }
 3110  2              }
 3111  1              else
 3112  1              {
 3113  2                      uCanBusOffTimeoutCnt = 0u;
 3114  2      
 3115  2                      uCanBusOffRecoverCnt++;
 3116  2                      if (BUSOFF_NORMAL == CanNm_GetBusoffStatus())
 3117  2                      {
 3118  3                              uCanBusOffRecoverCnt = MESSAGE_RECOVER_CYCLE;
 3119  3                              t_canDtcErr.bCanBusOffErr = FALSE;
 3120  3      
 3121  3                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 3122  3                              {
 3123  4                                      DescMgr_DtcStatusDataReport(DTC_VEHICLE_CAN_BUS_OFF, DTC_TEST_PASSED);
 3124  4                              }                       
 3125  3                              
 3126  3                      }
 3127  2                      else
 3128  2                      {
 3129  3                              uCanBusOffTimeoutCnt = 0u;
 3130  3                              uCanBusOffRecoverCnt = 0u;
 3131  3                              t_canDtcErr.bCanBusOffErr = TRUE;                       
 3132  3                      }
 3133  2              }
 3134  1      
 3135  1              return t_canDtcErr.bCanBusOffErr;
 3136  1      
 3137  1        // USER CODE END
 3138  1      
 3139  1      } //  End of function CanDiag_DTC_BusOff
 3140         
 3141         //****************************************************************************
 3142         // @Function      void CanDiag_ComVoltageAbnormalStatus()
 3143         //
 3144         //----------------------------------------------------------------------------
 3145         // @Description   This function check can communication status.
 3146         //
 3147         //----------------------------------------------------------------------------
 3148         // @Returnvalue   None
 3149         //
 3150         //----------------------------------------------------------------------------
 3151         // @Parameters    None 
 3152         //
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 52  

 3153         //----------------------------------------------------------------------------
 3154         // @Date          2020-03-04
 3155         //
 3156         //****************************************************************************
 3157         
 3158         // USER CODE BEGIN (If_TxConfirmation,1)
 3159         
 3160         CAN_DIAG_STAT INT8U uCanVoltageAbnormalTimeoutCnt = 0u;
 3161         CAN_DIAG_STAT INT8U uCanVoltageAbnormalRecoverCnt = 0u;
 3162         
 3163         // USER CODE END
 3164         
 3165         BOOLEAN CanDiag_ComVoltageAbnormalStatus(void)
 3166         {
 3167  1      
 3168  1        // USER CODE BEGIN (If_TxConfirmation,2)
 3169  1        
 3170  1              if (FALSE == t_canDtcErr.bCanVoltageErr)
 3171  1              {
 3172  2                      uCanVoltageAbnormalRecoverCnt = 0u;
 3173  2      
 3174  2                      if (uCanVoltageValue > 0u)
 3175  2                      {
 3176  3                              if ((uCanVoltageValue < CAN_VOLT_FALLING_LOW_THREHOLD) || (uCanVoltageValue > CAN_VOLT_RISING_HIGH_THRE
             -HOLD))
 3177  3                              {
 3178  4                                      uCanVoltageAbnormalTimeoutCnt++;
 3179  4                                      if (uCanVoltageAbnormalTimeoutCnt >= DIAG_ERR_TIMEOUT_CYCLE)
 3180  4                                      {
 3181  5                                              uCanVoltageAbnormalTimeoutCnt = DIAG_ERR_TIMEOUT_CYCLE;
 3182  5                                              t_canDtcErr.bCanVoltageErr = TRUE;
 3183  5      
 3184  5                                              Can_DisableControllerInterrupts(CAN_CONTROLLER0);
 3185  5                                              Can_DisableControllerInterrupts(CAN_CONTROLLER1);
 3186  5      
 3187  5                                              Can_SetControllerMode(CAN_CONTROLLER0, CAN_T_STOP);
 3188  5                                              Can_SetControllerMode(CAN_CONTROLLER1, CAN_T_STOP);
 3189  5                                      }
 3190  4                              }
 3191  3                              else
 3192  3                              {
 3193  4                                      uCanVoltageAbnormalTimeoutCnt = 0u;
 3194  4                                      uCanVoltageAbnormalRecoverCnt = 0u;     
 3195  4                                      t_canDtcErr.bCanVoltageErr = FALSE;             
 3196  4                              }               
 3197  3                      }
 3198  2              }
 3199  1              else
 3200  1              {
 3201  2                      uCanVoltageAbnormalTimeoutCnt = 0u;
 3202  2      
 3203  2                      if (uCanVoltageValue > 0u)
 3204  2                      {
 3205  3                              if ((uCanVoltageValue > CAN_VOLT_FALLING_HIGH_THREHOLD) && (uCanVoltageValue < CAN_VOLT_RISING_LOW_THRE
             -HOLD))
 3206  3                              {
 3207  4                                      uCanVoltageAbnormalRecoverCnt++;
 3208  4                                      if (uCanVoltageAbnormalRecoverCnt >= DIAG_ERR_RECOVER_CYCLE)
 3209  4                                      {
 3210  5                                              uCanVoltageAbnormalRecoverCnt = DIAG_ERR_RECOVER_CYCLE;
 3211  5                                              t_canDtcErr.bCanVoltageErr = FALSE;
 3212  5                              
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 53  

 3213  5                                              Can_SetControllerMode(CAN_CONTROLLER0, CAN_T_START);
 3214  5                                              Can_SetControllerMode(CAN_CONTROLLER1, CAN_T_START);                                    
 3215  5                              
 3216  5                                              Can_EnableControllerInterrupts(CAN_CONTROLLER0);
 3217  5                                              Can_EnableControllerInterrupts(CAN_CONTROLLER1);                        
 3218  5                                      }
 3219  4                              }
 3220  3                              else
 3221  3                              {
 3222  4                                      uCanVoltageAbnormalTimeoutCnt = 0u;
 3223  4                                      uCanVoltageAbnormalRecoverCnt = 0u; 
 3224  4                                      t_canDtcErr.bCanVoltageErr = TRUE;                              
 3225  4                              }
 3226  3                      }
 3227  2              }
 3228  1      
 3229  1        return t_canDtcErr.bCanVoltageErr;
 3230  1      
 3231  1        // USER CODE END
 3232  1      
 3233  1      } //  End of function CanDiag_ComVoltageAbnormalStatus
 3234         
 3235         //****************************************************************************
 3236         // @Function      void CanDiag_ComCircuitAbnormalStatus()
 3237         //
 3238         //----------------------------------------------------------------------------
 3239         // @Description   This function check can communication status.
 3240         //
 3241         //----------------------------------------------------------------------------
 3242         // @Returnvalue   None
 3243         //
 3244         //----------------------------------------------------------------------------
 3245         // @Parameters    None 
 3246         //
 3247         //----------------------------------------------------------------------------
 3248         // @Date          2020-03-04
 3249         //
 3250         //****************************************************************************
 3251         
 3252         // USER CODE BEGIN (If_TxConfirmation,1)
 3253         
 3254         CAN_DIAG_STAT BOOLEAN bCan0GetErrorIncrement = 0u;
 3255         CAN_DIAG_STAT BOOLEAN bCan0GetErrorTransferDirection = 0u;
 3256         
 3257         CAN_DIAG_STAT INT8U uCanCircuitAbnormalTimeoutCnt = 0u;
 3258         CAN_DIAG_STAT INT8U uCanCircuitAbnormalRecoverCnt = 0u;
 3259         
 3260         // USER CODE END
 3261         
 3262         BOOLEAN  CanDiag_ComCircuitAbnormalStatus(void)
 3263         {
 3264  1      
 3265  1        // USER CODE BEGIN (If_TxConfirmation,2)
 3266  1      
 3267  1              bCan0GetErrorIncrement = CAN_ubGetErrorIncrement(CAN_CONTROLLER0);
 3268  1              bCan0GetErrorTransferDirection = CAN_ubGetErrorTransferDirection(CAN_CONTROLLER0);
 3269  1      
 3270  1              if (FALSE == t_canDtcErr.bCanCircuitErr)
 3271  1              {
 3272  2                      uCanCircuitAbnormalRecoverCnt = 0u;
 3273  2      
 3274  2                      if ((FALSE == bCan0GetErrorTransferDirection) && (FALSE == bCan0GetErrorIncrement))
C166 COMPILER V7.57.0, CAN_DIAG                                                            01/20/2021 09:50:54 PAGE 54  

 3275  2                      {
 3276  3                              uCanCircuitAbnormalTimeoutCnt++;
 3277  3                              if (uCanCircuitAbnormalTimeoutCnt >= DIAG_ERR_TIMEOUT_CYCLE)
 3278  3                              {
 3279  4                                      uCanCircuitAbnormalTimeoutCnt = DIAG_ERR_TIMEOUT_CYCLE;
 3280  4                                      t_canDtcErr.bCanCircuitErr = TRUE;
 3281  4      
 3282  4                                      Can_DisableControllerInterrupts(CAN_CONTROLLER0);
 3283  4                                      Can_SetControllerMode(CAN_CONTROLLER0, CAN_T_STOP);
 3284  4                              }
 3285  3                      }
 3286  2                      else
 3287  2                      {
 3288  3                              uCanCircuitAbnormalTimeoutCnt = 0u;
 3289  3                              uCanCircuitAbnormalRecoverCnt = 0u;     
 3290  3                              t_canDtcErr.bCanCircuitErr = FALSE;             
 3291  3                      }
 3292  2              }
 3293  1              else
 3294  1              {
 3295  2                      uCanCircuitAbnormalTimeoutCnt = 0u;
 3296  2      
 3297  2                      uCanCircuitAbnormalRecoverCnt++;
 3298  2                      if (uCanCircuitAbnormalRecoverCnt >= DIAG_ERR_RECOVER_CYCLE)
 3299  2                      {
 3300  3                              uCanCircuitAbnormalRecoverCnt = DIAG_ERR_RECOVER_CYCLE;
 3301  3                              t_canDtcErr.bCanCircuitErr = FALSE;
 3302  3      
 3303  3                              Can_SetControllerMode(CAN_CONTROLLER0, CAN_T_START);                                    
 3304  3                              Can_EnableControllerInterrupts(CAN_CONTROLLER0);                        
 3305  3                      }
 3306  2              }
 3307  1              
 3308  1        return t_canDtcErr.bCanCircuitErr;    
 3309  1      
 3310  1        // USER CODE END
 3311  1      
 3312  1      } //  End of function CanDiag_ComCircuitAbnormalStatus
 3313         
 3314         


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        1726     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          23     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =          96     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
