C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 1   


C166 COMPILER V7.57.0, COMPILATION OF MODULE CAN_DIAG
OBJECT MODULE PLACED IN .\Obj\can_diag.obj
COMPILER INVOKED BY: C:\Keil_v5\C166\BIN\C166.EXE src\app\can\can_diag.c MODV2 LARGE BROWSE INCDIR(.\src;.\src\bsw;.\src
                    -\driver;.\src\interaction;.\src\app\adc;.\src\app\alogrithm;.\src\app\can;.\src\app\ccp;.\src\app\diagnostic;.\src\app\m
                    -ode control;.\src\app\task;.\src\app\Fun;.\src\app\rtos;.\src\bsw\can;.\src\bsw\desc;.\src\bsw\nm;.\src\app\time measure
                    -;.\src\app\rte) MODV2 DEBUG PRINT(.\Lst\can_diag.lst) OBJECT(.\Obj\can_diag.obj) 

 stmt lvl     source

    1         //****************************************************************************
    2         // @Module        Project Settings
    3         // @Filename      can_diag.c
    4         // @Project       P300.dav
    5         //----------------------------------------------------------------------------
    6         // @Controller    Infineon XC2365B-40F80
    7         //
    8         // @Compiler      Keil
    9         //
   10         // @Codegenerator 2.0
   11         //
   12         // @Description   This file contains the project initialization function.
   13         //
   14         //----------------------------------------------------------------------------
   15         // @Date          2020-03-04 15:47:42
   16         //
   17         //****************************************************************************
   18         
   19         // USER CODE BEGIN (MAIN_General,1)
   20         
   21         // USER CODE END
   22         
   23         
   24         
   25         //****************************************************************************
   26         // @Project Includes
   27         //****************************************************************************
   28         
   29         // USER CODE BEGIN (MAIN_General,2)
   30         
   31         #include <string.h>
   32         
   33         #include "can.h"
   34         #include "can_com.h"
   35         #include "can_diag.h"
   36         #include "desc_mgr.h"
   37         #include "Nm.h"
   38         
   39         #define CAN_DIAG_GLOBALS
   40         
   41         // USER CODE END
   42         
   43         
   44         //****************************************************************************
   45         // @Macros
   46         //****************************************************************************
   47         
   48         // USER CODE BEGIN (MAIN_General,3)
   49         
   50         // USER CODE END
   51         
   52         
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 2   

   53         //****************************************************************************
   54         // @Defines
   55         //****************************************************************************
   56         
   57         // USER CODE BEGIN (MAIN_General,4)
   58         
   59         // USER CODE END
   60         
   61         
   62         //****************************************************************************
   63         // @Typedefs
   64         //****************************************************************************
   65         
   66         // USER CODE BEGIN (MAIN_General,5)
   67         
   68         // USER CODE END
   69         
   70         
   71         //****************************************************************************
   72         // @Imported Global Variables
   73         //****************************************************************************
   74         
   75         // USER CODE BEGIN (MAIN_General,6)
   76         
   77         // USER CODE END
   78         
   79         
   80         //****************************************************************************
   81         // @Global Variables
   82         //****************************************************************************
   83         
   84         // USER CODE BEGIN (MAIN_General,7)
   85         
   86         INT16U  uCanVoltageValue;
   87         
   88         CAN_DIAG_STAT CAN_DTC_ERR t_canDtcErr = {0u};
   89         
   90         // USER CODE END
   91         
   92         
   93         //****************************************************************************
   94         // @External Prototypes
   95         //****************************************************************************
   96         
   97         // USER CODE BEGIN (MAIN_General,8)
   98         
   99         // USER CODE END
  100         
  101         
  102         //****************************************************************************
  103         // @Prototypes Of Local Functions
  104         //****************************************************************************
  105         
  106         // USER CODE BEGIN (MAIN_General,9)
  107         
  108         // USER CODE END
  109         
  110         
  111         //****************************************************************************
  112         // @Function      void CanDiag_DTC_VCU_0x118MsgRollingCount()
  113         //
  114         //----------------------------------------------------------------------------
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 3   

  115         // @Description   This function check 0x118 message rolling counter.
  116         //
  117         //----------------------------------------------------------------------------
  118         // @Returnvalue   None
  119         //
  120         //----------------------------------------------------------------------------
  121         // @Parameters    None 
  122         //
  123         //----------------------------------------------------------------------------
  124         // @Date          2020-03-04
  125         //
  126         //****************************************************************************
  127         
  128         // USER CODE BEGIN (If_TxConfirmation,1)
  129         
  130         CAN_DIAG_STAT INT8U u0x118MsgRollingTimeoutCnt = 0u;
  131         CAN_DIAG_STAT INT8U u0x118MsgRollingRecoverCnt = 0u;
  132         
  133         // USER CODE END
  134         
  135         BOOLEAN CanDiag_DTC_VCU_0x118MsgRollingCount(CanReceiveHandle* rcvObject)
  136         {
  137  1      
  138  1        // USER CODE BEGIN (If_TxConfirmation,2)
  139  1        
  140  1              CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
  141  1          CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
  142  1              CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
  143  1      
  144  1              INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
  145  1              
  146  1              if (FALSE == bFristMsgFlag)
  147  1              {
  148  2                      bFristMsgFlag = TRUE;
  149  2                      uRollingContinuity = 0u;
  150  2                      uPreRollingValue = uCurRollingValue;
  151  2      
  152  2                      return FALSE;
  153  2              }
  154  1              else
  155  1              {
  156  2                      uPreRollingValue++;
  157  2                      if (15u == uPreRollingValue)
  158  2                      {
  159  3                              uPreRollingValue = 0u;
  160  3                      }
  161  2      
  162  2                      if (uPreRollingValue == uCurRollingValue)
  163  2                      {
  164  3                              uRollingContinuity++;
  165  3                      }
  166  2                      else
  167  2                      {
  168  3                              bFristMsgFlag = FALSE;
  169  3                              uRollingContinuity = 0u;
  170  3                      }
  171  2      
  172  2                      if (FALSE == t_canDtcErr.b0x118MsgRollingCntErr)
  173  2                      {
  174  3                              if (uRollingContinuity < 10u)
  175  3                              {
  176  4                                      u0x118MsgRollingRecoverCnt = 0u;
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 4   

  177  4      
  178  4                                      u0x118MsgRollingTimeoutCnt++;
  179  4                                      if (u0x118MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
  180  4                                      {
  181  5                                              u0x118MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
  182  5                                              t_canDtcErr.b0x118MsgRollingCntErr = TRUE;
  183  5      
  184  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
  185  5                                              {
  186  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x118_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
  187  6                                              }
  188  5                                      }
  189  4                              }
  190  3                              else
  191  3                              {
  192  4                                      u0x118MsgRollingTimeoutCnt = 0u;
  193  4                                      u0x118MsgRollingRecoverCnt = 0u;
  194  4                                      t_canDtcErr.b0x118MsgRollingCntErr = FALSE;
  195  4                              }
  196  3                      }
  197  2                      else
  198  2                      {
  199  3                              if (uRollingContinuity >= 10u)
  200  3                              {
  201  4                                      u0x118MsgRollingTimeoutCnt = 0u;
  202  4      
  203  4                                      u0x118MsgRollingRecoverCnt++;
  204  4                                      if (u0x118MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
  205  4                                      {
  206  5                                              u0x118MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
  207  5                                              t_canDtcErr.b0x118MsgRollingCntErr = FALSE;
  208  5      
  209  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
  210  5                                              {
  211  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x118_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
  212  6                                              }
  213  5                                      }
  214  4                              }
  215  3                              else
  216  3                              {
  217  4                                      u0x118MsgRollingTimeoutCnt = 0u;
  218  4                                      u0x118MsgRollingRecoverCnt = 0u;
  219  4                                      t_canDtcErr.b0x118MsgRollingCntErr = TRUE;                              
  220  4                              }
  221  3                      }
  222  2      
  223  2                      if (uRollingContinuity >= 10u)
  224  2                      {
  225  3                              uRollingContinuity = 10u;
  226  3                              return TRUE;
  227  3                      }
  228  2                      else
  229  2                      {
  230  3                              return FALSE;   
  231  3                      }
  232  2              }
  233  1      
  234  1        // USER CODE END
  235  1      
  236  1      } //  End of function CanDiag_DTC_VCU_0x118MsgRollingCount
  237         
  238         //****************************************************************************
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 5   

  239         // @Function      void CanDiag_DTC_VCU_0x119MsgRollingCount()
  240         //
  241         //----------------------------------------------------------------------------
  242         // @Description   This function check 0x119 message rolling counter.
  243         //
  244         //----------------------------------------------------------------------------
  245         // @Returnvalue   None
  246         //
  247         //----------------------------------------------------------------------------
  248         // @Parameters    None 
  249         //
  250         //----------------------------------------------------------------------------
  251         // @Date          2020-03-04
  252         //
  253         //****************************************************************************
  254         
  255         // USER CODE BEGIN (If_TxConfirmation,1)
  256         
  257         CAN_DIAG_STAT INT8U u0x119MsgRollingTimeoutCnt = 0u;
  258         CAN_DIAG_STAT INT8U u0x119MsgRollingRecoverCnt = 0u;
  259         
  260         // USER CODE END
  261         
  262         BOOLEAN CanDiag_DTC_VCU_0x119MsgRollingCount(CanReceiveHandle* rcvObject)
  263         {
  264  1      
  265  1        // USER CODE BEGIN (If_TxConfirmation,2)
  266  1        
  267  1              CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
  268  1          CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
  269  1              CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
  270  1      
  271  1              INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
  272  1              
  273  1              if (FALSE == bFristMsgFlag)
  274  1              {
  275  2                      bFristMsgFlag = TRUE;
  276  2                      uRollingContinuity = 0u;
  277  2                      uPreRollingValue = uCurRollingValue;
  278  2      
  279  2                      return FALSE;
  280  2              }
  281  1              else
  282  1              {
  283  2                      uPreRollingValue++;
  284  2                      if (15u == uPreRollingValue)
  285  2                      {
  286  3                              uPreRollingValue = 0u;
  287  3                      }
  288  2      
  289  2                      if (uPreRollingValue == uCurRollingValue)
  290  2                      {
  291  3                              uRollingContinuity++;
  292  3                      }
  293  2                      else
  294  2                      {
  295  3                              bFristMsgFlag = FALSE;
  296  3                              uRollingContinuity = 0u;
  297  3                      }
  298  2      
  299  2                      if (FALSE == t_canDtcErr.b0x119MsgRollingCntErr)
  300  2                      {
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 6   

  301  3                              if (uRollingContinuity < 10u)
  302  3                              {
  303  4                                      u0x119MsgRollingRecoverCnt = 0u;
  304  4      
  305  4                                      u0x119MsgRollingTimeoutCnt++;
  306  4                                      if (u0x119MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
  307  4                                      {
  308  5                                              u0x119MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
  309  5                                              t_canDtcErr.b0x119MsgRollingCntErr = TRUE;
  310  5      
  311  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
  312  5                                              {
  313  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x119_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
  314  6                                              }
  315  5                                      }
  316  4                              }
  317  3                              else
  318  3                              {
  319  4                                      u0x119MsgRollingTimeoutCnt = 0u;
  320  4                                      u0x119MsgRollingRecoverCnt = 0u;
  321  4                                      t_canDtcErr.b0x119MsgRollingCntErr = FALSE;
  322  4                              }
  323  3                      }
  324  2                      else
  325  2                      {
  326  3                              if (uRollingContinuity >= 10u)
  327  3                              {
  328  4                                      u0x119MsgRollingTimeoutCnt = 0u;
  329  4      
  330  4                                      u0x119MsgRollingRecoverCnt++;
  331  4                                      if (u0x119MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
  332  4                                      {
  333  5                                              u0x119MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
  334  5                                              t_canDtcErr.b0x119MsgRollingCntErr = FALSE;
  335  5      
  336  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
  337  5                                              {
  338  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x119_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
  339  6                                              }
  340  5                                      }
  341  4                              }
  342  3                              else
  343  3                              {
  344  4                                      u0x119MsgRollingTimeoutCnt = 0u;
  345  4                                      u0x119MsgRollingRecoverCnt = 0u;
  346  4                                      t_canDtcErr.b0x119MsgRollingCntErr = TRUE;                              
  347  4                              }
  348  3                      }
  349  2      
  350  2                      if (uRollingContinuity >= 10u)
  351  2                      {
  352  3                              uRollingContinuity = 10u;
  353  3                              return TRUE;
  354  3                      }
  355  2                      else
  356  2                      {
  357  3                              return FALSE;   
  358  3                      }
  359  2              }
  360  1      
  361  1        // USER CODE END
  362  1      
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 7   

  363  1      } //  End of function CanDiag_DTC_VCU_0x119MsgRollingCount
  364         
  365         //****************************************************************************
  366         // @Function      void CanDiag_DTC_VCU_0x126MsgRollingCount()
  367         //
  368         //----------------------------------------------------------------------------
  369         // @Description   This function check 0x126 message rolling counter.
  370         //
  371         //----------------------------------------------------------------------------
  372         // @Returnvalue   None
  373         //
  374         //----------------------------------------------------------------------------
  375         // @Parameters    None 
  376         //
  377         //----------------------------------------------------------------------------
  378         // @Date          2020-03-04
  379         //
  380         //****************************************************************************
  381         
  382         // USER CODE BEGIN (If_TxConfirmation,1)
  383         
  384         CAN_DIAG_STAT INT8U u0x126MsgRollingTimeoutCnt = 0u;
  385         CAN_DIAG_STAT INT8U u0x126MsgRollingRecoverCnt = 0u;
  386         
  387         // USER CODE END
  388         
  389         BOOLEAN CanDiag_DTC_VCU_0x126MsgRollingCount(CanReceiveHandle* rcvObject)
  390         {
  391  1      
  392  1        // USER CODE BEGIN (If_TxConfirmation,2)
  393  1        
  394  1              CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
  395  1          CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
  396  1              CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
  397  1      
  398  1              INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
  399  1              
  400  1              if (FALSE == bFristMsgFlag)
  401  1              {
  402  2                      bFristMsgFlag = TRUE;
  403  2                      uRollingContinuity = 0u;
  404  2                      uPreRollingValue = uCurRollingValue;
  405  2      
  406  2                      return FALSE;
  407  2              }
  408  1              else
  409  1              {
  410  2                      uPreRollingValue++;
  411  2                      if (15u == uPreRollingValue)
  412  2                      {
  413  3                              uPreRollingValue = 0u;
  414  3                      }
  415  2      
  416  2                      if (uPreRollingValue == uCurRollingValue)
  417  2                      {
  418  3                              uRollingContinuity++;
  419  3                      }
  420  2                      else
  421  2                      {
  422  3                              bFristMsgFlag = FALSE;
  423  3                              uRollingContinuity = 0u;
  424  3                      }
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 8   

  425  2      
  426  2                      if (FALSE == t_canDtcErr.b0x126MsgRollingCntErr)
  427  2                      {
  428  3                              if (uRollingContinuity < 10u)
  429  3                              {
  430  4                                      u0x126MsgRollingRecoverCnt = 0u;
  431  4      
  432  4                                      u0x126MsgRollingTimeoutCnt++;
  433  4                                      if (u0x126MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
  434  4                                      {
  435  5                                              u0x126MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
  436  5                                              t_canDtcErr.b0x126MsgRollingCntErr = TRUE;
  437  5      
  438  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
  439  5                                              {
  440  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x126_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
  441  6                                              }
  442  5                                      }
  443  4                              }
  444  3                              else
  445  3                              {
  446  4                                      u0x126MsgRollingTimeoutCnt = 0u;
  447  4                                      u0x126MsgRollingRecoverCnt = 0u;
  448  4                                      t_canDtcErr.b0x126MsgRollingCntErr = FALSE;
  449  4                              }
  450  3                      }
  451  2                      else
  452  2                      {
  453  3                              if (uRollingContinuity >= 10u)
  454  3                              {
  455  4                                      u0x126MsgRollingTimeoutCnt = 0u;
  456  4      
  457  4                                      u0x126MsgRollingRecoverCnt++;
  458  4                                      if (u0x126MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
  459  4                                      {
  460  5                                              u0x126MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
  461  5                                              t_canDtcErr.b0x126MsgRollingCntErr = FALSE;
  462  5      
  463  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
  464  5                                              {
  465  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x126_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
  466  6                                              }
  467  5                                      }
  468  4                              }
  469  3                              else
  470  3                              {
  471  4                                      u0x126MsgRollingTimeoutCnt = 0u;
  472  4                                      u0x126MsgRollingRecoverCnt = 0u;
  473  4                                      t_canDtcErr.b0x126MsgRollingCntErr = TRUE;                              
  474  4                              }
  475  3                      }
  476  2      
  477  2                      if (uRollingContinuity >= 10u)
  478  2                      {
  479  3                              uRollingContinuity = 10u;
  480  3                              return TRUE;
  481  3                      }
  482  2                      else
  483  2                      {
  484  3                              return FALSE;   
  485  3                      }
  486  2              }
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 9   

  487  1      
  488  1        // USER CODE END
  489  1      
  490  1      } //  End of function CanDiag_DTC_VCU_0x126MsgRollingCount
  491         
  492         //****************************************************************************
  493         // @Function      void CanDiag_DTC_MCU_0x130MsgRollingCount()
  494         //
  495         //----------------------------------------------------------------------------
  496         // @Description   This function check 0x130 message rolling counter.
  497         //
  498         //----------------------------------------------------------------------------
  499         // @Returnvalue   None
  500         //
  501         //----------------------------------------------------------------------------
  502         // @Parameters    None 
  503         //
  504         //----------------------------------------------------------------------------
  505         // @Date          2020-03-04
  506         //
  507         //****************************************************************************
  508         
  509         // USER CODE BEGIN (If_TxConfirmation,1)
  510         
  511         CAN_DIAG_STAT INT8U u0x130MsgRollingTimeoutCnt = 0u;
  512         CAN_DIAG_STAT INT8U u0x130MsgRollingRecoverCnt = 0u;
  513         
  514         // USER CODE END
  515         
  516         BOOLEAN CanDiag_DTC_MCU_0x130MsgRollingCount(CanReceiveHandle* rcvObject)
  517         {
  518  1      
  519  1        // USER CODE BEGIN (If_TxConfirmation,2)
  520  1        
  521  1              CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
  522  1          CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
  523  1              CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
  524  1      
  525  1              INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
  526  1              
  527  1              if (FALSE == bFristMsgFlag)
  528  1              {
  529  2                      bFristMsgFlag = TRUE;
  530  2                      uRollingContinuity = 0u;
  531  2                      uPreRollingValue = uCurRollingValue;
  532  2      
  533  2                      return FALSE;
  534  2              }
  535  1              else
  536  1              {
  537  2                      uPreRollingValue++;
  538  2                      if (15u == uPreRollingValue)
  539  2                      {
  540  3                              uPreRollingValue = 0u;
  541  3                      }
  542  2      
  543  2                      if (uPreRollingValue == uCurRollingValue)
  544  2                      {
  545  3                              uRollingContinuity++;
  546  3                      }
  547  2                      else
  548  2                      {
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 10  

  549  3                              bFristMsgFlag = FALSE;
  550  3                              uRollingContinuity = 0u;
  551  3                      }
  552  2      
  553  2                      if (FALSE == t_canDtcErr.b0x130MsgRollingCntErr)
  554  2                      {
  555  3                              if (uRollingContinuity < 10u)
  556  3                              {
  557  4                                      u0x130MsgRollingRecoverCnt = 0u;
  558  4      
  559  4                                      u0x130MsgRollingTimeoutCnt++;
  560  4                                      if (u0x130MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
  561  4                                      {
  562  5                                              u0x130MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
  563  5                                              t_canDtcErr.b0x130MsgRollingCntErr = TRUE;
  564  5      
  565  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
  566  5                                              {
  567  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x130_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
  568  6                                              }
  569  5                                      }
  570  4                              }
  571  3                              else
  572  3                              {
  573  4                                      u0x130MsgRollingTimeoutCnt = 0u;
  574  4                                      u0x130MsgRollingRecoverCnt = 0u;
  575  4                                      t_canDtcErr.b0x130MsgRollingCntErr = FALSE;
  576  4                              }
  577  3                      }
  578  2                      else
  579  2                      {
  580  3                              if (uRollingContinuity >= 10u)
  581  3                              {
  582  4                                      u0x130MsgRollingTimeoutCnt = 0u;
  583  4      
  584  4                                      u0x130MsgRollingRecoverCnt++;
  585  4                                      if (u0x130MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
  586  4                                      {
  587  5                                              u0x130MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
  588  5                                              t_canDtcErr.b0x130MsgRollingCntErr = FALSE;
  589  5      
  590  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
  591  5                                              {
  592  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x130_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
  593  6                                              }
  594  5                                      }
  595  4                              }
  596  3                              else
  597  3                              {
  598  4                                      u0x130MsgRollingTimeoutCnt = 0u;
  599  4                                      u0x130MsgRollingRecoverCnt = 0u;
  600  4                                      t_canDtcErr.b0x130MsgRollingCntErr = TRUE;                              
  601  4                              }
  602  3                      }
  603  2      
  604  2                      if (uRollingContinuity >= 10u)
  605  2                      {
  606  3                              uRollingContinuity = 10u;
  607  3                              return TRUE;
  608  3                      }
  609  2                      else
  610  2                      {
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 11  

  611  3                              return FALSE;   
  612  3                      }
  613  2              }
  614  1      
  615  1        // USER CODE END
  616  1      
  617  1      } //  End of function CanDiag_DTC_MCU_0x130MsgRollingCount
  618         
  619         //****************************************************************************
  620         // @Function      void CanDiag_DTC_MCU_0x132MsgRollingCount()
  621         //
  622         //----------------------------------------------------------------------------
  623         // @Description   This function check 0x132 message rolling counter.
  624         //
  625         //----------------------------------------------------------------------------
  626         // @Returnvalue   None
  627         //
  628         //----------------------------------------------------------------------------
  629         // @Parameters    None 
  630         //
  631         //----------------------------------------------------------------------------
  632         // @Date          2020-03-04
  633         //
  634         //****************************************************************************
  635         
  636         // USER CODE BEGIN (If_TxConfirmation,1)
  637         
  638         CAN_DIAG_STAT INT8U u0x132MsgRollingTimeoutCnt = 0u;
  639         CAN_DIAG_STAT INT8U u0x132MsgRollingRecoverCnt = 0u;
  640         
  641         // USER CODE END
  642         
  643         BOOLEAN CanDiag_DTC_MCU_0x132MsgRollingCount(CanReceiveHandle* rcvObject)
  644         {
  645  1      
  646  1        // USER CODE BEGIN (If_TxConfirmation,2)
  647  1        
  648  1              CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
  649  1          CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
  650  1              CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
  651  1      
  652  1              INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
  653  1              
  654  1              if (FALSE == bFristMsgFlag)
  655  1              {
  656  2                      bFristMsgFlag = TRUE;
  657  2                      uRollingContinuity = 0u;
  658  2                      uPreRollingValue = uCurRollingValue;
  659  2      
  660  2                      return FALSE;
  661  2              }
  662  1              else
  663  1              {
  664  2                      uPreRollingValue++;
  665  2                      if (15u == uPreRollingValue)
  666  2                      {
  667  3                              uPreRollingValue = 0u;
  668  3                      }
  669  2      
  670  2                      if (uPreRollingValue == uCurRollingValue)
  671  2                      {
  672  3                              uRollingContinuity++;
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 12  

  673  3                      }
  674  2                      else
  675  2                      {
  676  3                              bFristMsgFlag = FALSE;
  677  3                              uRollingContinuity = 0u;
  678  3                      }
  679  2      
  680  2                      if (FALSE == t_canDtcErr.b0x132MsgRollingCntErr)
  681  2                      {
  682  3                              if (uRollingContinuity < 10u)
  683  3                              {
  684  4                                      u0x132MsgRollingRecoverCnt = 0u;
  685  4      
  686  4                                      u0x132MsgRollingTimeoutCnt++;
  687  4                                      if (u0x132MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
  688  4                                      {
  689  5                                              u0x132MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
  690  5                                              t_canDtcErr.b0x132MsgRollingCntErr = TRUE;
  691  5      
  692  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
  693  5                                              {
  694  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x132_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
  695  6                                              }
  696  5                                      }
  697  4                              }
  698  3                              else
  699  3                              {
  700  4                                      u0x132MsgRollingTimeoutCnt = 0u;
  701  4                                      u0x132MsgRollingRecoverCnt = 0u;
  702  4                                      t_canDtcErr.b0x132MsgRollingCntErr = FALSE;
  703  4                              }
  704  3                      }
  705  2                      else
  706  2                      {
  707  3                              if (uRollingContinuity >= 10u)
  708  3                              {
  709  4                                      u0x132MsgRollingTimeoutCnt = 0u;
  710  4      
  711  4                                      u0x132MsgRollingRecoverCnt++;
  712  4                                      if (u0x132MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
  713  4                                      {
  714  5                                              u0x132MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
  715  5                                              t_canDtcErr.b0x132MsgRollingCntErr = FALSE;
  716  5      
  717  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
  718  5                                              {
  719  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x132_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
  720  6                                              }
  721  5                                      }
  722  4                              }
  723  3                              else
  724  3                              {
  725  4                                      u0x132MsgRollingTimeoutCnt = 0u;
  726  4                                      u0x132MsgRollingRecoverCnt = 0u;
  727  4                                      t_canDtcErr.b0x132MsgRollingCntErr = TRUE;                              
  728  4                              }
  729  3                      }
  730  2      
  731  2                      if (uRollingContinuity >= 10u)
  732  2                      {
  733  3                              uRollingContinuity = 10u;
  734  3                              return TRUE;
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 13  

  735  3                      }
  736  2                      else
  737  2                      {
  738  3                              return FALSE;   
  739  3                      }
  740  2              }
  741  1      
  742  1        // USER CODE END
  743  1      
  744  1      } //  End of function CanDiag_DTC_MCU_0x132MsgRollingCount
  745         
  746         //****************************************************************************
  747         // @Function      void CanDiag_DTC_BMS_0x140MsgRollingCount()
  748         //
  749         //----------------------------------------------------------------------------
  750         // @Description   This function check 0x140 message rolling counter.
  751         //
  752         //----------------------------------------------------------------------------
  753         // @Returnvalue   None
  754         //
  755         //----------------------------------------------------------------------------
  756         // @Parameters    None 
  757         //
  758         //----------------------------------------------------------------------------
  759         // @Date          2020-03-04
  760         //
  761         //****************************************************************************
  762         
  763         // USER CODE BEGIN (If_TxConfirmation,1)
  764         
  765         CAN_DIAG_STAT INT8U u0x140MsgRollingTimeoutCnt = 0u;
  766         CAN_DIAG_STAT INT8U u0x140MsgRollingRecoverCnt = 0u;
  767         
  768         // USER CODE END
  769         
  770         BOOLEAN CanDiag_DTC_BMS_0x140MsgRollingCount(CanReceiveHandle* rcvObject)
  771         {
  772  1      
  773  1        // USER CODE BEGIN (If_TxConfirmation,2)
  774  1        
  775  1              CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
  776  1          CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
  777  1              CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
  778  1      
  779  1              INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
  780  1              
  781  1              if (FALSE == bFristMsgFlag)
  782  1              {
  783  2                      bFristMsgFlag = TRUE;
  784  2                      uRollingContinuity = 0u;
  785  2                      uPreRollingValue = uCurRollingValue;
  786  2      
  787  2                      return FALSE;
  788  2              }
  789  1              else
  790  1              {
  791  2                      uPreRollingValue++;
  792  2                      if (15u == uPreRollingValue)
  793  2                      {
  794  3                              uPreRollingValue = 0u;
  795  3                      }
  796  2      
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 14  

  797  2                      if (uPreRollingValue == uCurRollingValue)
  798  2                      {
  799  3                              uRollingContinuity++;
  800  3                      }
  801  2                      else
  802  2                      {
  803  3                              bFristMsgFlag = FALSE;
  804  3                              uRollingContinuity = 0u;
  805  3                      }
  806  2      
  807  2                      if (FALSE == t_canDtcErr.b0x140MsgRollingCntErr)
  808  2                      {
  809  3                              if (uRollingContinuity < 10u)
  810  3                              {
  811  4                                      u0x140MsgRollingRecoverCnt = 0u;
  812  4      
  813  4                                      u0x140MsgRollingTimeoutCnt++;
  814  4                                      if (u0x140MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
  815  4                                      {
  816  5                                              u0x140MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
  817  5                                              t_canDtcErr.b0x140MsgRollingCntErr = TRUE;
  818  5      
  819  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
  820  5                                              {
  821  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x140_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
  822  6                                              }
  823  5                                      }
  824  4                              }
  825  3                              else
  826  3                              {
  827  4                                      u0x140MsgRollingTimeoutCnt = 0u;
  828  4                                      u0x140MsgRollingRecoverCnt = 0u;
  829  4                                      t_canDtcErr.b0x140MsgRollingCntErr = FALSE;
  830  4                              }
  831  3                      }
  832  2                      else
  833  2                      {
  834  3                              if (uRollingContinuity >= 10u)
  835  3                              {
  836  4                                      u0x140MsgRollingTimeoutCnt = 0u;
  837  4      
  838  4                                      u0x140MsgRollingRecoverCnt++;
  839  4                                      if (u0x140MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
  840  4                                      {
  841  5                                              u0x140MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
  842  5                                              t_canDtcErr.b0x140MsgRollingCntErr = FALSE;
  843  5      
  844  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
  845  5                                              {
  846  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x140_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
  847  6                                              }
  848  5                                      }
  849  4                              }
  850  3                              else
  851  3                              {
  852  4                                      u0x140MsgRollingTimeoutCnt = 0u;
  853  4                                      u0x140MsgRollingRecoverCnt = 0u;
  854  4                                      t_canDtcErr.b0x140MsgRollingCntErr = TRUE;                              
  855  4                              }
  856  3                      }
  857  2      
  858  2                      if (uRollingContinuity >= 10u)
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 15  

  859  2                      {
  860  3                              uRollingContinuity = 10u;
  861  3                              return TRUE;
  862  3                      }
  863  2                      else
  864  2                      {
  865  3                              return FALSE;   
  866  3                      }
  867  2              }
  868  1      
  869  1        // USER CODE END
  870  1      
  871  1      } //  End of function CanDiag_DTC_BMS_0x140MsgRollingCount
  872         
  873         //****************************************************************************
  874         // @Function      void CanDiag_DTC_BMS_0x148MsgRollingCount()
  875         //
  876         //----------------------------------------------------------------------------
  877         // @Description   This function check 0x148 message rolling counter.
  878         //
  879         //----------------------------------------------------------------------------
  880         // @Returnvalue   None
  881         //
  882         //----------------------------------------------------------------------------
  883         // @Parameters    None 
  884         //
  885         //----------------------------------------------------------------------------
  886         // @Date          2020-03-04
  887         //
  888         //****************************************************************************
  889         
  890         // USER CODE BEGIN (If_TxConfirmation,1)
  891         
  892         CAN_DIAG_STAT INT8U u0x148MsgRollingTimeoutCnt = 0u;
  893         CAN_DIAG_STAT INT8U u0x148MsgRollingRecoverCnt = 0u;
  894         
  895         // USER CODE END
  896         
  897         BOOLEAN CanDiag_DTC_BMS_0x148MsgRollingCount(CanReceiveHandle* rcvObject)
  898         {
  899  1      
  900  1        // USER CODE BEGIN (If_TxConfirmation,2)
  901  1        
  902  1              CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
  903  1          CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
  904  1              CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
  905  1      
  906  1              INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
  907  1              
  908  1              if (FALSE == bFristMsgFlag)
  909  1              {
  910  2                      bFristMsgFlag = TRUE;
  911  2                      uRollingContinuity = 0u;
  912  2                      uPreRollingValue = uCurRollingValue;
  913  2      
  914  2                      return FALSE;
  915  2              }
  916  1              else
  917  1              {
  918  2                      uPreRollingValue++;
  919  2                      if (15u == uPreRollingValue)
  920  2                      {
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 16  

  921  3                              uPreRollingValue = 0u;
  922  3                      }
  923  2      
  924  2                      if (uPreRollingValue == uCurRollingValue)
  925  2                      {
  926  3                              uRollingContinuity++;
  927  3                      }
  928  2                      else
  929  2                      {
  930  3                              bFristMsgFlag = FALSE;
  931  3                              uRollingContinuity = 0u;
  932  3                      }
  933  2      
  934  2                      if (FALSE == t_canDtcErr.b0x148MsgRollingCntErr)
  935  2                      {
  936  3                              if (uRollingContinuity < 10u)
  937  3                              {
  938  4                                      u0x148MsgRollingRecoverCnt = 0u;
  939  4      
  940  4                                      u0x148MsgRollingTimeoutCnt++;
  941  4                                      if (u0x148MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
  942  4                                      {
  943  5                                              u0x148MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
  944  5                                              t_canDtcErr.b0x148MsgRollingCntErr = TRUE;
  945  5      
  946  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
  947  5                                              {
  948  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x148_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
  949  6                                              }
  950  5                                      }
  951  4                              }
  952  3                              else
  953  3                              {
  954  4                                      u0x148MsgRollingTimeoutCnt = 0u;
  955  4                                      u0x148MsgRollingRecoverCnt = 0u;
  956  4                                      t_canDtcErr.b0x148MsgRollingCntErr = FALSE;
  957  4                              }
  958  3                      }
  959  2                      else
  960  2                      {
  961  3                              if (uRollingContinuity >= 10u)
  962  3                              {
  963  4                                      u0x148MsgRollingTimeoutCnt = 0u;
  964  4      
  965  4                                      u0x148MsgRollingRecoverCnt++;
  966  4                                      if (u0x148MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
  967  4                                      {
  968  5                                              u0x148MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
  969  5                                              t_canDtcErr.b0x148MsgRollingCntErr = FALSE;
  970  5      
  971  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
  972  5                                              {
  973  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x148_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
  974  6                                              }
  975  5                                      }
  976  4                              }
  977  3                              else
  978  3                              {
  979  4                                      u0x148MsgRollingTimeoutCnt = 0u;
  980  4                                      u0x148MsgRollingRecoverCnt = 0u;
  981  4                                      t_canDtcErr.b0x148MsgRollingCntErr = TRUE;                              
  982  4                              }
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 17  

  983  3                      }
  984  2      
  985  2                      if (uRollingContinuity >= 10u)
  986  2                      {
  987  3                              uRollingContinuity = 10u;
  988  3                              return TRUE;
  989  3                      }
  990  2                      else
  991  2                      {
  992  3                              return FALSE;   
  993  3                      }
  994  2              }
  995  1      
  996  1        // USER CODE END
  997  1      
  998  1      } //  End of function CanDiag_DTC_BMS_0x148MsgRollingCount
  999         
 1000         //****************************************************************************
 1001         // @Function      void CanDiag_DTC_BMS_0x155MsgRollingCount()
 1002         //
 1003         //----------------------------------------------------------------------------
 1004         // @Description   This function check 0x155 message rolling counter.
 1005         //
 1006         //----------------------------------------------------------------------------
 1007         // @Returnvalue   None
 1008         //
 1009         //----------------------------------------------------------------------------
 1010         // @Parameters    None 
 1011         //
 1012         //----------------------------------------------------------------------------
 1013         // @Date          2020-03-04
 1014         //
 1015         //****************************************************************************
 1016         
 1017         // USER CODE BEGIN (If_TxConfirmation,1)
 1018         
 1019         CAN_DIAG_STAT INT8U u0x155MsgRollingTimeoutCnt = 0u;
 1020         CAN_DIAG_STAT INT8U u0x155MsgRollingRecoverCnt = 0u;
 1021         
 1022         // USER CODE END
 1023         
 1024         BOOLEAN CanDiag_DTC_BMS_0x155MsgRollingCount(CanReceiveHandle* rcvObject)
 1025         {
 1026  1      
 1027  1        // USER CODE BEGIN (If_TxConfirmation,2)
 1028  1        
 1029  1              CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
 1030  1          CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
 1031  1              CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
 1032  1      
 1033  1              INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
 1034  1              
 1035  1              if (FALSE == bFristMsgFlag)
 1036  1              {
 1037  2                      bFristMsgFlag = TRUE;
 1038  2                      uRollingContinuity = 0u;
 1039  2                      uPreRollingValue = uCurRollingValue;
 1040  2      
 1041  2                      return FALSE;
 1042  2              }
 1043  1              else
 1044  1              {
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 18  

 1045  2                      uPreRollingValue++;
 1046  2                      if (15u == uPreRollingValue)
 1047  2                      {
 1048  3                              uPreRollingValue = 0u;
 1049  3                      }
 1050  2      
 1051  2                      if (uPreRollingValue == uCurRollingValue)
 1052  2                      {
 1053  3                              uRollingContinuity++;
 1054  3                      }
 1055  2                      else
 1056  2                      {
 1057  3                              bFristMsgFlag = FALSE;
 1058  3                              uRollingContinuity = 0u;
 1059  3                      }
 1060  2      
 1061  2                      if (FALSE == t_canDtcErr.b0x155MsgRollingCntErr)
 1062  2                      {
 1063  3                              if (uRollingContinuity < 10u)
 1064  3                              {
 1065  4                                      u0x155MsgRollingRecoverCnt = 0u;
 1066  4      
 1067  4                                      u0x155MsgRollingTimeoutCnt++;
 1068  4                                      if (u0x155MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 1069  4                                      {
 1070  5                                              u0x155MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 1071  5                                              t_canDtcErr.b0x155MsgRollingCntErr = TRUE;
 1072  5      
 1073  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1074  5                                              {
 1075  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x155_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 1076  6                                              }
 1077  5                                      }
 1078  4                              }
 1079  3                              else
 1080  3                              {
 1081  4                                      u0x155MsgRollingTimeoutCnt = 0u;
 1082  4                                      u0x155MsgRollingRecoverCnt = 0u;
 1083  4                                      t_canDtcErr.b0x155MsgRollingCntErr = FALSE;
 1084  4                              }
 1085  3                      }
 1086  2                      else
 1087  2                      {
 1088  3                              if (uRollingContinuity >= 10u)
 1089  3                              {
 1090  4                                      u0x155MsgRollingTimeoutCnt = 0u;
 1091  4      
 1092  4                                      u0x155MsgRollingRecoverCnt++;
 1093  4                                      if (u0x155MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
 1094  4                                      {
 1095  5                                              u0x155MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
 1096  5                                              t_canDtcErr.b0x155MsgRollingCntErr = FALSE;
 1097  5      
 1098  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1099  5                                              {
 1100  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x155_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
 1101  6                                              }
 1102  5                                      }
 1103  4                              }
 1104  3                              else
 1105  3                              {
 1106  4                                      u0x155MsgRollingTimeoutCnt = 0u;
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 19  

 1107  4                                      u0x155MsgRollingRecoverCnt = 0u;
 1108  4                                      t_canDtcErr.b0x155MsgRollingCntErr = TRUE;                              
 1109  4                              }
 1110  3                      }
 1111  2      
 1112  2                      if (uRollingContinuity >= 10u)
 1113  2                      {
 1114  3                              uRollingContinuity = 10u;
 1115  3                              return TRUE;
 1116  3                      }
 1117  2                      else
 1118  2                      {
 1119  3                              return FALSE;   
 1120  3                      }
 1121  2              }
 1122  1      
 1123  1        // USER CODE END
 1124  1      
 1125  1      } //  End of function CanDiag_DTC_BMS_0x155MsgRollingCount
 1126         
 1127         //****************************************************************************
 1128         // @Function      void CanDiag_DTC_VCU_0x16eMsgRollingCount()
 1129         //
 1130         //----------------------------------------------------------------------------
 1131         // @Description   This function check 0x16E message rolling counter.
 1132         //
 1133         //----------------------------------------------------------------------------
 1134         // @Returnvalue   None
 1135         //
 1136         //----------------------------------------------------------------------------
 1137         // @Parameters    None 
 1138         //
 1139         //----------------------------------------------------------------------------
 1140         // @Date          2020-03-04
 1141         //
 1142         //****************************************************************************
 1143         
 1144         // USER CODE BEGIN (If_TxConfirmation,1)
 1145         
 1146         CAN_DIAG_STAT INT8U u0x16eMsgRollingTimeoutCnt = 0u;
 1147         CAN_DIAG_STAT INT8U u0x16eMsgRollingRecoverCnt = 0u;
 1148         
 1149         // USER CODE END
 1150         
 1151         BOOLEAN CanDiag_DTC_VCU_0x16eMsgRollingCount(CanReceiveHandle* rcvObject)
 1152         {
 1153  1      
 1154  1        // USER CODE BEGIN (If_TxConfirmation,2)
 1155  1        
 1156  1              CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
 1157  1          CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
 1158  1              CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
 1159  1      
 1160  1              INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
 1161  1              
 1162  1              if (FALSE == bFristMsgFlag)
 1163  1              {
 1164  2                      bFristMsgFlag = TRUE;
 1165  2                      uRollingContinuity = 0u;
 1166  2                      uPreRollingValue = uCurRollingValue;
 1167  2      
 1168  2                      return FALSE;
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 20  

 1169  2              }
 1170  1              else
 1171  1              {
 1172  2                      uPreRollingValue++;
 1173  2                      if (15u == uPreRollingValue)
 1174  2                      {
 1175  3                              uPreRollingValue = 0u;
 1176  3                      }
 1177  2      
 1178  2                      if (uPreRollingValue == uCurRollingValue)
 1179  2                      {
 1180  3                              uRollingContinuity++;
 1181  3                      }
 1182  2                      else
 1183  2                      {
 1184  3                              bFristMsgFlag = FALSE;
 1185  3                              uRollingContinuity = 0u;
 1186  3                      }
 1187  2      
 1188  2                      if (FALSE == t_canDtcErr.b0x16eMsgRollingCntErr)
 1189  2                      {
 1190  3                              if (uRollingContinuity < 10u)
 1191  3                              {
 1192  4                                      u0x16eMsgRollingRecoverCnt = 0u;
 1193  4      
 1194  4                                      u0x16eMsgRollingTimeoutCnt++;
 1195  4                                      if (u0x16eMsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 1196  4                                      {
 1197  5                                              u0x16eMsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 1198  5                                              t_canDtcErr.b0x16eMsgRollingCntErr = TRUE;
 1199  5      
 1200  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1201  5                                              {
 1202  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x16E_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 1203  6                                              }
 1204  5                                      }
 1205  4                              }
 1206  3                              else
 1207  3                              {
 1208  4                                      u0x16eMsgRollingTimeoutCnt = 0u;
 1209  4                                      u0x16eMsgRollingRecoverCnt = 0u;
 1210  4                                      t_canDtcErr.b0x16eMsgRollingCntErr = FALSE;
 1211  4                              }
 1212  3                      }
 1213  2                      else
 1214  2                      {
 1215  3                              if (uRollingContinuity >= 10u)
 1216  3                              {
 1217  4                                      u0x16eMsgRollingTimeoutCnt = 0u;
 1218  4      
 1219  4                                      u0x16eMsgRollingRecoverCnt++;
 1220  4                                      if (u0x16eMsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
 1221  4                                      {
 1222  5                                              u0x16eMsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
 1223  5                                              t_canDtcErr.b0x16eMsgRollingCntErr = FALSE;
 1224  5      
 1225  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1226  5                                              {
 1227  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x16E_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
 1228  6                                              }
 1229  5                                      }
 1230  4                              }
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 21  

 1231  3                              else
 1232  3                              {
 1233  4                                      u0x16eMsgRollingTimeoutCnt = 0u;
 1234  4                                      u0x16eMsgRollingRecoverCnt = 0u;
 1235  4                                      t_canDtcErr.b0x16eMsgRollingCntErr = TRUE;                              
 1236  4                              }
 1237  3                      }
 1238  2      
 1239  2                      if (uRollingContinuity >= 10u)
 1240  2                      {
 1241  3                              uRollingContinuity = 10u;
 1242  3                              return TRUE;
 1243  3                      }
 1244  2                      else
 1245  2                      {
 1246  3                              return FALSE;   
 1247  3                      }
 1248  2              }
 1249  1      
 1250  1        // USER CODE END
 1251  1      
 1252  1      } //  End of function CanDiag_DTC_VCU_0x16eMsgRollingCount
 1253         
 1254         //****************************************************************************
 1255         // @Function      void CanDiag_DTC_VCU_0x16fMsgRollingCount()
 1256         //
 1257         //----------------------------------------------------------------------------
 1258         // @Description   This function check 0x16F message rolling counter.
 1259         //
 1260         //----------------------------------------------------------------------------
 1261         // @Returnvalue   None
 1262         //
 1263         //----------------------------------------------------------------------------
 1264         // @Parameters    None 
 1265         //
 1266         //----------------------------------------------------------------------------
 1267         // @Date          2020-03-04
 1268         //
 1269         //****************************************************************************
 1270         
 1271         // USER CODE BEGIN (If_TxConfirmation,1)
 1272         
 1273         CAN_DIAG_STAT INT8U u0x16fMsgRollingTimeoutCnt = 0u;
 1274         CAN_DIAG_STAT INT8U u0x16fMsgRollingRecoverCnt = 0u;
 1275         
 1276         // USER CODE END
 1277         
 1278         BOOLEAN CanDiag_DTC_VCU_0x16fMsgRollingCount(CanReceiveHandle* rcvObject)
 1279         {
 1280  1      
 1281  1        // USER CODE BEGIN (If_TxConfirmation,2)
 1282  1        
 1283  1              CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
 1284  1          CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
 1285  1              CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
 1286  1      
 1287  1              INT8U uCurRollingValue = (INT8U)((rcvObject[7] & 0xF0) >> 4u);  
 1288  1              
 1289  1              if (FALSE == bFristMsgFlag)
 1290  1              {
 1291  2                      bFristMsgFlag = TRUE;
 1292  2                      uRollingContinuity = 0u;
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 22  

 1293  2                      uPreRollingValue = uCurRollingValue;
 1294  2      
 1295  2                      return FALSE;
 1296  2              }
 1297  1              else
 1298  1              {
 1299  2                      uPreRollingValue++;
 1300  2                      if (15u == uPreRollingValue)
 1301  2                      {
 1302  3                              uPreRollingValue = 0u;
 1303  3                      }
 1304  2      
 1305  2                      if (uPreRollingValue == uCurRollingValue)
 1306  2                      {
 1307  3                              uRollingContinuity++;
 1308  3                      }
 1309  2                      else
 1310  2                      {
 1311  3                              bFristMsgFlag = FALSE;
 1312  3                              uRollingContinuity = 0u;
 1313  3                      }
 1314  2      
 1315  2                      if (FALSE == t_canDtcErr.b0x16fMsgRollingCntErr)
 1316  2                      {
 1317  3                              if (uRollingContinuity < 10u)
 1318  3                              {
 1319  4                                      u0x16fMsgRollingRecoverCnt = 0u;
 1320  4      
 1321  4                                      u0x16fMsgRollingTimeoutCnt++;
 1322  4                                      if (u0x16fMsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 1323  4                                      {
 1324  5                                              u0x16fMsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 1325  5                                              t_canDtcErr.b0x16fMsgRollingCntErr = TRUE;
 1326  5      
 1327  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1328  5                                              {
 1329  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x16F_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 1330  6                                              }
 1331  5                                      }
 1332  4                              }
 1333  3                              else
 1334  3                              {
 1335  4                                      u0x16fMsgRollingTimeoutCnt = 0u;
 1336  4                                      u0x16fMsgRollingRecoverCnt = 0u;
 1337  4                                      t_canDtcErr.b0x16fMsgRollingCntErr = FALSE;
 1338  4                              }
 1339  3                      }
 1340  2                      else
 1341  2                      {
 1342  3                              if (uRollingContinuity >= 10u)
 1343  3                              {
 1344  4                                      u0x16fMsgRollingTimeoutCnt = 0u;
 1345  4      
 1346  4                                      u0x16fMsgRollingRecoverCnt++;
 1347  4                                      if (u0x16fMsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
 1348  4                                      {
 1349  5                                              u0x16fMsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
 1350  5                                              t_canDtcErr.b0x16fMsgRollingCntErr = FALSE;
 1351  5      
 1352  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1353  5                                              {
 1354  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x16F_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 23  

 1355  6                                              }
 1356  5                                      }
 1357  4                              }
 1358  3                              else
 1359  3                              {
 1360  4                                      u0x16fMsgRollingTimeoutCnt = 0u;
 1361  4                                      u0x16fMsgRollingRecoverCnt = 0u;
 1362  4                                      t_canDtcErr.b0x16fMsgRollingCntErr = TRUE;                              
 1363  4                              }
 1364  3                      }
 1365  2      
 1366  2                      if (uRollingContinuity >= 10u)
 1367  2                      {
 1368  3                              uRollingContinuity = 10u;
 1369  3                              return TRUE;
 1370  3                      }
 1371  2                      else
 1372  2                      {
 1373  3                              return FALSE;   
 1374  3                      }
 1375  2              }
 1376  1      
 1377  1        // USER CODE END
 1378  1      
 1379  1      } //  End of function CanDiag_DTC_VCU_0x16fMsgRollingCount
 1380         
 1381         //****************************************************************************
 1382         // @Function      void CanDiag_DTC_GW_0x278MsgRollingCount()
 1383         //
 1384         //----------------------------------------------------------------------------
 1385         // @Description   This function check 0x278 message rolling counter.
 1386         //
 1387         //----------------------------------------------------------------------------
 1388         // @Returnvalue   None
 1389         //
 1390         //----------------------------------------------------------------------------
 1391         // @Parameters    None 
 1392         //
 1393         //----------------------------------------------------------------------------
 1394         // @Date          2020-03-04
 1395         //
 1396         //****************************************************************************
 1397         
 1398         // USER CODE BEGIN (If_TxConfirmation,1)
 1399         
 1400         CAN_DIAG_STAT INT8U u0x278MsgRollingTimeoutCnt = 0u;
 1401         CAN_DIAG_STAT INT8U u0x278MsgRollingRecoverCnt = 0u;
 1402         
 1403         // USER CODE END
 1404         
 1405         BOOLEAN CanDiag_DTC_GW_0x278MsgRollingCount(CanReceiveHandle* rcvObject)
 1406         {
 1407  1      
 1408  1        // USER CODE BEGIN (If_TxConfirmation,2)
 1409  1        
 1410  1              CAN_DIAG_STAT INT8U uPreRollingValue = 0u;
 1411  1          CAN_DIAG_STAT INT8U uRollingContinuity = 0u;
 1412  1              CAN_DIAG_STAT BOOLEAN bFristMsgFlag = FALSE;
 1413  1      
 1414  1              INT8U uCurRollingValue = (INT8U)((rcvObject[6] & 0x0F) >> 4u);  
 1415  1              
 1416  1              if (FALSE == bFristMsgFlag)
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 24  

 1417  1              {
 1418  2                      bFristMsgFlag = TRUE;
 1419  2                      uRollingContinuity = 0u;
 1420  2                      uPreRollingValue = uCurRollingValue;
 1421  2      
 1422  2                      return FALSE;
 1423  2              }
 1424  1              else
 1425  1              {
 1426  2                      uPreRollingValue++;
 1427  2                      if (15u == uPreRollingValue)
 1428  2                      {
 1429  3                              uPreRollingValue = 0u;
 1430  3                      }
 1431  2      
 1432  2                      if (uPreRollingValue == uCurRollingValue)
 1433  2                      {
 1434  3                              uRollingContinuity++;
 1435  3                      }
 1436  2                      else
 1437  2                      {
 1438  3                              bFristMsgFlag = FALSE;
 1439  3                              uRollingContinuity = 0u;
 1440  3                      }
 1441  2      
 1442  2                      if (FALSE == t_canDtcErr.b0x278MsgRollingCntErr)
 1443  2                      {
 1444  3                              if (uRollingContinuity < 10u)
 1445  3                              {
 1446  4                                      u0x278MsgRollingRecoverCnt = 0u;
 1447  4      
 1448  4                                      u0x278MsgRollingTimeoutCnt++;
 1449  4                                      if (u0x278MsgRollingTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 1450  4                                      {
 1451  5                                              u0x278MsgRollingTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 1452  5                                              t_canDtcErr.b0x278MsgRollingCntErr = TRUE;
 1453  5      
 1454  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1455  5                                              {
 1456  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x278_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 1457  6                                              }
 1458  5                                      }
 1459  4                              }
 1460  3                              else
 1461  3                              {
 1462  4                                      u0x278MsgRollingTimeoutCnt = 0u;
 1463  4                                      u0x278MsgRollingRecoverCnt = 0u;
 1464  4                                      t_canDtcErr.b0x278MsgRollingCntErr = FALSE;
 1465  4                              }
 1466  3                      }
 1467  2                      else
 1468  2                      {
 1469  3                              if (uRollingContinuity >= 10u)
 1470  3                              {
 1471  4                                      u0x278MsgRollingTimeoutCnt = 0u;
 1472  4      
 1473  4                                      u0x278MsgRollingRecoverCnt++;
 1474  4                                      if (u0x278MsgRollingRecoverCnt >= MESSAGE_RECOVER_CYCLE)
 1475  4                                      {
 1476  5                                              u0x278MsgRollingRecoverCnt = MESSAGE_RECOVER_CYCLE;
 1477  5                                              t_canDtcErr.b0x278MsgRollingCntErr = FALSE;
 1478  5      
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 25  

 1479  5                                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1480  5                                              {
 1481  6                                                      DescMgr_DtcStatusDataReport(DTC_CAN_0x278_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
 1482  6                                              }
 1483  5                                      }
 1484  4                              }
 1485  3                              else
 1486  3                              {
 1487  4                                      u0x278MsgRollingTimeoutCnt = 0u;
 1488  4                                      u0x278MsgRollingRecoverCnt = 0u;
 1489  4                                      t_canDtcErr.b0x278MsgRollingCntErr = TRUE;                              
 1490  4                              }
 1491  3                      }
 1492  2      
 1493  2                      if (uRollingContinuity >= 10u)
 1494  2                      {
 1495  3                              uRollingContinuity = 10u;
 1496  3                              return TRUE;
 1497  3                      }
 1498  2                      else
 1499  2                      {
 1500  3                              return FALSE;   
 1501  3                      }
 1502  2              }
 1503  1      
 1504  1        // USER CODE END
 1505  1      
 1506  1      } //  End of function CanDiag_DTC_GW_0x278MsgRollingCount
 1507         
 1508         //****************************************************************************
 1509         // @Function      void CanDiag_DTC_VCU_0x118MsgChecksum()
 1510         //
 1511         //----------------------------------------------------------------------------
 1512         // @Description   This function check 0x118 message checksum.
 1513         //
 1514         //----------------------------------------------------------------------------
 1515         // @Returnvalue   None
 1516         //
 1517         //----------------------------------------------------------------------------
 1518         // @Parameters    None 
 1519         //
 1520         //----------------------------------------------------------------------------
 1521         // @Date          2020-03-04
 1522         //
 1523         //****************************************************************************
 1524         
 1525         // USER CODE BEGIN (If_TxConfirmation,1)
 1526         
 1527         CAN_DIAG_STAT INT8U u0x118MsgChecksumTimeoutCnt = 0u;
 1528         CAN_DIAG_STAT INT8U u0x118MsgChecksumRecoverCnt = 0u;
 1529         
 1530         // USER CODE END
 1531         
 1532         BOOLEAN CanDiag_DTC_VCU_0x118MsgChecksum(CanReceiveHandle* rcvObject)
 1533         {
 1534  1      
 1535  1        // USER CODE BEGIN (If_TxConfirmation,2)
 1536  1      
 1537  1              INT8U i;
 1538  1              INT8U uChecksumValue = 0u;
 1539  1      
 1540  1              for (i = 0u; i < 7; i++)
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 26  

 1541  1              {
 1542  2                      uChecksumValue ^= rcvObject[i]; 
 1543  2              }
 1544  1      
 1545  1              if (FALSE == t_canDtcErr.b0x118MsgChecksumErr)
 1546  1              {
 1547  2                      if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
 1548  2                      {
 1549  3                              u0x118MsgChecksumRecoverCnt = 0u;
 1550  3      
 1551  3                              u0x118MsgChecksumTimeoutCnt++;
 1552  3                              if (u0x118MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 1553  3                              {
 1554  4                                      u0x118MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 1555  4                                      t_canDtcErr.b0x118MsgChecksumErr = TRUE;
 1556  4      
 1557  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1558  4                                      {
 1559  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x118_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 1560  5                                      }
 1561  4                              }
 1562  3                      }
 1563  2                      else
 1564  2                      {
 1565  3                              u0x118MsgChecksumTimeoutCnt = 0u;
 1566  3                              u0x118MsgChecksumRecoverCnt = 0u;
 1567  3                              t_canDtcErr.b0x118MsgChecksumErr = FALSE;
 1568  3                      }
 1569  2              }
 1570  1              else
 1571  1              {
 1572  2                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 1573  2                      {
 1574  3                              u0x118MsgChecksumTimeoutCnt = 0u;
 1575  3      
 1576  3                              u0x118MsgChecksumRecoverCnt++;
 1577  3                              if (u0x118MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
 1578  3                              {
 1579  4                                      u0x118MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
 1580  4                                      t_canDtcErr.b0x118MsgChecksumErr = FALSE;
 1581  4      
 1582  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1583  4                                      {
 1584  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x118_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
 1585  5                                      }                               
 1586  4                              }
 1587  3                      }
 1588  2                      else
 1589  2                      {
 1590  3                              u0x118MsgChecksumTimeoutCnt = 0u;
 1591  3                              u0x118MsgChecksumRecoverCnt = 0u;
 1592  3                              t_canDtcErr.b0x118MsgChecksumErr = TRUE;                        
 1593  3                      }
 1594  2              }
 1595  1      
 1596  1              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 1597  1              {
 1598  2                      return TRUE;
 1599  2              }
 1600  1              else
 1601  1              {
 1602  2                      return FALSE;
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 27  

 1603  2              }       
 1604  1      
 1605  1        // USER CODE END
 1606  1      
 1607  1      } //  End of function CanDiag_DTC_VCU_0x118MsgChecksum
 1608         
 1609         //****************************************************************************
 1610         // @Function      void CanDiag_DTC_VCU_0x119MsgChecksum()
 1611         //
 1612         //----------------------------------------------------------------------------
 1613         // @Description   This function check 0x119 message checksum.
 1614         //
 1615         //----------------------------------------------------------------------------
 1616         // @Returnvalue   None
 1617         //
 1618         //----------------------------------------------------------------------------
 1619         // @Parameters    None 
 1620         //
 1621         //----------------------------------------------------------------------------
 1622         // @Date          2020-03-04
 1623         //
 1624         //****************************************************************************
 1625         
 1626         // USER CODE BEGIN (If_TxConfirmation,1)
 1627         
 1628         CAN_DIAG_STAT INT8U u0x119MsgChecksumTimeoutCnt = 0u;
 1629         CAN_DIAG_STAT INT8U u0x119MsgChecksumRecoverCnt = 0u;
 1630         
 1631         // USER CODE END
 1632         
 1633         BOOLEAN CanDiag_DTC_VCU_0x119MsgChecksum(CanReceiveHandle* rcvObject)
 1634         {
 1635  1      
 1636  1        // USER CODE BEGIN (If_TxConfirmation,2)
 1637  1      
 1638  1              INT8U i;
 1639  1              INT8U uChecksumValue = 0u;
 1640  1      
 1641  1              for (i = 0u; i < 7; i++)
 1642  1              {
 1643  2                      uChecksumValue ^= rcvObject[i]; 
 1644  2              }
 1645  1      
 1646  1              if (FALSE == t_canDtcErr.b0x119MsgChecksumErr)
 1647  1              {
 1648  2                      if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
 1649  2                      {
 1650  3                              u0x119MsgChecksumRecoverCnt = 0u;
 1651  3      
 1652  3                              u0x119MsgChecksumTimeoutCnt++;
 1653  3                              if (u0x119MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 1654  3                              {
 1655  4                                      u0x119MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 1656  4                                      t_canDtcErr.b0x119MsgChecksumErr = TRUE;
 1657  4      
 1658  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1659  4                                      {
 1660  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x119_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 1661  5                                      }
 1662  4                              }
 1663  3                      }
 1664  2                      else
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 28  

 1665  2                      {
 1666  3                              u0x119MsgChecksumTimeoutCnt = 0u;
 1667  3                              u0x119MsgChecksumRecoverCnt = 0u;
 1668  3                              t_canDtcErr.b0x119MsgChecksumErr = FALSE;
 1669  3                      }
 1670  2              }
 1671  1              else
 1672  1              {
 1673  2                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 1674  2                      {
 1675  3                              u0x119MsgChecksumTimeoutCnt = 0u;
 1676  3      
 1677  3                              u0x119MsgChecksumRecoverCnt++;
 1678  3                              if (u0x119MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
 1679  3                              {
 1680  4                                      u0x119MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
 1681  4                                      t_canDtcErr.b0x119MsgChecksumErr = FALSE;
 1682  4      
 1683  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1684  4                                      {
 1685  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x119_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
 1686  5                                      }                               
 1687  4                              }
 1688  3                      }
 1689  2                      else
 1690  2                      {
 1691  3                              u0x119MsgChecksumTimeoutCnt = 0u;
 1692  3                              u0x119MsgChecksumRecoverCnt = 0u;
 1693  3                              t_canDtcErr.b0x119MsgChecksumErr = TRUE;                        
 1694  3                      }
 1695  2              }
 1696  1      
 1697  1              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 1698  1              {
 1699  2                      return TRUE;
 1700  2              }
 1701  1              else
 1702  1              {
 1703  2                      return FALSE;
 1704  2              }       
 1705  1      
 1706  1        // USER CODE END
 1707  1      
 1708  1      } //  End of function CanDiag_DTC_VCU_0x119MsgChecksum
 1709         
 1710         //****************************************************************************
 1711         // @Function      void CanDiag_DTC_VCU_0x126MsgChecksum()
 1712         //
 1713         //----------------------------------------------------------------------------
 1714         // @Description   This function check 0x126 message checksum.
 1715         //
 1716         //----------------------------------------------------------------------------
 1717         // @Returnvalue   None
 1718         //
 1719         //----------------------------------------------------------------------------
 1720         // @Parameters    None 
 1721         //
 1722         //----------------------------------------------------------------------------
 1723         // @Date          2020-03-04
 1724         //
 1725         //****************************************************************************
 1726         
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 29  

 1727         // USER CODE BEGIN (If_TxConfirmation,1)
 1728         
 1729         CAN_DIAG_STAT INT8U u0x126MsgChecksumTimeoutCnt = 0u;
 1730         CAN_DIAG_STAT INT8U u0x126MsgChecksumRecoverCnt = 0u;
 1731         
 1732         // USER CODE END
 1733         
 1734         BOOLEAN CanDiag_DTC_VCU_0x126MsgChecksum(CanReceiveHandle* rcvObject)
 1735         {
 1736  1      
 1737  1        // USER CODE BEGIN (If_TxConfirmation,2)
 1738  1      
 1739  1              INT8U i;
 1740  1              INT8U uChecksumValue = 0u;
 1741  1      
 1742  1              for (i = 0u; i < 7; i++)
 1743  1              {
 1744  2                      uChecksumValue ^= rcvObject[i]; 
 1745  2              }
 1746  1      
 1747  1              if (FALSE == t_canDtcErr.b0x126MsgChecksumErr)
 1748  1              {
 1749  2                      if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
 1750  2                      {
 1751  3                              u0x126MsgChecksumRecoverCnt = 0u;
 1752  3      
 1753  3                              u0x126MsgChecksumTimeoutCnt++;
 1754  3                              if (u0x126MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 1755  3                              {
 1756  4                                      u0x126MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 1757  4                                      t_canDtcErr.b0x126MsgChecksumErr = TRUE;
 1758  4      
 1759  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1760  4                                      {
 1761  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x126_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 1762  5                                      }
 1763  4                              }
 1764  3                      }
 1765  2                      else
 1766  2                      {
 1767  3                              u0x126MsgChecksumTimeoutCnt = 0u;
 1768  3                              u0x126MsgChecksumRecoverCnt = 0u;
 1769  3                              t_canDtcErr.b0x126MsgChecksumErr = FALSE;
 1770  3                      }
 1771  2              }
 1772  1              else
 1773  1              {
 1774  2                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 1775  2                      {
 1776  3                              u0x126MsgChecksumTimeoutCnt = 0u;
 1777  3      
 1778  3                              u0x126MsgChecksumRecoverCnt++;
 1779  3                              if (u0x126MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
 1780  3                              {
 1781  4                                      u0x126MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
 1782  4                                      t_canDtcErr.b0x126MsgChecksumErr = FALSE;
 1783  4      
 1784  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1785  4                                      {
 1786  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x126_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
 1787  5                                      }                               
 1788  4                              }
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 30  

 1789  3                      }
 1790  2                      else
 1791  2                      {
 1792  3                              u0x126MsgChecksumTimeoutCnt = 0u;
 1793  3                              u0x126MsgChecksumRecoverCnt = 0u;
 1794  3                              t_canDtcErr.b0x126MsgChecksumErr = TRUE;                        
 1795  3                      }
 1796  2              }
 1797  1      
 1798  1              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 1799  1              {
 1800  2                      return TRUE;
 1801  2              }
 1802  1              else
 1803  1              {
 1804  2                      return FALSE;
 1805  2              }       
 1806  1      
 1807  1        // USER CODE END
 1808  1      
 1809  1      } //  End of function CanDiag_DTC_VCU_0x126MsgChecksum
 1810         
 1811         //****************************************************************************
 1812         // @Function      void CanDiag_DTC_MCU_0x130MsgChecksum()
 1813         //
 1814         //----------------------------------------------------------------------------
 1815         // @Description   This function check 0x130 message checksum.
 1816         //
 1817         //----------------------------------------------------------------------------
 1818         // @Returnvalue   None
 1819         //
 1820         //----------------------------------------------------------------------------
 1821         // @Parameters    None 
 1822         //
 1823         //----------------------------------------------------------------------------
 1824         // @Date          2020-03-04
 1825         //
 1826         //****************************************************************************
 1827         
 1828         // USER CODE BEGIN (If_TxConfirmation,1)
 1829         
 1830         CAN_DIAG_STAT INT8U u0x130MsgChecksumTimeoutCnt = 0u;
 1831         CAN_DIAG_STAT INT8U u0x130MsgChecksumRecoverCnt = 0u;
 1832         
 1833         // USER CODE END
 1834         
 1835         BOOLEAN CanDiag_DTC_MCU_0x130MsgChecksum(CanReceiveHandle* rcvObject)
 1836         {
 1837  1      
 1838  1        // USER CODE BEGIN (If_TxConfirmation,2)
 1839  1      
 1840  1              INT8U i;
 1841  1              INT8U uChecksumValue = 0u;
 1842  1      
 1843  1              for (i = 0u; i < 7; i++)
 1844  1              {
 1845  2                      uChecksumValue ^= rcvObject[i]; 
 1846  2              }
 1847  1      
 1848  1              if (FALSE == t_canDtcErr.b0x130MsgChecksumErr)
 1849  1              {
 1850  2                      if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 31  

 1851  2                      {
 1852  3                              u0x130MsgChecksumRecoverCnt = 0u;
 1853  3      
 1854  3                              u0x130MsgChecksumTimeoutCnt++;
 1855  3                              if (u0x130MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 1856  3                              {
 1857  4                                      u0x130MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 1858  4                                      t_canDtcErr.b0x130MsgChecksumErr = TRUE;
 1859  4      
 1860  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1861  4                                      {
 1862  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x130_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 1863  5                                      }
 1864  4                              }
 1865  3                      }
 1866  2                      else
 1867  2                      {
 1868  3                              u0x130MsgChecksumTimeoutCnt = 0u;
 1869  3                              u0x130MsgChecksumRecoverCnt = 0u;
 1870  3                              t_canDtcErr.b0x130MsgChecksumErr = FALSE;
 1871  3                      }
 1872  2              }
 1873  1              else
 1874  1              {
 1875  2                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 1876  2                      {
 1877  3                              u0x130MsgChecksumTimeoutCnt = 0u;
 1878  3      
 1879  3                              u0x130MsgChecksumRecoverCnt++;
 1880  3                              if (u0x130MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
 1881  3                              {
 1882  4                                      u0x130MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
 1883  4                                      t_canDtcErr.b0x130MsgChecksumErr = FALSE;
 1884  4      
 1885  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1886  4                                      {
 1887  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x130_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
 1888  5                                      }                               
 1889  4                              }
 1890  3                      }
 1891  2                      else
 1892  2                      {
 1893  3                              u0x130MsgChecksumTimeoutCnt = 0u;
 1894  3                              u0x130MsgChecksumRecoverCnt = 0u;
 1895  3                              t_canDtcErr.b0x130MsgChecksumErr = TRUE;                        
 1896  3                      }
 1897  2              }
 1898  1      
 1899  1              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 1900  1              {
 1901  2                      return TRUE;
 1902  2              }
 1903  1              else
 1904  1              {
 1905  2                      return FALSE;
 1906  2              }       
 1907  1      
 1908  1        // USER CODE END
 1909  1      
 1910  1      } //  End of function CanDiag_DTC_MCU_0x130MsgChecksum
 1911         
 1912         //****************************************************************************
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 32  

 1913         // @Function      void CanDiag_DTC_MCU_0x132MsgChecksum()
 1914         //
 1915         //----------------------------------------------------------------------------
 1916         // @Description   This function check 0x132 message checksum.
 1917         //
 1918         //----------------------------------------------------------------------------
 1919         // @Returnvalue   None
 1920         //
 1921         //----------------------------------------------------------------------------
 1922         // @Parameters    None 
 1923         //
 1924         //----------------------------------------------------------------------------
 1925         // @Date          2020-03-04
 1926         //
 1927         //****************************************************************************
 1928         
 1929         // USER CODE BEGIN (If_TxConfirmation,1)
 1930         
 1931         CAN_DIAG_STAT INT8U u0x132MsgChecksumTimeoutCnt = 0u;
 1932         CAN_DIAG_STAT INT8U u0x132MsgChecksumRecoverCnt = 0u;
 1933         
 1934         // USER CODE END
 1935         
 1936         BOOLEAN CanDiag_DTC_MCU_0x132MsgChecksum(CanReceiveHandle* rcvObject)
 1937         {
 1938  1      
 1939  1        // USER CODE BEGIN (If_TxConfirmation,2)
 1940  1      
 1941  1              INT8U i;
 1942  1              INT8U uChecksumValue = 0u;
 1943  1      
 1944  1              for (i = 0u; i < 7; i++)
 1945  1              {
 1946  2                      uChecksumValue ^= rcvObject[i]; 
 1947  2              }
 1948  1      
 1949  1              if (FALSE == t_canDtcErr.b0x132MsgChecksumErr)
 1950  1              {
 1951  2                      if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
 1952  2                      {
 1953  3                              u0x132MsgChecksumRecoverCnt = 0u;
 1954  3      
 1955  3                              u0x132MsgChecksumTimeoutCnt++;
 1956  3                              if (u0x132MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 1957  3                              {
 1958  4                                      u0x132MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 1959  4                                      t_canDtcErr.b0x132MsgChecksumErr = TRUE;
 1960  4      
 1961  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1962  4                                      {
 1963  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x132_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 1964  5                                      }
 1965  4                              }
 1966  3                      }
 1967  2                      else
 1968  2                      {
 1969  3                              u0x132MsgChecksumTimeoutCnt = 0u;
 1970  3                              u0x132MsgChecksumRecoverCnt = 0u;
 1971  3                              t_canDtcErr.b0x132MsgChecksumErr = FALSE;
 1972  3                      }
 1973  2              }
 1974  1              else
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 33  

 1975  1              {
 1976  2                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 1977  2                      {
 1978  3                              u0x132MsgChecksumTimeoutCnt = 0u;
 1979  3      
 1980  3                              u0x132MsgChecksumRecoverCnt++;
 1981  3                              if (u0x132MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
 1982  3                              {
 1983  4                                      u0x132MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
 1984  4                                      t_canDtcErr.b0x132MsgChecksumErr = FALSE;
 1985  4      
 1986  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1987  4                                      {
 1988  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x132_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
 1989  5                                      }                               
 1990  4                              }
 1991  3                      }
 1992  2                      else
 1993  2                      {
 1994  3                              u0x132MsgChecksumTimeoutCnt = 0u;
 1995  3                              u0x132MsgChecksumRecoverCnt = 0u;
 1996  3                              t_canDtcErr.b0x132MsgChecksumErr = TRUE;                        
 1997  3                      }
 1998  2              }
 1999  1      
 2000  1              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 2001  1              {
 2002  2                      return TRUE;
 2003  2              }
 2004  1              else
 2005  1              {
 2006  2                      return FALSE;
 2007  2              }       
 2008  1      
 2009  1        // USER CODE END
 2010  1      
 2011  1      } //  End of function CanDiag_DTC_MCU_0x132MsgChecksum
 2012         
 2013         //****************************************************************************
 2014         // @Function      void CanDiag_DTC_BMS_0x140MsgChecksum()
 2015         //
 2016         //----------------------------------------------------------------------------
 2017         // @Description   This function check 0x140 message checksum.
 2018         //
 2019         //----------------------------------------------------------------------------
 2020         // @Returnvalue   None
 2021         //
 2022         //----------------------------------------------------------------------------
 2023         // @Parameters    None 
 2024         //
 2025         //----------------------------------------------------------------------------
 2026         // @Date          2020-03-04
 2027         //
 2028         //****************************************************************************
 2029         
 2030         // USER CODE BEGIN (If_TxConfirmation,1)
 2031         
 2032         CAN_DIAG_STAT INT8U u0x140MsgChecksumTimeoutCnt = 0u;
 2033         CAN_DIAG_STAT INT8U u0x140MsgChecksumRecoverCnt = 0u;
 2034         
 2035         // USER CODE END
 2036         
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 34  

 2037         BOOLEAN CanDiag_DTC_BMS_0x140MsgChecksum(CanReceiveHandle* rcvObject)
 2038         {
 2039  1      
 2040  1        // USER CODE BEGIN (If_TxConfirmation,2)
 2041  1      
 2042  1              INT8U i;
 2043  1              INT8U uChecksumValue = 0u;
 2044  1      
 2045  1              for (i = 0u; i < 7; i++)
 2046  1              {
 2047  2                      uChecksumValue ^= rcvObject[i]; 
 2048  2              }
 2049  1      
 2050  1              if (FALSE == t_canDtcErr.b0x140MsgChecksumErr)
 2051  1              {
 2052  2                      if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
 2053  2                      {
 2054  3                              u0x140MsgChecksumRecoverCnt = 0u;
 2055  3      
 2056  3                              u0x140MsgChecksumTimeoutCnt++;
 2057  3                              if (u0x140MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 2058  3                              {
 2059  4                                      u0x140MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 2060  4                                      t_canDtcErr.b0x140MsgChecksumErr = TRUE;
 2061  4      
 2062  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 2063  4                                      {
 2064  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x140_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 2065  5                                      }
 2066  4                              }
 2067  3                      }
 2068  2                      else
 2069  2                      {
 2070  3                              u0x140MsgChecksumTimeoutCnt = 0u;
 2071  3                              u0x140MsgChecksumRecoverCnt = 0u;
 2072  3                              t_canDtcErr.b0x140MsgChecksumErr = FALSE;
 2073  3                      }
 2074  2              }
 2075  1              else
 2076  1              {
 2077  2                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 2078  2                      {
 2079  3                              u0x140MsgChecksumTimeoutCnt = 0u;
 2080  3      
 2081  3                              u0x140MsgChecksumRecoverCnt++;
 2082  3                              if (u0x140MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
 2083  3                              {
 2084  4                                      u0x140MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
 2085  4                                      t_canDtcErr.b0x140MsgChecksumErr = FALSE;
 2086  4      
 2087  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 2088  4                                      {
 2089  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x140_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
 2090  5                                      }                               
 2091  4                              }
 2092  3                      }
 2093  2                      else
 2094  2                      {
 2095  3                              u0x140MsgChecksumTimeoutCnt = 0u;
 2096  3                              u0x140MsgChecksumRecoverCnt = 0u;
 2097  3                              t_canDtcErr.b0x140MsgChecksumErr = TRUE;                        
 2098  3                      }
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 35  

 2099  2              }
 2100  1      
 2101  1              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 2102  1              {
 2103  2                      return TRUE;
 2104  2              }
 2105  1              else
 2106  1              {
 2107  2                      return FALSE;
 2108  2              }       
 2109  1      
 2110  1        // USER CODE END
 2111  1      
 2112  1      } //  End of function CanDiag_DTC_BMS_0x140MsgChecksum
 2113         
 2114         //****************************************************************************
 2115         // @Function      void CanDiag_DTC_BMS_0x148MsgChecksum()
 2116         //
 2117         //----------------------------------------------------------------------------
 2118         // @Description   This function check 0x148 message checksum.
 2119         //
 2120         //----------------------------------------------------------------------------
 2121         // @Returnvalue   None
 2122         //
 2123         //----------------------------------------------------------------------------
 2124         // @Parameters    None 
 2125         //
 2126         //----------------------------------------------------------------------------
 2127         // @Date          2020-03-04
 2128         //
 2129         //****************************************************************************
 2130         
 2131         // USER CODE BEGIN (If_TxConfirmation,1)
 2132         
 2133         CAN_DIAG_STAT INT8U u0x148MsgChecksumTimeoutCnt = 0u;
 2134         CAN_DIAG_STAT INT8U u0x148MsgChecksumRecoverCnt = 0u;
 2135         
 2136         // USER CODE END
 2137         
 2138         BOOLEAN CanDiag_DTC_BMS_0x148MsgChecksum(CanReceiveHandle* rcvObject)
 2139         {
 2140  1      
 2141  1        // USER CODE BEGIN (If_TxConfirmation,2)
 2142  1      
 2143  1              INT8U i;
 2144  1              INT8U uChecksumValue = 0u;
 2145  1      
 2146  1              for (i = 0u; i < 7; i++)
 2147  1              {
 2148  2                      uChecksumValue ^= rcvObject[i]; 
 2149  2              }
 2150  1      
 2151  1              if (FALSE == t_canDtcErr.b0x148MsgChecksumErr)
 2152  1              {
 2153  2                      if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
 2154  2                      {
 2155  3                              u0x148MsgChecksumRecoverCnt = 0u;
 2156  3      
 2157  3                              u0x148MsgChecksumTimeoutCnt++;
 2158  3                              if (u0x148MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 2159  3                              {
 2160  4                                      u0x148MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 36  

 2161  4                                      t_canDtcErr.b0x148MsgChecksumErr = TRUE;
 2162  4      
 2163  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 2164  4                                      {
 2165  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x148_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 2166  5                                      }
 2167  4                              }
 2168  3                      }
 2169  2                      else
 2170  2                      {
 2171  3                              u0x148MsgChecksumTimeoutCnt = 0u;
 2172  3                              u0x148MsgChecksumRecoverCnt = 0u;
 2173  3                              t_canDtcErr.b0x148MsgChecksumErr = FALSE;
 2174  3                      }
 2175  2              }
 2176  1              else
 2177  1              {
 2178  2                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 2179  2                      {
 2180  3                              u0x148MsgChecksumTimeoutCnt = 0u;
 2181  3      
 2182  3                              u0x148MsgChecksumRecoverCnt++;
 2183  3                              if (u0x148MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
 2184  3                              {
 2185  4                                      u0x148MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
 2186  4                                      t_canDtcErr.b0x148MsgChecksumErr = FALSE;
 2187  4      
 2188  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 2189  4                                      {
 2190  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x148_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
 2191  5                                      }                               
 2192  4                              }
 2193  3                      }
 2194  2                      else
 2195  2                      {
 2196  3                              u0x148MsgChecksumTimeoutCnt = 0u;
 2197  3                              u0x148MsgChecksumRecoverCnt = 0u;
 2198  3                              t_canDtcErr.b0x148MsgChecksumErr = TRUE;                        
 2199  3                      }
 2200  2              }
 2201  1      
 2202  1              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 2203  1              {
 2204  2                      return TRUE;
 2205  2              }
 2206  1              else
 2207  1              {
 2208  2                      return FALSE;
 2209  2              }       
 2210  1      
 2211  1        // USER CODE END
 2212  1      
 2213  1      } //  End of function CanDiag_DTC_BMS_0x148MsgChecksum
 2214         
 2215         //****************************************************************************
 2216         // @Function      void CanDiag_DTC_BMS_0x155MsgChecksum()
 2217         //
 2218         //----------------------------------------------------------------------------
 2219         // @Description   This function check 0x155 message checksum.
 2220         //
 2221         //----------------------------------------------------------------------------
 2222         // @Returnvalue   None
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 37  

 2223         //
 2224         //----------------------------------------------------------------------------
 2225         // @Parameters    None 
 2226         //
 2227         //----------------------------------------------------------------------------
 2228         // @Date          2020-03-04
 2229         //
 2230         //****************************************************************************
 2231         
 2232         // USER CODE BEGIN (If_TxConfirmation,1)
 2233         
 2234         CAN_DIAG_STAT INT8U u0x155MsgChecksumTimeoutCnt = 0u;
 2235         CAN_DIAG_STAT INT8U u0x155MsgChecksumRecoverCnt = 0u;
 2236         
 2237         // USER CODE END
 2238         
 2239         BOOLEAN CanDiag_DTC_BMS_0x155MsgChecksum(CanReceiveHandle* rcvObject)
 2240         {
 2241  1      
 2242  1        // USER CODE BEGIN (If_TxConfirmation,2)
 2243  1      
 2244  1              INT8U i;
 2245  1              INT8U uChecksumValue = 0u;
 2246  1      
 2247  1              for (i = 0u; i < 7; i++)
 2248  1              {
 2249  2                      uChecksumValue ^= rcvObject[i]; 
 2250  2              }
 2251  1      
 2252  1              if (FALSE == t_canDtcErr.b0x155MsgChecksumErr)
 2253  1              {
 2254  2                      if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
 2255  2                      {
 2256  3                              u0x155MsgChecksumRecoverCnt = 0u;
 2257  3      
 2258  3                              u0x155MsgChecksumTimeoutCnt++;
 2259  3                              if (u0x155MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 2260  3                              {
 2261  4                                      u0x155MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 2262  4                                      t_canDtcErr.b0x155MsgChecksumErr = TRUE;
 2263  4      
 2264  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 2265  4                                      {
 2266  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x155_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 2267  5                                      }
 2268  4                              }
 2269  3                      }
 2270  2                      else
 2271  2                      {
 2272  3                              u0x155MsgChecksumTimeoutCnt = 0u;
 2273  3                              u0x155MsgChecksumRecoverCnt = 0u;
 2274  3                              t_canDtcErr.b0x155MsgChecksumErr = FALSE;
 2275  3                      }
 2276  2              }
 2277  1              else
 2278  1              {
 2279  2                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 2280  2                      {
 2281  3                              u0x155MsgChecksumTimeoutCnt = 0u;
 2282  3      
 2283  3                              u0x155MsgChecksumRecoverCnt++;
 2284  3                              if (u0x155MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 38  

 2285  3                              {
 2286  4                                      u0x155MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
 2287  4                                      t_canDtcErr.b0x155MsgChecksumErr = FALSE;
 2288  4      
 2289  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 2290  4                                      {
 2291  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x155_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
 2292  5                                      }                               
 2293  4                              }
 2294  3                      }
 2295  2                      else
 2296  2                      {
 2297  3                              u0x155MsgChecksumTimeoutCnt = 0u;
 2298  3                              u0x155MsgChecksumRecoverCnt = 0u;
 2299  3                              t_canDtcErr.b0x155MsgChecksumErr = TRUE;                        
 2300  3                      }
 2301  2              }
 2302  1      
 2303  1              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 2304  1              {
 2305  2                      return TRUE;
 2306  2              }
 2307  1              else
 2308  1              {
 2309  2                      return FALSE;
 2310  2              }       
 2311  1      
 2312  1        // USER CODE END
 2313  1      
 2314  1      } //  End of function CanDiag_DTC_BMS_0x155MsgChecksum
 2315         
 2316         //****************************************************************************
 2317         // @Function      void CanDiag_DTC_VCU_0x16eMsgChecksum()
 2318         //
 2319         //----------------------------------------------------------------------------
 2320         // @Description   This function check 0x16E message checksum.
 2321         //
 2322         //----------------------------------------------------------------------------
 2323         // @Returnvalue   None
 2324         //
 2325         //----------------------------------------------------------------------------
 2326         // @Parameters    None 
 2327         //
 2328         //----------------------------------------------------------------------------
 2329         // @Date          2020-03-04
 2330         //
 2331         //****************************************************************************
 2332         
 2333         // USER CODE BEGIN (If_TxConfirmation,1)
 2334         
 2335         CAN_DIAG_STAT INT8U u0x16eMsgChecksumTimeoutCnt = 0u;
 2336         CAN_DIAG_STAT INT8U u0x16eMsgChecksumRecoverCnt = 0u;
 2337         
 2338         // USER CODE END
 2339         
 2340         BOOLEAN CanDiag_DTC_VCU_0x16eMsgChecksum(CanReceiveHandle* rcvObject)
 2341         {
 2342  1      
 2343  1        // USER CODE BEGIN (If_TxConfirmation,2)
 2344  1      
 2345  1              INT8U i;
 2346  1              INT8U uChecksumValue = 0u;
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 39  

 2347  1      
 2348  1              for (i = 0u; i < 7; i++)
 2349  1              {
 2350  2                      uChecksumValue ^= rcvObject[i]; 
 2351  2              }
 2352  1      
 2353  1              if (FALSE == t_canDtcErr.b0x16eMsgChecksumErr)
 2354  1              {
 2355  2                      if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
 2356  2                      {
 2357  3                              u0x16eMsgChecksumRecoverCnt = 0u;
 2358  3      
 2359  3                              u0x16eMsgChecksumTimeoutCnt++;
 2360  3                              if (u0x16eMsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 2361  3                              {
 2362  4                                      u0x16eMsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 2363  4                                      t_canDtcErr.b0x16eMsgChecksumErr = TRUE;
 2364  4      
 2365  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 2366  4                                      {
 2367  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x16E_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 2368  5                                      }
 2369  4                              }
 2370  3                      }
 2371  2                      else
 2372  2                      {
 2373  3                              u0x16eMsgChecksumTimeoutCnt = 0u;
 2374  3                              u0x16eMsgChecksumRecoverCnt = 0u;
 2375  3                              t_canDtcErr.b0x16eMsgChecksumErr = FALSE;
 2376  3                      }
 2377  2              }
 2378  1              else
 2379  1              {
 2380  2                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 2381  2                      {
 2382  3                              u0x16eMsgChecksumTimeoutCnt = 0u;
 2383  3      
 2384  3                              u0x16eMsgChecksumRecoverCnt++;
 2385  3                              if (u0x16eMsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
 2386  3                              {
 2387  4                                      u0x16eMsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
 2388  4                                      t_canDtcErr.b0x16eMsgChecksumErr = FALSE;
 2389  4      
 2390  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 2391  4                                      {
 2392  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x16E_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
 2393  5                                      }                               
 2394  4                              }
 2395  3                      }
 2396  2                      else
 2397  2                      {
 2398  3                              u0x16eMsgChecksumTimeoutCnt = 0u;
 2399  3                              u0x16eMsgChecksumRecoverCnt = 0u;
 2400  3                              t_canDtcErr.b0x16eMsgChecksumErr = TRUE;                        
 2401  3                      }
 2402  2              }
 2403  1      
 2404  1              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 2405  1              {
 2406  2                      return TRUE;
 2407  2              }
 2408  1              else
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 40  

 2409  1              {
 2410  2                      return FALSE;
 2411  2              }       
 2412  1      
 2413  1        // USER CODE END
 2414  1      
 2415  1      } //  End of function CanDiag_DTC_VCU_0x16eMsgChecksum
 2416         
 2417         //****************************************************************************
 2418         // @Function      void CanDiag_DTC_VCU_0x16fMsgChecksum()
 2419         //
 2420         //----------------------------------------------------------------------------
 2421         // @Description   This function check 0x16F message checksum.
 2422         //
 2423         //----------------------------------------------------------------------------
 2424         // @Returnvalue   None
 2425         //
 2426         //----------------------------------------------------------------------------
 2427         // @Parameters    None 
 2428         //
 2429         //----------------------------------------------------------------------------
 2430         // @Date          2020-03-04
 2431         //
 2432         //****************************************************************************
 2433         
 2434         // USER CODE BEGIN (If_TxConfirmation,1)
 2435         
 2436         CAN_DIAG_STAT INT8U u0x16fMsgChecksumTimeoutCnt = 0u;
 2437         CAN_DIAG_STAT INT8U u0x16fMsgChecksumRecoverCnt = 0u;
 2438         
 2439         // USER CODE END
 2440         
 2441         BOOLEAN CanDiag_DTC_VCU_0x16fMsgChecksum(CanReceiveHandle* rcvObject)
 2442         {
 2443  1      
 2444  1        // USER CODE BEGIN (If_TxConfirmation,2)
 2445  1      
 2446  1              INT8U i;
 2447  1              INT8U uChecksumValue = 0u;
 2448  1      
 2449  1              for (i = 0u; i < 7; i++)
 2450  1              {
 2451  2                      uChecksumValue ^= rcvObject[i]; 
 2452  2              }
 2453  1      
 2454  1              if (FALSE == t_canDtcErr.b0x16fMsgChecksumErr)
 2455  1              {
 2456  2                      if (uChecksumValue != (INT8U)(rcvObject[7] & 0x0F))
 2457  2                      {
 2458  3                              u0x16fMsgChecksumRecoverCnt = 0u;
 2459  3      
 2460  3                              u0x16fMsgChecksumTimeoutCnt++;
 2461  3                              if (u0x16fMsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 2462  3                              {
 2463  4                                      u0x16fMsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 2464  4                                      t_canDtcErr.b0x16fMsgChecksumErr = TRUE;
 2465  4      
 2466  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 2467  4                                      {
 2468  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x16F_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 2469  5                                      }
 2470  4                              }
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 41  

 2471  3                      }
 2472  2                      else
 2473  2                      {
 2474  3                              u0x16fMsgChecksumTimeoutCnt = 0u;
 2475  3                              u0x16fMsgChecksumRecoverCnt = 0u;
 2476  3                              t_canDtcErr.b0x16fMsgChecksumErr = FALSE;
 2477  3                      }
 2478  2              }
 2479  1              else
 2480  1              {
 2481  2                      if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 2482  2                      {
 2483  3                              u0x16fMsgChecksumTimeoutCnt = 0u;
 2484  3      
 2485  3                              u0x16fMsgChecksumRecoverCnt++;
 2486  3                              if (u0x16fMsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
 2487  3                              {
 2488  4                                      u0x16fMsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
 2489  4                                      t_canDtcErr.b0x16fMsgChecksumErr = FALSE;
 2490  4      
 2491  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 2492  4                                      {
 2493  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x16F_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
 2494  5                                      }                               
 2495  4                              }
 2496  3                      }
 2497  2                      else
 2498  2                      {
 2499  3                              u0x16fMsgChecksumTimeoutCnt = 0u;
 2500  3                              u0x16fMsgChecksumRecoverCnt = 0u;
 2501  3                              t_canDtcErr.b0x16fMsgChecksumErr = TRUE;                        
 2502  3                      }
 2503  2              }
 2504  1      
 2505  1              if (uChecksumValue == (INT8U)(rcvObject[7] & 0x0F))
 2506  1              {
 2507  2                      return TRUE;
 2508  2              }
 2509  1              else
 2510  1              {
 2511  2                      return FALSE;
 2512  2              }       
 2513  1      
 2514  1        // USER CODE END
 2515  1      
 2516  1      } //  End of function CanDiag_DTC_VCU_0x16fMsgChecksum
 2517         
 2518         //****************************************************************************
 2519         // @Function      void CanDiag_DTC_GW_0x278MsgChecksum()
 2520         //
 2521         //----------------------------------------------------------------------------
 2522         // @Description   This function check 0x278 message checksum.
 2523         //
 2524         //----------------------------------------------------------------------------
 2525         // @Returnvalue   None
 2526         //
 2527         //----------------------------------------------------------------------------
 2528         // @Parameters    None 
 2529         //
 2530         //----------------------------------------------------------------------------
 2531         // @Date          2020-03-04
 2532         //
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 42  

 2533         //****************************************************************************
 2534         
 2535         // USER CODE BEGIN (If_TxConfirmation,1)
 2536         
 2537         CAN_DIAG_STAT INT8U u0x278MsgChecksumTimeoutCnt = 0u;
 2538         CAN_DIAG_STAT INT8U u0x278MsgChecksumRecoverCnt = 0u;
 2539         
 2540         // USER CODE END
 2541         
 2542         BOOLEAN CanDiag_DTC_GW_0x278MsgChecksum(CanReceiveHandle* rcvObject)
 2543         {
 2544  1      
 2545  1        // USER CODE BEGIN (If_TxConfirmation,2)
 2546  1      
 2547  1              INT8U i;
 2548  1              INT8U uChecksumValue = 0u;
 2549  1      
 2550  1              for (i = 0u; i < 7; i++)
 2551  1              {
 2552  2                      uChecksumValue ^= rcvObject[i]; 
 2553  2              }
 2554  1      
 2555  1              if (FALSE == t_canDtcErr.b0x278MsgChecksumErr)
 2556  1              {
 2557  2                      if (uChecksumValue != (INT8U)(rcvObject[7]))
 2558  2                      {
 2559  3                              u0x278MsgChecksumRecoverCnt = 0u;
 2560  3      
 2561  3                              u0x278MsgChecksumTimeoutCnt++;
 2562  3                              if (u0x278MsgChecksumTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 2563  3                              {
 2564  4                                      u0x278MsgChecksumTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 2565  4                                      t_canDtcErr.b0x278MsgChecksumErr = TRUE;
 2566  4      
 2567  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 2568  4                                      {
 2569  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x278_CHECKSUM_ROLLING_ERR, DTC_TEST_FAILED);
 2570  5                                      }
 2571  4                              }
 2572  3                      }
 2573  2                      else
 2574  2                      {
 2575  3                              u0x278MsgChecksumTimeoutCnt = 0u;
 2576  3                              u0x278MsgChecksumRecoverCnt = 0u;
 2577  3                              t_canDtcErr.b0x278MsgChecksumErr = FALSE;
 2578  3                      }
 2579  2              }
 2580  1              else
 2581  1              {
 2582  2                      if (uChecksumValue == (INT8U)(rcvObject[7]))
 2583  2                      {
 2584  3                              u0x278MsgChecksumTimeoutCnt = 0u;
 2585  3      
 2586  3                              u0x278MsgChecksumRecoverCnt++;
 2587  3                              if (u0x278MsgChecksumRecoverCnt >= MESSAGE_RECOVER_CYCLE)
 2588  3                              {
 2589  4                                      u0x278MsgChecksumRecoverCnt = MESSAGE_RECOVER_CYCLE;
 2590  4                                      t_canDtcErr.b0x278MsgChecksumErr = FALSE;
 2591  4      
 2592  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 2593  4                                      {
 2594  5                                              DescMgr_DtcStatusDataReport(DTC_CAN_0x278_CHECKSUM_ROLLING_ERR, DTC_TEST_PASSED);
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 43  

 2595  5                                      }                               
 2596  4                              }
 2597  3                      }
 2598  2                      else
 2599  2                      {
 2600  3                              u0x278MsgChecksumTimeoutCnt = 0u;
 2601  3                              u0x278MsgChecksumRecoverCnt = 0u;
 2602  3                              t_canDtcErr.b0x278MsgChecksumErr = TRUE;                        
 2603  3                      }
 2604  2              }
 2605  1      
 2606  1              if (uChecksumValue == (INT8U)(rcvObject[7]))
 2607  1              {
 2608  2                      return TRUE;
 2609  2              }
 2610  1              else
 2611  1              {
 2612  2                      return FALSE;
 2613  2              }       
 2614  1      
 2615  1        // USER CODE END
 2616  1      
 2617  1      } //  End of function CanDiag_DTC_GW_0x278MsgChecksum
 2618         
 2619         //****************************************************************************
 2620         // @Function      void CanDiag_DTC_BusOff()
 2621         //
 2622         //----------------------------------------------------------------------------
 2623         // @Description   This function check can bus off.
 2624         //
 2625         //----------------------------------------------------------------------------
 2626         // @Returnvalue   None
 2627         //
 2628         //----------------------------------------------------------------------------
 2629         // @Parameters    None 
 2630         //
 2631         //----------------------------------------------------------------------------
 2632         // @Date          2020-03-04
 2633         //
 2634         //****************************************************************************
 2635         
 2636         // USER CODE BEGIN (If_TxConfirmation,1)
 2637         
 2638         CAN_DIAG_STAT INT8U uCanBusOffTimeoutCnt = 0u;
 2639         CAN_DIAG_STAT INT8U uCanBusOffRecoverCnt = 0u;
 2640         
 2641         // USER CODE END
 2642         
 2643         BOOLEAN CanDiag_DTC_BusOff(void)
 2644         {
 2645  1      
 2646  1        // USER CODE BEGIN (If_TxConfirmation,2)
 2647  1              
 2648  1              if (FALSE == t_canDtcErr.bCanBusOffErr)
 2649  1              {
 2650  2                      uCanBusOffRecoverCnt = 0u;
 2651  2      
 2652  2                      if (BUSOFF_SHUTDOWN_ERR == CanNm_GetBusoffStatus())
 2653  2                      {
 2654  3                              uCanBusOffTimeoutCnt++;
 2655  3                              if (uCanBusOffTimeoutCnt >= MESSAGE_TIMEOUT_CYCLE)
 2656  3                              {
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 44  

 2657  4                                      uCanBusOffTimeoutCnt = MESSAGE_TIMEOUT_CYCLE;
 2658  4                                      t_canDtcErr.bCanBusOffErr = TRUE;
 2659  4      
 2660  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 2661  4                                      {
 2662  5                                              DescMgr_DtcStatusDataReport(DTC_VEHICLE_CAN_BUS_OFF, DTC_TEST_FAILED);
 2663  5                                      }                               
 2664  4                              }
 2665  3                      }
 2666  2                      else
 2667  2                      {
 2668  3                              uCanBusOffTimeoutCnt = 0u;
 2669  3                              uCanBusOffRecoverCnt = 0u;
 2670  3                              t_canDtcErr.bCanBusOffErr = FALSE;
 2671  3                      }
 2672  2              }
 2673  1              else
 2674  1              {
 2675  2                      uCanBusOffTimeoutCnt = 0u;
 2676  2      
 2677  2                      uCanBusOffRecoverCnt++;
 2678  2                      if (BUSOFF_NORMAL == CanNm_GetBusoffStatus())
 2679  2                      {
 2680  3                              uCanBusOffRecoverCnt = MESSAGE_RECOVER_CYCLE;
 2681  3                              t_canDtcErr.bCanBusOffErr = FALSE;
 2682  3      
 2683  3                              if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 2684  3                              {
 2685  4                                      DescMgr_DtcStatusDataReport(DTC_VEHICLE_CAN_BUS_OFF, DTC_TEST_PASSED);
 2686  4                              }                       
 2687  3                              
 2688  3                      }
 2689  2                      else
 2690  2                      {
 2691  3                              uCanBusOffTimeoutCnt = 0u;
 2692  3                              uCanBusOffRecoverCnt = 0u;
 2693  3                              t_canDtcErr.bCanBusOffErr = TRUE;                       
 2694  3                      }
 2695  2              }
 2696  1      
 2697  1              return t_canDtcErr.bCanBusOffErr;
 2698  1      
 2699  1        // USER CODE END
 2700  1      
 2701  1      } //  End of function CanDiag_DTC_BusOff
 2702         
 2703         //****************************************************************************
 2704         // @Function      void CanDiag_ComVoltageAbnormalStatus()
 2705         //
 2706         //----------------------------------------------------------------------------
 2707         // @Description   This function check can communication status.
 2708         //
 2709         //----------------------------------------------------------------------------
 2710         // @Returnvalue   None
 2711         //
 2712         //----------------------------------------------------------------------------
 2713         // @Parameters    None 
 2714         //
 2715         //----------------------------------------------------------------------------
 2716         // @Date          2020-03-04
 2717         //
 2718         //****************************************************************************
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 45  

 2719         
 2720         // USER CODE BEGIN (If_TxConfirmation,1)
 2721         
 2722         CAN_DIAG_STAT INT8U uCanVoltageAbnormalTimeoutCnt = 0u;
 2723         CAN_DIAG_STAT INT8U uCanVoltageAbnormalRecoverCnt = 0u;
 2724         
 2725         // USER CODE END
 2726         
 2727         BOOLEAN CanDiag_ComVoltageAbnormalStatus(void)
 2728         {
 2729  1      
 2730  1        // USER CODE BEGIN (If_TxConfirmation,2)
 2731  1        
 2732  1              if (FALSE == t_canDtcErr.bCanVoltageErr)
 2733  1              {
 2734  2                      uCanVoltageAbnormalRecoverCnt = 0u;
 2735  2      
 2736  2                      if (uCanVoltageValue > 0u)
 2737  2                      {
 2738  3                              if ((uCanVoltageValue < CAN_VOLT_FALLING_LOW_THREHOLD) || (uCanVoltageValue > CAN_VOLT_RISING_HIGH_THRE
             -HOLD))
 2739  3                              {
 2740  4                                      uCanVoltageAbnormalTimeoutCnt++;
 2741  4                                      if (uCanVoltageAbnormalTimeoutCnt >= DIAG_ERR_TIMEOUT_CYCLE)
 2742  4                                      {
 2743  5                                              uCanVoltageAbnormalTimeoutCnt = DIAG_ERR_TIMEOUT_CYCLE;
 2744  5                                              t_canDtcErr.bCanVoltageErr = TRUE;
 2745  5      
 2746  5                                              Can_DisableControllerInterrupts(CAN_CONTROLLER0);
 2747  5                                              Can_DisableControllerInterrupts(CAN_CONTROLLER1);
 2748  5      
 2749  5                                              Can_SetControllerMode(CAN_CONTROLLER0, CAN_T_STOP);
 2750  5                                              Can_SetControllerMode(CAN_CONTROLLER1, CAN_T_STOP);
 2751  5                                      }
 2752  4                              }
 2753  3                              else
 2754  3                              {
 2755  4                                      uCanVoltageAbnormalTimeoutCnt = 0u;
 2756  4                                      uCanVoltageAbnormalRecoverCnt = 0u;     
 2757  4                                      t_canDtcErr.bCanVoltageErr = FALSE;             
 2758  4                              }               
 2759  3                      }
 2760  2              }
 2761  1              else
 2762  1              {
 2763  2                      uCanVoltageAbnormalTimeoutCnt = 0u;
 2764  2      
 2765  2                      if (uCanVoltageValue > 0u)
 2766  2                      {
 2767  3                              if ((uCanVoltageValue > CAN_VOLT_FALLING_HIGH_THREHOLD) && (uCanVoltageValue < CAN_VOLT_RISING_LOW_THRE
             -HOLD))
 2768  3                              {
 2769  4                                      uCanVoltageAbnormalRecoverCnt++;
 2770  4                                      if (uCanVoltageAbnormalRecoverCnt >= DIAG_ERR_RECOVER_CYCLE)
 2771  4                                      {
 2772  5                                              uCanVoltageAbnormalRecoverCnt = DIAG_ERR_RECOVER_CYCLE;
 2773  5                                              t_canDtcErr.bCanVoltageErr = FALSE;
 2774  5                              
 2775  5                                              Can_SetControllerMode(CAN_CONTROLLER0, CAN_T_START);
 2776  5                                              Can_SetControllerMode(CAN_CONTROLLER1, CAN_T_START);                                    
 2777  5                              
 2778  5                                              Can_EnableControllerInterrupts(CAN_CONTROLLER0);
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 46  

 2779  5                                              Can_EnableControllerInterrupts(CAN_CONTROLLER1);                        
 2780  5                                      }
 2781  4                              }
 2782  3                              else
 2783  3                              {
 2784  4                                      uCanVoltageAbnormalTimeoutCnt = 0u;
 2785  4                                      uCanVoltageAbnormalRecoverCnt = 0u; 
 2786  4                                      t_canDtcErr.bCanVoltageErr = TRUE;                              
 2787  4                              }
 2788  3                      }
 2789  2              }
 2790  1      
 2791  1        return t_canDtcErr.bCanVoltageErr;
 2792  1      
 2793  1        // USER CODE END
 2794  1      
 2795  1      } //  End of function CanDiag_ComVoltageAbnormalStatus
 2796         
 2797         //****************************************************************************
 2798         // @Function      void CanDiag_ComCircuitAbnormalStatus()
 2799         //
 2800         //----------------------------------------------------------------------------
 2801         // @Description   This function check can communication status.
 2802         //
 2803         //----------------------------------------------------------------------------
 2804         // @Returnvalue   None
 2805         //
 2806         //----------------------------------------------------------------------------
 2807         // @Parameters    None 
 2808         //
 2809         //----------------------------------------------------------------------------
 2810         // @Date          2020-03-04
 2811         //
 2812         //****************************************************************************
 2813         
 2814         // USER CODE BEGIN (If_TxConfirmation,1)
 2815         
 2816         CAN_DIAG_STAT BOOLEAN bCan0GetErrorIncrement = 0u;
 2817         CAN_DIAG_STAT BOOLEAN bCan0GetErrorTransferDirection = 0u;
 2818         
 2819         CAN_DIAG_STAT INT8U uCanCircuitAbnormalTimeoutCnt = 0u;
 2820         CAN_DIAG_STAT INT8U uCanCircuitAbnormalRecoverCnt = 0u;
 2821         
 2822         // USER CODE END
 2823         
 2824         BOOLEAN  CanDiag_ComCircuitAbnormalStatus(void)
 2825         {
 2826  1      
 2827  1        // USER CODE BEGIN (If_TxConfirmation,2)
 2828  1      
 2829  1              bCan0GetErrorIncrement = CAN_ubGetErrorIncrement(CAN_CONTROLLER0);
 2830  1              bCan0GetErrorTransferDirection = CAN_ubGetErrorTransferDirection(CAN_CONTROLLER0);
 2831  1      
 2832  1              if (FALSE == t_canDtcErr.bCanCircuitErr)
 2833  1              {
 2834  2                      uCanCircuitAbnormalRecoverCnt = 0u;
 2835  2      
 2836  2                      if ((FALSE == bCan0GetErrorTransferDirection) && (FALSE == bCan0GetErrorIncrement))
 2837  2                      {
 2838  3                              uCanCircuitAbnormalTimeoutCnt++;
 2839  3                              if (uCanCircuitAbnormalTimeoutCnt >= DIAG_ERR_TIMEOUT_CYCLE)
 2840  3                              {
C166 COMPILER V7.57.0, CAN_DIAG                                                            11/13/2020 15:09:30 PAGE 47  

 2841  4                                      uCanCircuitAbnormalTimeoutCnt = DIAG_ERR_TIMEOUT_CYCLE;
 2842  4                                      t_canDtcErr.bCanCircuitErr = TRUE;
 2843  4      
 2844  4                                      Can_DisableControllerInterrupts(CAN_CONTROLLER0);
 2845  4                                      Can_SetControllerMode(CAN_CONTROLLER0, CAN_T_STOP);
 2846  4                              }
 2847  3                      }
 2848  2                      else
 2849  2                      {
 2850  3                              uCanCircuitAbnormalTimeoutCnt = 0u;
 2851  3                              uCanCircuitAbnormalRecoverCnt = 0u;     
 2852  3                              t_canDtcErr.bCanCircuitErr = FALSE;             
 2853  3                      }
 2854  2              }
 2855  1              else
 2856  1              {
 2857  2                      uCanCircuitAbnormalTimeoutCnt = 0u;
 2858  2      
 2859  2                      uCanCircuitAbnormalRecoverCnt++;
 2860  2                      if (uCanCircuitAbnormalRecoverCnt >= DIAG_ERR_RECOVER_CYCLE)
 2861  2                      {
 2862  3                              uCanCircuitAbnormalRecoverCnt = DIAG_ERR_RECOVER_CYCLE;
 2863  3                              t_canDtcErr.bCanCircuitErr = FALSE;
 2864  3      
 2865  3                              Can_SetControllerMode(CAN_CONTROLLER0, CAN_T_START);                                    
 2866  3                              Can_EnableControllerInterrupts(CAN_CONTROLLER0);                        
 2867  3                      }
 2868  2              }
 2869  1              
 2870  1        return t_canDtcErr.bCanCircuitErr;    
 2871  1      
 2872  1        // USER CODE END
 2873  1      
 2874  1      } //  End of function CanDiag_ComCircuitAbnormalStatus
 2875         
 2876         


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        6220     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          87     --------
  FAR-DATA SIZE    =          36     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =         552     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
