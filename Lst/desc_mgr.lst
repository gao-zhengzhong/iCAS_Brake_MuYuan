C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 1   


C166 COMPILER V7.57.0, COMPILATION OF MODULE DESC_MGR
OBJECT MODULE PLACED IN .\Obj\desc_mgr.obj
COMPILER INVOKED BY: C:\Keil_v5\C166\BIN\C166.EXE src\bsw\desc\desc_mgr.c MODV2 LARGE BROWSE INCDIR(.\src;.\src\bsw;.\sr
                    -c\driver;.\src\interaction;.\src\app\adc;.\src\app\alogrithm;.\src\app\can;.\src\app\ccp;.\src\app\diagnostic;.\src\app\
                    -mode control;.\src\app\task;.\src\app\Fun;.\src\app\rtos;.\src\bsw\can;.\src\bsw\desc;.\src\bsw\nm;.\src\app\time measur
                    -e;.\src\app\rte) MODV2 DEBUG PRINT(.\Lst\desc_mgr.lst) OBJECT(.\Obj\desc_mgr.obj) 

 stmt lvl     source

    1         /***********************************************************************
    2         *   Copyright (C) JWD Automotive Co., Ltd.                                             * 
    3         *       All Rights Reserved.                                                                   *
    4         *   Department : iCAS SW                                                                               *
    5         *   AUTHOR         :                                                                                               *
    6         ************************************************************************
    7         * Object        : 
    8         * Module        : DescDtcMgr.c
    9         * Instance      : 
   10         * Description   : UDS
   11         *-----------------------------------------------------------------------
   12         * Version: v0.1
   13         * Date   : Dec 27,2019 
   14         * Author : Gao zehngzhong
   15         ***********************************************************************/
   16         /*-History--------------------------------------------------------------
   17         * Version    Date           Name            Changes and comments
   18         ------------------------------------------------------------------------
   19         * 0.1        Dec 27,2019    Gao Zhengzhong  Initial version
   20         *=====================================================================*/
   21         
   22         #define DESC_MGR_GLOBALS
   23         
   24         #include <string.h>
   25         
   26         #include "desc_mgr.h"
   27         #include "desc_ser.h"
   28         #include "EEPROM_Cfg.h"
   29         #include "adc_sample.h"
   30         #include "eepRom.h"
   31         
   32         /**** Definition of variables ****/
   33         DESC_MGR_STAT INT16U can_diag_init_delay_timer = 0u;
   34         DESC_MGR_STAT INT16U can_diag_ign_delay_timer = 0u;
   35         DESC_MGR_STAT INT16U can_diag_init_nm_delay_timer = 0u;
   36         DESC_MGR_STAT INT16U can_diag_bat_volt_recover_delay_timer = 0u;
   37         
   38         DESC_MGR_STAT BOOLEAN dtc_control_setting_on_off = TRUE;
   39         DESC_MGR_STAT BOOLEAN bDtcDataNeedSendToEep = FALSE;
   40         DESC_MGR_STAT DTC_INIT_STEP_TYPE dtc_eeprom_init_step = DTC_INIT_STEP_START;
   41         DESC_MGR_STAT INT8U dtc_status_svc14_clear_counter = DTC_STATUS_SVC14_CLEAR_FINISHED;
   42         
   43         DESC_MGR_STAT INT8U dtc_occurance_count[DTC_CODE_MAX_NUM] = {0u};
   44         DESC_MGR_STAT INT8U dtc_aging_count[DTC_CODE_MAX_NUM] = {0u};
   45         DESC_MGR_STAT INT8U dtc_pending_count[DTC_CODE_MAX_NUM] = {0u}; 
   46         DESC_MGR_STAT INT8U dtc_aged_count[DTC_CODE_MAX_NUM] = {0u};
   47         
   48         DESC_MGR_STAT INT8U dtc_record_enable_mask = DTC_RECORD_ENABLE_NONE;
   49         DESC_MGR_STAT INT32U delta_trip_count = 0x00000000;
   50         
   51         DESC_MGR_STAT BOOLEAN bSetClearHistoryFaultCntFlag[DTC_CODE_MAX_NUM] = {FALSE}; 
   52         DESC_MGR_STAT BOOLEAN bSetClearHistoryPendingCntFlag[DTC_CODE_MAX_NUM] = {FALSE}; 
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 2   

   53         DESC_MGR_STAT BOOLEAN bSetIncreaseHistoryPendingCntFlag[DTC_CODE_MAX_NUM] = {FALSE}; 
   54         
   55         /* DTC status mask statusOfDTC */
   56         DESC_MGR_STAT DTC_RECORD_TYPE dtc_current_status_record[DTC_CODE_MAX_NUM] = {0x00};
   57         
   58         /* DTC create count Fault occurrence counter */
   59         DESC_MGR_STAT DTC_RECORD_CNT_TYPE dtc_create_record_cnt[DTC_CODE_MAX_NUM] = {0u};
   60         
   61         /* DTC create and recover time count */
   62         DESC_MGR_STAT DTC_RECORD_TIME_CNT_TYPE dtc_status_time_record_cnt[DTC_CODE_MAX_NUM] = {0u}; 
   63         
   64         /* DTC snapshot data */
   65         DESC_MGR_STAT DTC_SNAPSHOT_DATA_RECORD dtc_snapshot_data_record[DTC_CODE_MAX_NUM] = {0u};
   66         
   67         /* DTC Number */
   68         DTC_CODE_DATA_TYPE dtc_code_data[DTC_CODE_MAX_NUM] = 
   69         {
   70             {0xC0, 0x73, 0x00}, /* can bus off */
   71             {0x90, 0x00, 0x16}, /* power voltage low */
   72             {0x90, 0x00, 0x17}, /* power voltage high */ 
   73         
   74                 {0xD0, 0x02, 0x87}, /* 0x118 message lost */
   75                 {0xD2, 0x01, 0x87}, /* 0x119 message lost */
   76                 {0xD4, 0x00, 0x87}, /* 0x126 meaasge lost */
   77                 {0xD4, 0x02, 0x87}, /* 0x130 message lost */
   78                 {0xD4, 0x03, 0x87}, /* 0x132 message lost */
   79                 {0xD4, 0x04, 0x87}, /* 0x140 message lost */
   80                 {0xD4, 0x0A, 0x87}, /* 0x148 message lost */
   81                 {0xD4, 0x0B, 0x87}, /* 0x155 message lost */
   82                 {0xD6, 0x00, 0x87}, /* 0x16E message lost */
   83                 {0xE0, 0x03, 0x87}, /* 0x16F message lost */
   84                 {0xE0, 0x04, 0x87}, /* 0x278 message lost */
   85         
   86                 {0xD0, 0x02, 0x83}, /* 0x118 message checksum or rolling count error */
   87                 {0xD2, 0x01, 0x83}, /* 0x119 message checksum or rolling count error */
   88                 {0xD4, 0x00, 0x83}, /* 0x126 meaasge checksum or rolling count error */
   89                 {0xD4, 0x02, 0x83}, /* 0x130 message checksum or rolling count error */
   90                 {0xD4, 0x03, 0x83}, /* 0x132 message checksum or rolling count error */
   91                 {0xD4, 0x04, 0x83}, /* 0x140 message checksum or rolling count error */
   92                 {0xD4, 0x0A, 0x83}, /* 0x148 message checksum or rolling count error */
   93                 {0xD4, 0x0B, 0x83}, /* 0x155 message checksum or rolling count error */
   94                 {0xD6, 0x00, 0x83}, /* 0x16E message checksum or rolling count error */
   95                 {0xE0, 0x03, 0x83}, /* 0x16F message checksum or rolling count error */
   96                 {0xE0, 0x04, 0x83}, /* 0x278 message checksum or rolling count error */ 
   97                 
   98                 {0x60, 0x04, 0x83}, /* Test error */
   99         };
  100         
  101         /**** Declaration of functions ****/
  102         DESC_MGR_STAT void DescMgr_ReadDtcFromEEP(void);
  103         DESC_MGR_STAT void DescMgr_WriteAllDtcToEEP(void);
  104         DESC_MGR_STAT void DescMgr_WriteExtendDataToEEP(INT8U dtc_code);
  105         DESC_MGR_STAT void DescMgr_WriteSnapshotDataToEEP(INT8U dtc_code);
  106         DESC_MGR_STAT void DescMgr_ExtendDataReport(INT8U dtc_code);
  107         DESC_MGR_STAT void DescMgr_SnapshotDataReport(INT8U dtc_code);
  108         DESC_MGR_STAT void DescMgr_CanDigDtcRecordEnableAdjust(void);
  109         DESC_MGR_STAT void DescMgr_InitDtcCreateRecoverCounterAndStatus(void);
  110         DESC_MGR_STAT void DescMgr_SetDeltaTripCounter(INT8U dtc_code, BOOLEAN delta_Trip_flag);
  111         DESC_MGR_STAT void DescMgr_ReturnSnapshotData(INT8U *res_data, DTC_CODE_NUM_TYPE dtc_number);
  112         DESC_MGR_STAT void DescMgr_ReturnSnapshotDataDefault(INT8U *res_data, DTC_CODE_NUM_TYPE dtc_number);
  113         DESC_MGR_STAT void DescMgr_ReturnExtendData(INT8U *res_data, DTC_CODE_NUM_TYPE dtc_number, INT8U RecordNum
             -);
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 3   

  114         DESC_MGR_STAT void DescMgr_ReturnExtendDataDefault(INT8U *res_data, DTC_CODE_NUM_TYPE dtc_number, INT8U Re
             -cordNum);
  115         
  116         DESC_MGR_STAT BOOLEAN DescMgr_CanDiagDtcStatusServiceClearAll(void);
  117         DESC_MGR_STAT BOOLEAN DescMgr_CanDiagDtcStatusServiceClearFinished(void);
  118         
  119         #define DELAY_1s 10
  120         #define POWER_9V_VOLTAGE 9000
  121         #define POWER_9_5V_VOLTAGE 9500
  122         
  123         
  124         /***********************************************************************
  125         * FUNCTION    : CanDescDtc_vInit
  126         * DESCRIPTION : 
  127         * INPUTS      : none
  128         * RETURN      : none
  129         ***********************************************************************/
  130         void CanDescDtc_vInit(void)
  131         {
  132  1              /* control dtc setting to on in default */
  133  1          dtc_control_setting_on_off = TRUE; 
  134  1          dtc_eeprom_init_step = DTC_INIT_STEP_START;
  135  1          dtc_status_svc14_clear_counter = DTC_STATUS_SVC14_CLEAR_FINISHED;
  136  1      
  137  1          bDtcDataNeedSendToEep = FALSE;
  138  1          
  139  1          can_diag_init_delay_timer = CAN_DIAG_INIT_DELAY_TIME;
  140  1          
  141  1          can_diag_init_nm_delay_timer = CAN_DIAG_NM_INIT_DELAY_TIME;
  142  1          can_diag_ign_delay_timer = CAN_DIAG_NM_IGN_ON_DELAY_TIME;
  143  1          can_diag_bat_volt_recover_delay_timer = CAN_DIAG_BAT_VOLT_RECOVER_DELAY_TIMEOUT;    
  144  1      
  145  1          /* init to disable all dtc record */
  146  1          dtc_record_enable_mask = DTC_RECORD_ENABLE_NONE;
  147  1      
  148  1          /* Adjust dtc record enable mask */
  149  1              
  150  1      #ifdef DTC_AGING_COUNTER
  151  1              memset(bSetClearHistoryFaultCntFlag, TRUE, DTC_CODE_MAX_NUM);
  152  1      #endif
  153  1      
  154  1          //EEP_Read_Status_Before_S3_Monitor();
  155  1      }
  156         
  157         /***********************************************************************
  158         * FUNCTION    : DescMgr_CanDiagDtcDeInit
  159         * DESCRIPTION : 
  160         * INPUTS      : none
  161         * RETURN      : none
  162         ***********************************************************************/
  163         void DescMgr_CanDiagDtcDeInit(void)
  164         {
  165  1              return;
  166  1      }
  167         
  168         /***********************************************************************
  169         * FUNCTION    : can_diag_dtc_eeprom_handle
  170         * DESCRIPTION : Initialize all the dtc eeprom data at one time will lead to other can function delay,
  171         * such as nm or app cycle msg transmition. So we separate the init action of dtc eeprom.
  172         * INPUTS      : none
  173         * RETURN      : none
  174         ***********************************************************************/
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 4   

  175         DESC_MGR_STAT void DescMgr_CanDiagDtcEepromHandle(void)
  176         {
  177  1              DESC_MGR_STAT INT8U write_delay = 0u;
  178  1      
  179  1              switch (dtc_eeprom_init_step)
  180  1              {
  181  2                      case DTC_INIT_STEP_START:
  182  2                              dtc_eeprom_init_step = DTC_INIT_STEP_READ_DTC_ST;
  183  2                              break;
  184  2                              
  185  2                      case DTC_INIT_STEP_READ_DTC_ST:
  186  2                              DescMgr_ReadDtcFromEEP();
  187  2                              dtc_eeprom_init_step = DTC_INIT_STEP_CALCULATE_DTC_ST;
  188  2                              break;
  189  2                              
  190  2                      case DTC_INIT_STEP_CALCULATE_DTC_ST:
  191  2                              DescMgr_InitDtcCreateRecoverCounterAndStatus();
  192  2                              dtc_eeprom_init_step = DTC_INIT_STEP_WRITE_EEPROM_ST;
  193  2                              break;
  194  2                              
  195  2                      case DTC_INIT_STEP_WRITE_EEPROM_ST:
  196  2                  dtc_eeprom_init_step = DTC_INIT_STEP_FINISHED;
  197  2                  dtc_record_enable_mask |= DTC_RECORD_ENALBE_BDY; /* enable body diag */                     
  198  2                              break;
  199  2      
  200  2                      case DTC_INIT_STEP_FINISHED:
  201  2                              if (TRUE == bDtcDataNeedSendToEep)
  202  2                              {
  203  3                                      write_delay++;
  204  3                                      if (write_delay >= EEP_WRITE_FRE) /* write eep frequence 1s once */
  205  3                                      {
  206  4                                              write_delay = 0u;
  207  4                                              bDtcDataNeedSendToEep = FALSE; // EED_nDTCRecord;
  208  4      
  209  4                                              DescMgr_WriteAllDtcToEEP();
  210  4                                      }             
  211  3                              }                       
  212  2                              break;
  213  2      
  214  2                      default:
  215  2                              break;
  216  2              }
  217  1      }
  218         
  219         /***********************************************************************
  220         * FUNCTION    : DescMgr_ReadDtcFromEEP
  221         * DESCRIPTION : None
  222         * INPUTS      : None
  223         * RETURN      : None
  224         ***********************************************************************/
  225         DESC_MGR_STAT void DescMgr_ReadDtcFromEEP(void)
  226         {
  227  1              INT8U i;
  228  1      
  229  1              for (i=0; i<DTC_CODE_MAX_NUM; i++)
  230  1              {
  231  2                      ReadString_v_g((INT8U *)&dtc_current_status_record[i], DTC_EEPROM_STATUS_BYTE_START_ADDRESS+(i * 16u), s
             -izeof(dtc_current_status_record[i]));
  232  2                      ReadString_v_g((INT8U *)&dtc_snapshot_data_record[i], DTC_EEPROM_SNAPSHOT_DATA_START_ADDRESS+(i * 16u), 
             -sizeof(dtc_snapshot_data_record[i]));
  233  2      
  234  2      #if 0
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 5   

                              dtc_current_status_record[i].dtc_status.status_byte
                              dtc_occurance_count[i] = EED_CAN_OCCR_CNT_0[i];
                              dtc_pending_count[i] = EED_CAN_PNDING_CNT_0[i];
                              dtc_aging_count[i] = EED_CAN_AGING_CNT_0[i];
                              dtc_aged_count[i] = EED_CAN_AGED_CNT_0[i];      
              #endif
  241  2              }
  242  1      }
  243         
  244         /***********************************************************************
  245         * FUNCTION    : DescMgr_WriteAllDtcToEEP
  246         * DESCRIPTION : None
  247         * INPUTS      : None
  248         * RETURN      : None
  249         ***********************************************************************/
  250         DESC_MGR_STAT void DescMgr_WriteAllDtcToEEP(void)
  251         {
  252  1              INT8U i;        
  253  1      
  254  1              for (i=0; i<DTC_CODE_MAX_NUM; i++)
  255  1              {
  256  2                      CopyString_v_g(&dtc_current_status_record[i], DTC_EEPROM_STATUS_BYTE_START_ADDRESS + (i * 16u), sizeof(d
             -tc_current_status_record[i]), 1);
  257  2                      CopyString_v_g(&dtc_snapshot_data_record[i], DTC_EEPROM_SNAPSHOT_DATA_START_ADDRESS + (i * 16u), sizeof(
             -dtc_snapshot_data_record[i]), 1);             
  258  2      
  259  2                      // TODO:Write extend data to EEPROM
  260  2              }       
  261  1      }
  262         
  263         /***********************************************************************
  264         * FUNCTION    : DescMgr_WriteExtendDataToEEP
  265         * DESCRIPTION : None
  266         * INPUTS      : None
  267         * RETURN      : None
  268         ***********************************************************************/
  269         DESC_MGR_STAT void DescMgr_WriteExtendDataToEEP(INT8U dtc_code)
  270         {
  271  1              // TODO:Write extend data to EEPROM
  272  1      }
*** WARNING C47 IN LINE 269 OF src\bsw\desc\desc_mgr.c: 'dtc_code': unreferenced parameter
  273         
  274         /***********************************************************************
  275         * FUNCTION    : DescMgr_WriteSnapshotDataToEEP
  276         * DESCRIPTION : None
  277         * INPUTS      : INT8U dtc_code
  278         * RETURN      : None
  279         ***********************************************************************/
  280         DESC_MGR_STAT void DescMgr_WriteSnapshotDataToEEP(INT8U dtc_code)
  281         {
  282  1              INT16U snapshotDataLength = 0;
  283  1              INT32U snapshotDataAddress = 0;
  284  1              
  285  1              snapshotDataLength = sizeof(DTC_SNAPSHOT_DATA_RECORD) + 2;
  286  1              snapshotDataAddress = DTC_EEPROM_SNAPSHOT_DATA_START_ADDRESS + (dtc_code * snapshotDataLength);
  287  1              CopyString_v_g(&dtc_snapshot_data_record[dtc_code], snapshotDataAddress, snapshotDataLength, 1);
  288  1      }
  289         
  290         /***********************************************************************
  291         * FUNCTION    : Init_DTC_Creat_Recover_Counter_And_Status
  292         * DESCRIPTION : 
  293         * INPUTS      : none
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 6   

  294         * RETURN      : none
  295         ***********************************************************************/
  296         DESC_MGR_STAT void DescMgr_InitDtcCreateRecoverCounterAndStatus(void)
  297         {
  298  1          INT8U i = 0u;
  299  1      
  300  1          for (i=0u; i<DTC_CODE_MAX_NUM; i++)
  301  1          {
  302  2              dtc_status_time_record_cnt[i].dtc_create_time_cnt = 0u;
  303  2              dtc_status_time_record_cnt[i].dtc_recover_time_cnt = 0u;
  304  2      
  305  2              DescMgr_DtcStatusDataReport(i, (DTC_TEST_INIT | DTC_TEST_NEW_OPR));
  306  2          }   
  307  1      }
  308         
  309         /***********************************************************************
  310         * FUNCTION    : DescMgr_DtcStatusDataReport
  311         * DESCRIPTION : None
  312         * INPUTS      : None
  313         * RETURN      : None
  314         ***********************************************************************/
  315         void DescMgr_DtcStatusDataReport(INT8U dtc_code, INT8U dtc_test_type)
  316         {
  317  1              BOOLEAN dtc_status_changed = FALSE; 
  318  1                      
  319  1              if ((dtc_code < DTC_CODE_MAX_NUM) && ((TRUE == DescMgr_CanDiagDtcControlSettingCheck()) || (DTC_TEST_CLEA
             -R == dtc_test_type)))
  320  1              {
  321  2      #if defined (DESC_ENABLE_DTC_STATUS_BIT0)               
  322  2                      /* DTC Status Bit0: Test Fail */
  323  2                      if (TRUE == DescMgr_ProcTestFailed(dtc_code, dtc_test_type))
  324  2                      {
  325  3                              dtc_status_changed = TRUE;
  326  3                      }
  327  2      #endif
  328  2      
  329  2      #if defined (DESC_ENABLE_DTC_STATUS_BIT1)       
  330  2                      /* DTC Status Bit1: Test Fail This Operation Cycle */
  331  2                      if (TRUE == DescMgr_ProcTestFailedThisOperationCycle(dtc_code, dtc_test_type))
  332  2                      {
  333  3                              dtc_status_changed = TRUE;
  334  3                      }
  335  2      #endif
  336  2      
  337  2      #if defined (DESC_ENABLE_DTC_STATUS_BIT2)       
  338  2                      /* DTC Status Bit2: Not Confirmed DTC */
  339  2                      if (TRUE == DescMgr_ProcPendingDTC(dtc_code, dtc_test_type))
  340  2                      {
  341  3                              dtc_status_changed = TRUE;
  342  3                      }
  343  2      #endif
  344  2      
  345  2      #if defined (DESC_ENABLE_DTC_STATUS_BIT3)       
  346  2                      /* DTC Status Bit3: Confirmed DTC */
  347  2                      if (TRUE == DescMgr_ProcConfirmedDTC(dtc_code, dtc_test_type))
  348  2                      {
  349  3                              dtc_status_changed = TRUE;
  350  3                              bDtcDataNeedSendToEep = TRUE;
  351  3                      }
  352  2      #endif
  353  2      
  354  2      #if defined (DESC_ENABLE_DTC_STATUS_BIT4)       
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 7   

                              /* DTC Status Bit4: Test Not Completed Since Last Clear */
                              if (TRUE == DescMgr_ProcTestNotCompletedSinceLastClear(dtc_code, dtc_test_type))
                              {
                                      dtc_status_changed = TRUE;
                              }
              #endif
  361  2      
  362  2      #if defined (DESC_ENABLE_DTC_STATUS_BIT5)       
                              /* DTC Status Bit5: Test Fail Since Last Clear */
                              if (TRUE == DescMgr_ProcTestFailedSinceLastClear(dtc_code, dtc_test_type))
                              {
                                      dtc_status_changed = TRUE;
                              }               
              #endif
  369  2      
  370  2      #if defined (DESC_ENABLE_DTC_STATUS_BIT6)       
  371  2                      /* DTC Status Bit6: Test Not Completed This Operation Cycle */
  372  2                      if (TRUE == DescMgr_ProcTestNotCompletedThisOperationCycle(dtc_code, dtc_test_type))
  373  2                      {
  374  3                              dtc_status_changed = TRUE;
  375  3                      }
  376  2      #endif
  377  2      
  378  2      #if defined (DESC_ENABLE_DTC_STATUS_BIT7)       
                              /* DTC Status Bit7: Warning Indicator Requested */
                              if (TRUE == DescMgr_ProcWarningIndicatorRequested(dtc_code, dtc_test_type))
                              {
                                      dtc_status_changed = TRUE;
                              }
              #endif
  385  2              }
  386  1      }
  387         
  388         /***********************************************************************
  389         * FUNCTION    : DescMgr_ProcTestFailed
  390         * DESCRIPTION : None
  391         * INPUTS      : INT8U dtc_code, INT8U dtc_test_type
  392         * RETURN      : None
  393         ***********************************************************************/
  394         BOOLEAN DescMgr_ProcTestFailed(INT8U dtc_code, INT8U dtc_test_type)
  395         {
  396  1              BOOLEAN dtc_status_changed = FALSE;
  397  1      
  398  1              if (dtc_code < DTC_CODE_MAX_NUM)
  399  1              {
  400  2                      /* DTC Status Bit0 Supported Check */
  401  2                      if (0 != (DTC_STATUS_BIT0_MASK_TF & DTC_STATUS_AVAILABILITY_MASK)) 
  402  2                      {
  403  3                              /* Check test initial */
  404  3                              if (0 != (dtc_test_type & DTC_TEST_INIT))
  405  3                              {
  406  4                                      if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailed)
  407  4                                      {
  408  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailed = FALSE;
  409  5                                              dtc_status_changed = TRUE;                                              
  410  5                                      }                       
  411  4                              }
  412  3      
  413  3                              /* Check test passed */
  414  3                              if (0 != (dtc_test_type & DTC_TEST_PASSED))
  415  3                              {
  416  4                                      if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailed)
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 8   

  417  4                                      {
  418  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailed = FALSE;
  419  5                                              dtc_status_changed = TRUE;                                              
  420  5                                      }
  421  4                              }
  422  3      
  423  3                              /* Check test failed */
  424  3                              if (0 != (dtc_test_type & DTC_TEST_FAILED))
  425  3                              {
  426  4                                      if (FALSE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailed)
  427  4                                      {
  428  5                                              dtc_create_record_cnt[dtc_code].dtc_create_cnt++;       /*error count add*/
  429  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailed = TRUE;
  430  5      
  431  5                                              DescMgr_SnapshotDataReport(dtc_code);
  432  5                                              DescMgr_WriteSnapshotDataToEEP(dtc_code);
  433  5      
  434  5                                              DescMgr_ExtendDataReport(dtc_code);
  435  5                                              DescMgr_WriteExtendDataToEEP(dtc_code);
  436  5      
  437  5                                              dtc_status_changed = TRUE;
  438  5      #if defined (DTC_AGING_COUNTER)
  439  5                                              if (dtc_occurance_count[dtc_code] != 255u)
  440  5                                              {
  441  6                                                      dtc_occurance_count[dtc_code]++;
  442  6                                              }
  443  5      
  444  5                                              if (DTC_STATUS_AGING_CNT_RESET != dtc_aging_count[dtc_code])
  445  5                                              {
  446  6                                                      dtc_aging_count[dtc_code] = DTC_STATUS_AGING_CNT_RESET;
  447  6                                                      bDtcDataNeedSendToEep = TRUE;
  448  6                                                      
  449  6                                                      dtc_status_changed = TRUE;
  450  6                                              }
  451  5      #endif
  452  5                                      }
  453  4                              }
  454  3      
  455  3                              /* Check test clear */
  456  3                              if (0 != (dtc_test_type & DTC_TEST_CLEAR))
  457  3                              {
  458  4                                      /* Clear all counter */
  459  4                                      dtc_status_time_record_cnt[dtc_code].dtc_create_time_cnt = 0u;
  460  4                                      dtc_status_time_record_cnt[dtc_code].dtc_recover_time_cnt = 0u;
  461  4                                      dtc_create_record_cnt[dtc_code].dtc_create_cnt = 0u;
  462  4      
  463  4                                      if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailed)
  464  4                                      {
  465  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailed = FALSE;
  466  5                                              dtc_status_changed = TRUE;                                              
  467  5                                      }
  468  4                              }
  469  3      
  470  3                              /* Check test new operation */
  471  3                              if (0u != (dtc_test_type & DTC_TEST_NEW_OPR))
  472  3                              {
  473  4                                      /* Nothing to do. */
  474  4                              }
  475  3                              
  476  3                      }
  477  2                      else
  478  2                      {
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 9   

  479  3                              /* DTC Status Bit not supported, set to a default value if needed. 
  480  3                               * Please adapter the default value according to SPEC. */
  481  3                              if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailed)
  482  3                              {
  483  4                                      dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailed = FALSE;
  484  4                                      dtc_status_changed = TRUE;
  485  4                              }
  486  3                      }
  487  2              }
  488  1      
  489  1              return dtc_status_changed;
  490  1      }
  491         
  492         /***********************************************************************
  493         * FUNCTION    : DescMgr_ProcTestFailedThisOperationCycle
  494         * DESCRIPTION : None
  495         * INPUTS      : INT8U dtc_code, INT8U dtc_test_type
  496         * RETURN      : None
  497         ***********************************************************************/
  498         BOOLEAN DescMgr_ProcTestFailedThisOperationCycle(INT8U dtc_code, INT8U dtc_test_type)
  499         {
  500  1              BOOLEAN dtc_status_changed = FALSE;
  501  1      
  502  1              if (dtc_code < DTC_CODE_MAX_NUM)
  503  1              {
  504  2                      /* DTC Status Bit1 suppored check */
  505  2                      if (0u != (DTC_STATUS_BIT1_MASK_TFTOC & DTC_STATUS_AVAILABILITY_MASK))
  506  2                      {
  507  3                              /* Check test initial */
  508  3                              if (0 != (dtc_test_type & DTC_TEST_INIT))
  509  3                              {
  510  4                                      /* Nothing to do. */                    
  511  4                              }
  512  3      
  513  3                              /* Check test passed */
  514  3                              if (0 != (dtc_test_type & DTC_TEST_PASSED))
  515  3                              {
  516  4                                      /* Nothing to do. */
  517  4                              }
  518  3      
  519  3                              /* Check test failed */
  520  3                              if (0 != (dtc_test_type & DTC_TEST_FAILED))
  521  3                              {
  522  4                                      if (FALSE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedThisOperationCycle)
  523  4                                      {
  524  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedThisOperationCycle = TRUE;
  525  5                                              dtc_status_changed = TRUE;
  526  5                                      }
  527  4                              }
  528  3      
  529  3                              /* Check test clear */
  530  3                              if (0 != (dtc_test_type & DTC_TEST_CLEAR))
  531  3                              {
  532  4                                      /* Clear all counter */
  533  4                                      dtc_status_time_record_cnt[dtc_code].dtc_create_time_cnt = 0u;
  534  4                                      dtc_status_time_record_cnt[dtc_code].dtc_recover_time_cnt = 0u;
  535  4                                      dtc_create_record_cnt[dtc_code].dtc_create_cnt = 0u;
  536  4      
  537  4                                      if (FALSE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedThisOperationCycle)
  538  4                                      {
  539  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedThisOperationCycle = TRUE;
  540  5                                              dtc_status_changed = TRUE;
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 10  

  541  5                                      }
  542  4                              }       
  543  3      
  544  3                              /* Check test new operation */
  545  3                              if (0u != (dtc_test_type & DTC_TEST_NEW_OPR))
  546  3                              {
  547  4                                      if (FALSE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedThisOperationCycle)
  548  4                                      {
  549  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedThisOperationCycle = TRUE;
  550  5                                              dtc_status_changed = TRUE;
  551  5                                      }
  552  4                              }
  553  3                      }
  554  2                      else
  555  2                      {
  556  3                              /* DTC Status Bit not supported, set to a default value if needed. 
  557  3                               * Please adapter the default value according to SPEC. */       
  558  3                               if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedThisOperationCycle)
  559  3                               {
  560  4                                      dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedThisOperationCycle = FALSE;
  561  4                                      dtc_status_changed = TRUE;
  562  4                               }
  563  3                      }
  564  2              }
  565  1      
  566  1              return dtc_status_changed;
  567  1      }
  568         
  569         /***********************************************************************
  570         * FUNCTION    : DescMgr_ProcPendingDTC
  571         * DESCRIPTION : None
  572         * INPUTS      : INT8U dtc_code, INT8U dtc_test_type
  573         * RETURN      : None
  574         ***********************************************************************/
  575         BOOLEAN DescMgr_ProcPendingDTC(INT8U dtc_code, INT8U dtc_test_type)
  576         {
  577  1              BOOLEAN dtc_status_changed = FALSE;
  578  1      
  579  1              DESC_MGR_STAT INT32U testDeltaTrip = 0u;
  580  1              testDeltaTrip = delta_trip_count >> dtc_code & 1u;
  581  1      
  582  1              if (dtc_code < DTC_CODE_MAX_NUM)
  583  1              {
  584  2                      /* DTC Status Bit2 suppored check */
  585  2                      if (0u != (DTC_STATUS_BIT1_MASK_TFTOC & DTC_STATUS_AVAILABILITY_MASK))
  586  2                      {
  587  3                              /* Check test initial */
  588  3                              if (0 != (dtc_test_type & DTC_TEST_INIT))
  589  3                              {
  590  4                                      /* Nothing to do. */                    
  591  4                              }
  592  3      
  593  3                              if (TRUE == bSetIncreaseHistoryPendingCntFlag[dtc_code])
  594  3                              {
  595  4                                      bSetIncreaseHistoryPendingCntFlag[dtc_code] = FALSE;
  596  4      #if defined (DTC_AGING_COUNTER)
  597  4                                      if (255u != dtc_pending_count[dtc_code])
  598  4                                      {
  599  5                                              dtc_pending_count[dtc_code]++;
  600  5                                              bDtcDataNeedSendToEep = TRUE;
  601  5                                      }
  602  4      #endif
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 11  

  603  4                              }
  604  3      
  605  3                              /* Check test passed */
  606  3                              if (0u != (dtc_test_type & DTC_TEST_PASSED))
  607  3                              {
  608  4      #if defined (DTC_AGING_COUNTER)
  609  4                                      if (TRUE == bSetClearHistoryPendingCntFlag[dtc_code])
  610  4                                      {
  611  5                                              bSetClearHistoryPendingCntFlag[dtc_code] = FALSE;
  612  5      
  613  5                                              if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.pendingDTC)
  614  5                                              {
  615  6                                                      if (testDeltaTrip)
  616  6                                                      {
  617  7                                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.pendingDTC = FALSE;
  618  7                                                              dtc_pending_count[dtc_code] = 0u;
  619  7                                                              DescMgr_SetDeltaTripCounter(dtc_code, FALSE);
  620  7      
  621  7                                                              dtc_status_changed = TRUE;
  622  7                                                      }
  623  6                                                      else
  624  6                                                      {
  625  7                                                              DescMgr_SetDeltaTripCounter(dtc_code, FALSE);
  626  7                                                      }
  627  6                                              }
  628  5                                      }
  629  4      #endif                  
  630  4                              }
  631  3      
  632  3                              /* Check test failed */
  633  3                              if (0 != (dtc_test_type & DTC_TEST_FAILED))
  634  3                              {
  635  4                                      if (FALSE == dtc_current_status_record[dtc_code].dtc_status.status_bits.pendingDTC)
  636  4                                      {
  637  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.pendingDTC = TRUE;
  638  5      #ifdef DTC_AGING_COUNTER
  639  5                                              if (255u != dtc_pending_count[dtc_code])
  640  5                                              {
  641  6                                                      dtc_pending_count[dtc_code]++;
  642  6                                                      bDtcDataNeedSendToEep = TRUE;
  643  6                                              }
  644  5      #endif
  645  5                                              dtc_status_changed = TRUE;
  646  5                                      }                               
  647  4                              }
  648  3      
  649  3                              /* Check test clear */
  650  3                  if (0u != (dtc_test_type & DTC_TEST_CLEAR))
  651  3                  {
  652  4                      dtc_status_time_record_cnt[dtc_code].dtc_create_time_cnt = 0u;
  653  4                      dtc_status_time_record_cnt[dtc_code].dtc_recover_time_cnt = 0u;
  654  4      
  655  4                      dtc_create_record_cnt[dtc_code].dtc_create_cnt = 0u;
  656  4      
  657  4      
  658  4                      if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.pendingDTC)
  659  4                      {
  660  5                          dtc_current_status_record[dtc_code].dtc_status.status_bits.pendingDTC = FALSE;
  661  5                          dtc_status_changed = TRUE;
  662  5                      }
  663  4                  }
  664  3      
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 12  

  665  3                              /* Check test new operation */
  666  3                  if (0u != (dtc_test_type & DTC_TEST_NEW_OPR))
  667  3                  {
  668  4                      /* Nothing to do */
  669  4                  }                   
  670  3                      }
  671  2                      else
  672  2                      {
  673  3                              /* DTC Status Bit not supported, set to a default value if needed. 
  674  3                               * Please adapter the default value according to SPEC. */       
  675  3                               if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.pendingDTC)
  676  3                               {
  677  4                                      dtc_current_status_record[dtc_code].dtc_status.status_bits.pendingDTC = FALSE;
  678  4                                      dtc_status_changed = TRUE;
  679  4                               }                      
  680  3                      }
  681  2              }
  682  1              
  683  1              return dtc_status_changed;
  684  1      }
  685         
  686         /***********************************************************************
  687         * FUNCTION    : DescMgr_ProcConfirmedDTC
  688         * DESCRIPTION : None
  689         * INPUTS      : INT8U dtc_code, INT8U dtc_test_type
  690         * RETURN      : None
  691         ***********************************************************************/
  692         BOOLEAN DescMgr_ProcConfirmedDTC(INT8U dtc_code, INT8U dtc_test_type)
  693         {
  694  1              BOOLEAN dtc_status_changed = FALSE;
  695  1      
  696  1              if (dtc_code < DTC_CODE_MAX_NUM)
  697  1              {
  698  2                      /* DTC Status Bit3 supported check */
  699  2                      if (0u != (DTC_STATUS_BIT3_MASK_CDTC & DTC_STATUS_AVAILABILITY_MASK))
  700  2                      {
  701  3                              /* Check test initial */
  702  3                              if (0u != (dtc_test_type & DTC_TEST_INIT))
  703  3                  {
  704  4                      /* Nothing to do */
  705  4                  }   
  706  3      
  707  3                              /* Check test passed */
  708  3                  if (0u != (dtc_test_type & DTC_TEST_PASSED))
  709  3                  {                
  710  4      #if defined (DTC_AGING_COUNTER)
  711  4                      if (TRUE == bSetClearHistoryFaultCntFlag[dtc_code])
  712  4                      {
  713  5                                              bSetClearHistoryFaultCntFlag[dtc_code] = FALSE;
  714  5      
  715  5                                              if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.confirmedDTC)
  716  5                          {
  717  6                              if (dtc_aging_count[dtc_code] >= DTC_STATUS_AGING_CNT_MAX)
  718  6                              {
  719  7                                  dtc_current_status_record[dtc_code].dtc_status.status_bits.confirmedDTC = FALS
             -E;
  720  7                                                              
  721  7                                                              /* DTC aging counter and DTC occurrence counter will be reset to 0 by self healing */
  722  7                                  dtc_aging_count[dtc_code] = DTC_STATUS_AGING_CNT_RESET;
  723  7                                                              dtc_occurance_count[dtc_code] = 0u;
  724  7                                  dtc_pending_count[dtc_code] = 0u;
  725  7      
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 13  

  726  7                                                              /* When the aging counter is up to self healing value, DTC will be moved out from current memory */
  727  7                                                              //CanDiagApp_DTC_StatusDataReport(dtc_code, DTC_TEST_CLEAR);
  728  7                                                              
  729  7                                                              if(dtc_aged_count[dtc_code] < 255u)
  730  7                                                              {
  731  8                                                                      /* When the DTC's aging counter is up to set-value, Aged counter will be increased by 1. */
  732  8                                                                      dtc_aged_count[dtc_code]++;
  733  8                                                              }
  734  7                                                              else
  735  7                                                              {
  736  8                                                                      /* If the aged counter is up to 255, it will keep to 255. */
  737  8                                                                      dtc_aged_count[dtc_code] = 255u;
  738  8                                                              }
  739  7                                                              
  740  7                                  dtc_status_changed = TRUE;
  741  7                              }
  742  6                              else
  743  6                              {
  744  7                                      /* ECU error never occur during the last whole operation cycle, driving cycle, or
             - warm-up cycle.The DTC aging
  745  7                                                               * counter value shall be increased by 1. */
  746  7                                  dtc_aging_count[dtc_code]++;
  747  7                                  dtc_status_changed = TRUE;
  748  7                              }
  749  6                          }
  750  5                      }
  751  4      #endif
  752  4                  }
  753  3      
  754  3                              /* Check test failed */
  755  3                              if (0u != (dtc_test_type & DTC_TEST_FAILED))
  756  3                  {
  757  4                      if (FALSE == dtc_current_status_record[dtc_code].dtc_status.status_bits.confirmedDTC)
  758  4                      {                   
  759  5                          dtc_current_status_record[dtc_code].dtc_status.status_bits.confirmedDTC = TRUE;
  760  5                          dtc_aging_count[dtc_code] = DTC_STATUS_AGING_CNT_RESET;
  761  5                          
  762  5                          dtc_status_changed = TRUE;
  763  5                      }
  764  4                  }
  765  3      
  766  3                              /* Check test clear */
  767  3                  if (0u != (dtc_test_type & DTC_TEST_CLEAR))
  768  3                  {
  769  4                      dtc_status_time_record_cnt[dtc_code].dtc_create_time_cnt = 0u;
  770  4                      dtc_status_time_record_cnt[dtc_code].dtc_recover_time_cnt = 0u;
  771  4                      dtc_create_record_cnt[dtc_code].dtc_create_cnt = 0u;
  772  4      
  773  4                      if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.confirmedDTC)
  774  4                      {
  775  5                          dtc_current_status_record[dtc_code].dtc_status.status_bits.confirmedDTC = FALSE;
  776  5                          dtc_status_changed = TRUE;
  777  5                      }
  778  4                  }
  779  3      
  780  3                              /* Check test new operation */
  781  3                  if (0u != (dtc_test_type & DTC_TEST_NEW_OPR))
  782  3                  {
  783  4                      /* Nothing to do */
  784  4                  }
  785  3                      }
  786  2                      else
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 14  

  787  2                      {
  788  3                              /* DTC Status Bit not supported, set to a default value if needed. 
  789  3                               * Please adapter the default value according to SPEC. */
  790  3                              if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.confirmedDTC)
  791  3                  {
  792  4                      dtc_current_status_record[dtc_code].dtc_status.status_bits.confirmedDTC = FALSE;
  793  4                      dtc_status_changed = TRUE;
  794  4                  }                   
  795  3                      }
  796  2              }
  797  1              
  798  1              return dtc_status_changed;
  799  1      }
  800         
  801         /***********************************************************************
  802         * FUNCTION    : DescMgr_ProcTestNotCompletedSinceLastClear
  803         * DESCRIPTION : None
  804         * INPUTS      : INT8U dtc_code, INT8U dtc_test_type
  805         * RETURN      : None
  806         ***********************************************************************/
  807         BOOLEAN DescMgr_ProcTestNotCompletedSinceLastClear(INT8U dtc_code, INT8U dtc_test_type)
  808         {
  809  1              BOOLEAN dtc_status_changed = FALSE;
  810  1      
  811  1              if (dtc_code < DTC_CODE_MAX_NUM)
  812  1              {
  813  2                      /* DTC Status Bit4 supported check */
  814  2                      if (0u != (DTC_STATUS_BIT4_MASK_TNCSLC & DTC_STATUS_AVAILABILITY_MASK))
  815  2                      {
  816  3                              /* Check test initial */
  817  3                              if (0 != (dtc_test_type & DTC_TEST_INIT))
  818  3                              {
  819  4                                      if (FALSE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedSinceLastClear
             -)
  820  4                                      {
  821  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedSinceLastClear = TRUE;
  822  5                                              dtc_status_changed = TRUE;
  823  5                                      }
  824  4                              }
  825  3      
  826  3                              /* Check test passed */
  827  3                              if (0 != (dtc_test_type & DTC_TEST_PASSED))
  828  3                              {
  829  4                                      if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedSinceLastClear)
  830  4                                      {
  831  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedSinceLastClear = FALSE;
  832  5                                              dtc_status_changed = TRUE;
  833  5                                      }       
  834  4                              }
  835  3      
  836  3                              /* Check test failed */
  837  3                              if (0 != (dtc_test_type & DTC_TEST_FAILED))
  838  3                              {
  839  4                                      if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedSinceLastClear)
  840  4                                      {
  841  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedSinceLastClear = FALSE;
  842  5                                              dtc_status_changed = TRUE;
  843  5                                      }       
  844  4                              }       
  845  3      
  846  3                              /* Check test clear */
  847  3                              if (0 != (dtc_test_type & DTC_TEST_CLEAR))
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 15  

  848  3                              {
  849  4                                      /* Clear all counter */
  850  4                                      dtc_status_time_record_cnt[dtc_code].dtc_create_time_cnt = 0u;
  851  4                                      dtc_status_time_record_cnt[dtc_code].dtc_recover_time_cnt = 0u;
  852  4                                      dtc_create_record_cnt[dtc_code].dtc_create_cnt = 0u;
  853  4      
  854  4                                      if (FALSE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedSinceLastClear
             -)
  855  4                                      {
  856  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedSinceLastClear = TRUE;
  857  5                                              dtc_status_changed = TRUE;
  858  5                                      }
  859  4                              }       
  860  3      
  861  3                              /* Check test new operation */
  862  3                  if (0u != (dtc_test_type&DTC_TEST_NEW_OPR))
  863  3                  {
  864  4                      /* Nothing to do */
  865  4                  }                   
  866  3                      }
  867  2                      else
  868  2                      {
  869  3                              /* DTC Status Bit not supported, set to a default value if needed. 
  870  3                               * Please adapter the default value according to SPEC. */       
  871  3                               if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedSinceLastClear)
  872  3                               {
  873  4                                      dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedSinceLastClear = FALSE;
  874  4                                      dtc_status_changed = TRUE;
  875  4                               }                      
  876  3                      }
  877  2              }
  878  1              
  879  1              return dtc_status_changed;
  880  1      }
  881         
  882         /***********************************************************************
  883         * FUNCTION    : DescMgr_ProcTestFailedSinceLastClear
  884         * DESCRIPTION : None
  885         * INPUTS      : INT8U dtc_code, INT8U dtc_test_type
  886         * RETURN      : None
  887         ***********************************************************************/
  888         BOOLEAN DescMgr_ProcTestFailedSinceLastClear(INT8U dtc_code, INT8U dtc_test_type)
  889         {
  890  1              BOOLEAN dtc_status_changed = FALSE;
  891  1      
  892  1              if (dtc_code < DTC_CODE_MAX_NUM)
  893  1              {
  894  2                      /* DTC Status Bit5 supported check */
  895  2                      if (0u != (DTC_STATUS_BIT5_MASK_TFSLC & DTC_STATUS_AVAILABILITY_MASK))
  896  2                      {
  897  3                              /* Check test initial */
  898  3                              if (0 != (dtc_test_type & DTC_TEST_INIT))
  899  3                              {
  900  4                                      if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedSinceLastClear)
  901  4                                      {
  902  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedSinceLastClear = FALSE;
  903  5                                              dtc_status_changed = TRUE;
  904  5                                      }
  905  4                              }
  906  3      
  907  3                              /* Check test passed */
  908  3                              if (0 != (dtc_test_type & DTC_TEST_PASSED))
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 16  

  909  3                              {
  910  4                                      /* Nothing to do. */
  911  4                              }
  912  3      
  913  3                              /* Check test failed */
  914  3                              if (0 != (dtc_test_type & DTC_TEST_FAILED))
  915  3                              {
  916  4                                      if (FALSE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedSinceLastClear)
  917  4                                      {
  918  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedSinceLastClear = TRUE;
  919  5                                              dtc_status_changed = TRUE;
  920  5                                      }       
  921  4                              }       
  922  3      
  923  3                              /* Check test clear */
  924  3                              if (0 != (dtc_test_type & DTC_TEST_CLEAR))
  925  3                              {
  926  4                                      /* Clear all counter */
  927  4                                      dtc_status_time_record_cnt[dtc_code].dtc_create_time_cnt = 0u;
  928  4                                      dtc_status_time_record_cnt[dtc_code].dtc_recover_time_cnt = 0u;
  929  4                                      dtc_create_record_cnt[dtc_code].dtc_create_cnt = 0u;
  930  4      
  931  4                                      if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedSinceLastClear)
  932  4                                      {
  933  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedSinceLastClear = FALSE;
  934  5                                              dtc_status_changed = TRUE;
  935  5                                      }
  936  4                              }       
  937  3      
  938  3                              /* Check test new operation */
  939  3                  if (0u != (dtc_test_type & DTC_TEST_NEW_OPR))
  940  3                  {
  941  4                      /* Nothing to do */
  942  4                  }                   
  943  3                      }
  944  2                      else
  945  2                      {
  946  3                              /* DTC Status Bit not supported, set to a default value if needed. 
  947  3                               * Please adapter the default value according to SPEC. */       
  948  3                               if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedSinceLastClear)
  949  3                               {
  950  4                                      dtc_current_status_record[dtc_code].dtc_status.status_bits.testFailedSinceLastClear = FALSE;
  951  4                                      dtc_status_changed = TRUE;
  952  4                               }                      
  953  3                      }
  954  2              }
  955  1      
  956  1              return dtc_status_changed;
  957  1      }
  958         
  959         /***********************************************************************
  960         * FUNCTION    : DescMgr_ProcTestNotCompletedThisOperationCycle
  961         * DESCRIPTION : None
  962         * INPUTS      : INT8U dtc_code, INT8U dtc_test_type
  963         * RETURN      : None
  964         ***********************************************************************/
  965         BOOLEAN DescMgr_ProcTestNotCompletedThisOperationCycle(INT8U dtc_code, INT8U dtc_test_type)
  966         {
  967  1              BOOLEAN dtc_status_changed = FALSE;
  968  1      
  969  1              if (dtc_code < DTC_CODE_MAX_NUM)
  970  1              {
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 17  

  971  2                      /* DTC Status Bit6 supported check */
  972  2                      if (0u != (DTC_STATUS_BIT6_MASK_TNCTOC & DTC_STATUS_AVAILABILITY_MASK))
  973  2                      {
  974  3                              /* Check test initial */
  975  3                              if (0 != (dtc_test_type & DTC_TEST_INIT))
  976  3                              {
  977  4                                      if (FALSE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedThisOperationC
             -ycle)
  978  4                                      {
  979  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedThisOperationCycle = TRUE;
  980  5                                              dtc_status_changed = TRUE;
  981  5                                      }
  982  4                              }
  983  3      
  984  3                              /* Check test passed */
  985  3                              if (0 != (dtc_test_type & DTC_TEST_PASSED))
  986  3                              {
  987  4                                      if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedThisOperationCy
             -cle)
  988  4                                      {
  989  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedThisOperationCycle = FALSE
             -;
  990  5                                              dtc_status_changed = TRUE;
  991  5                                      }
  992  4                              }
  993  3      
  994  3                              /* Check test failed */
  995  3                              if (0 != (dtc_test_type & DTC_TEST_FAILED))
  996  3                              {
  997  4                                      if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedThisOperationCy
             -cle)
  998  4                                      {
  999  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedThisOperationCycle = FALSE
             -;
 1000  5                                              dtc_status_changed = TRUE;
 1001  5                                      }       
 1002  4                              }       
 1003  3      
 1004  3                              /* Check test clear */
 1005  3                              if (0 != (dtc_test_type & DTC_TEST_CLEAR))
 1006  3                              {
 1007  4                                      /* Clear all counter */
 1008  4                                      dtc_status_time_record_cnt[dtc_code].dtc_create_time_cnt = 0u;
 1009  4                                      dtc_status_time_record_cnt[dtc_code].dtc_recover_time_cnt = 0u;
 1010  4                                      dtc_create_record_cnt[dtc_code].dtc_create_cnt = 0u;
 1011  4      
 1012  4                                      if (FALSE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedThisOperationC
             -ycle)
 1013  4                                      {
 1014  5                                              dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedThisOperationCycle = TRUE;
 1015  5                                              dtc_status_changed = TRUE;
 1016  5                                      }
 1017  4                              }       
 1018  3      
 1019  3                              /* Check test new operation */
 1020  3                  if (0u != (dtc_test_type&DTC_TEST_NEW_OPR))
 1021  3                  {
 1022  4                      if (FALSE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedTh
             -isOperationCycle)
 1023  4                      {
 1024  5                          dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedThisOperati
             -onCycle = TRUE;
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 18  

 1025  5                          dtc_status_changed = TRUE;
 1026  5                      }
 1027  4                  }                   
 1028  3                      }
 1029  2                      else
 1030  2                      {
 1031  3                              /* DTC Status Bit not supported, set to a default value if needed. 
 1032  3                               * Please adapter the default value according to SPEC. */       
 1033  3                               if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedThisOperationCy
             -cle)
 1034  3                               {
 1035  4                                      dtc_current_status_record[dtc_code].dtc_status.status_bits.testNotCompletedThisOperationCycle = FALSE
             -;
 1036  4                                      dtc_status_changed = TRUE;
 1037  4                               }                      
 1038  3                      }
 1039  2              }
 1040  1      
 1041  1              return dtc_status_changed;
 1042  1      }
 1043         
 1044         /***********************************************************************
 1045         * FUNCTION    : DescMgr_ProcWarningIndicatorRequested
 1046         * DESCRIPTION : None
 1047         * INPUTS      : INT8U dtc_code, INT8U dtc_test_type
 1048         * RETURN      : None
 1049         ***********************************************************************/
 1050         BOOLEAN DescMgr_ProcWarningIndicatorRequested(INT8U dtc_code, INT8U dtc_test_type)
 1051         {
 1052  1              BOOLEAN dtc_status_changed = FALSE;
 1053  1      
 1054  1          if (dtc_code < DTC_CODE_MAX_NUM)
 1055  1          {
 1056  2                      /* DTC Status Bit7 supported check */
 1057  2                      if (0u != (DTC_STATUS_BIT7_MASK_WIR & DTC_STATUS_AVAILABILITY_MASK)) 
 1058  2              {
 1059  3                              /* Check test initial */
 1060  3                  if (0u != (dtc_test_type & DTC_TEST_INIT))
 1061  3                  {
 1062  4                                      /* Not implement yet */
 1063  4                  }
 1064  3      
 1065  3                              /* Check test passed */
 1066  3                  if (0u != (dtc_test_type & DTC_TEST_PASSED))
 1067  3                  {
 1068  4                      /* Not implement yet */
 1069  4                  }
 1070  3      
 1071  3                              /* Check test failed */                 
 1072  3                  if (0u != (dtc_test_type & DTC_TEST_FAILED))
 1073  3                  {
 1074  4                      /* Not implement yet */
 1075  4                  }
 1076  3      
 1077  3                              /* Check test clear */                  
 1078  3                  if (0u != (dtc_test_type & DTC_TEST_CLEAR))
 1079  3                  {
 1080  4                      dtc_status_time_record_cnt[dtc_code].dtc_create_time_cnt = 0u;
 1081  4                      dtc_status_time_record_cnt[dtc_code].dtc_recover_time_cnt = 0u;
 1082  4                      dtc_create_record_cnt[dtc_code].dtc_create_cnt = 0u;
 1083  4      
 1084  4                      /* Not implement yet */
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 19  

 1085  4                  }
 1086  3      
 1087  3                              /* Check test new operation */
 1088  3                  if (0u != (dtc_test_type & DTC_TEST_NEW_OPR))
 1089  3                  {
 1090  4                      /* Not implement yet */
 1091  4                  }    
 1092  3              }
 1093  2              else
 1094  2              {
 1095  3                              /* DTC Status Bit not supported, set to a default value if needed. 
 1096  3                               * Please adapter the default value according to SPEC. */
 1097  3                  if (TRUE == dtc_current_status_record[dtc_code].dtc_status.status_bits.warningIndicatorRequest
             -ed)
 1098  3                  {
 1099  4                      dtc_current_status_record[dtc_code].dtc_status.status_bits.warningIndicatorRequested = FAL
             -SE;
 1100  4                      dtc_status_changed = TRUE;
 1101  4                  }
 1102  3              }
 1103  2          }
 1104  1              
 1105  1              return dtc_status_changed;
 1106  1      }
 1107         
 1108         /*****************************************************************************************
 1109         *  Name        : DescMgr_ExtendDataReport
 1110         *  Description :     
 1111         *  Parameter   : INT8U dtc_code
 1112         *  Returns     : none 
 1113         *****************************************************************************************/
 1114         DESC_MGR_STAT void DescMgr_ExtendDataReport(INT8U dtc_code)
 1115         {
 1116  1              // TODO:
 1117  1      }
*** WARNING C47 IN LINE 1114 OF src\bsw\desc\desc_mgr.c: 'dtc_code': unreferenced parameter
 1118         
 1119         /*****************************************************************************************
 1120         *  Name        : DescMgr_SnapshotDataReport
 1121         *  Description :     
 1122         *  Parameter   : INT8U dtc_code
 1123         *  Returns     : none 
 1124         *****************************************************************************************/
 1125         DESC_MGR_STAT void DescMgr_SnapshotDataReport(INT8U dtc_code)
 1126         {
 1127  1              // TODO:Snapshot data need to conversion
 1128  1      
 1129  1              const T_ADC_APP *ptr = AdcApp_SampleData();
 1130  1      
 1131  1              // 19A0:DC Vlink voltage
 1132  1              dtc_snapshot_data_record[dtc_code].DcVoltage_High_Byte = (INT8U)((ptr->vehiclePowerVoltage & 0xFF00) >> 8
             -u);
 1133  1              dtc_snapshot_data_record[dtc_code].DcVoltage_Low_Byte = (INT8U)(ptr->vehiclePowerVoltage & 0x00FF);
 1134  1      
 1135  1              // 19A1:ECU output current
 1136  1              dtc_snapshot_data_record[dtc_code].OutputCurrent_High_Byte = 0u;
 1137  1              dtc_snapshot_data_record[dtc_code].OutputCurrent_Low_Byte = 0u;
 1138  1      
 1139  1              // 19A2:Target frequency
 1140  1              dtc_snapshot_data_record[dtc_code].TargetFrequency_High_Byte = 0u;
 1141  1              dtc_snapshot_data_record[dtc_code].TargetFrequency_Low_Byte = 0u;       
 1142  1      
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 20  

 1143  1              // 19A3:Actual frequency
 1144  1              dtc_snapshot_data_record[dtc_code].ActualFrequency_High_Byte = 0u;
 1145  1              dtc_snapshot_data_record[dtc_code].ActualFrequency_Low_Byte = 0u;               
 1146  1      
 1147  1              // 19A4:Target torque
 1148  1              dtc_snapshot_data_record[dtc_code].TargetTorque_High_Byte = 0u;
 1149  1              dtc_snapshot_data_record[dtc_code].TargetTorque_Low_Byte = 0u;
 1150  1      
 1151  1              // 19A5:Motor temperature
 1152  1              dtc_snapshot_data_record[dtc_code].MotorTemperature = 0u;
 1153  1      
 1154  1              // 19A6:ECU temperature
 1155  1              dtc_snapshot_data_record[dtc_code].EcuTemperature = 0u; 
 1156  1      
 1157  1              // 19A7:Ext power voltage
 1158  1              dtc_snapshot_data_record[dtc_code].ExtPowerVoltage_High_Byte = 0u;
 1159  1              dtc_snapshot_data_record[dtc_code].ExtPowerVoltage_Low_Byte = 0u;       
 1160  1      
 1161  1              return;
 1162  1      }
 1163         
 1164         /******************************************************************************
 1165         * Name         :  DescMgr_SetDeltaTripCounter 
 1166         * Called by    :   
 1167         * Preconditions:  None
 1168         * Parameters   :  None
 1169         * Description  :  uidq2008
 1170         ******************************************************************************/
 1171         DESC_MGR_STAT void DescMgr_SetDeltaTripCounter(INT8U dtc_code, BOOLEAN delta_Trip_flag)
 1172         {
 1173  1         if (TRUE == delta_Trip_flag)
 1174  1         {
 1175  2              delta_trip_count |= (1u << dtc_code);
 1176  2         }
 1177  1         else
 1178  1         {
 1179  2              delta_trip_count &= ~(1u << dtc_code);
 1180  2         }
 1181  1      }
 1182         
 1183         /***********************************************************************
 1184         * FUNCTION    : DescMgr_CanDiagDtcRecordBodyEnableCheck
 1185         * DESCRIPTION : 
 1186         * INPUTS      : none
 1187         * RETURN      : none
 1188         ***********************************************************************/
 1189         BOOLEAN DescMgr_CanDiagDtcRecordBodyEnableCheck(void)
 1190         {
 1191  1          return (((dtc_record_enable_mask & DTC_RECORD_ENALBE_BDY) != 0u) ? 1u : 0u);
 1192  1      }
 1193         
 1194         
 1195         /***********************************************************************
 1196         * FUNCTION    : DescMgr_CanDiagDtcRecordNmEnableCheck
 1197         * DESCRIPTION : 
 1198         * INPUTS      : none
 1199         * RETURN      : none
 1200         ***********************************************************************/
 1201         BOOLEAN DescMgr_CanDiagDtcRecordNmEnableCheck(void)
 1202         {
 1203  1          return (((dtc_record_enable_mask & DTC_RECORD_ENABLE_NM) != 0u) ? 1u : 0u);
 1204  1      }
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 21  

 1205         
 1206         
 1207         /***********************************************************************
 1208         * FUNCTION    : DescMgr_CanDiagDtcRecordOpVoltEnableCheck
 1209         * DESCRIPTION : 
 1210         * INPUTS      : none
 1211         * RETURN      : none
 1212         ***********************************************************************/
 1213         BOOLEAN DescMgr_CanDiagDtcRecordOpVoltEnableCheck(void)
 1214         {
 1215  1          return (((dtc_record_enable_mask & DTC_RECORD_ENABLE_OP_VOLT) != 0u) ? 1u : 0u);
 1216  1      }
 1217         
 1218         /**** $85 ****/
 1219         
 1220         /***********************************************************************
 1221         * FUNCTION    : DescMgr_CanDiagDtcControlSettingOn
 1222         * DESCRIPTION : TRUE:means control dtc setting is on,
 1223         *               FALSE:means control dtc setting is off.
 1224         * INPUTS      : none
 1225         * RETURN      : none
 1226         ***********************************************************************/
 1227         void DescMgr_CanDiagDtcControlSettingOn(void)
 1228         {
 1229  1          dtc_control_setting_on_off = TRUE;
 1230  1      }
 1231         
 1232         /***********************************************************************
 1233         * FUNCTION    : DescMgr_CanDiagDtcControlSettingOff
 1234         * DESCRIPTION : TRUE:means control dtc setting is on,
 1235         *               FALSE:means control dtc setting is off.
 1236         * INPUTS      : none
 1237         * RETURN      : none
 1238         ***********************************************************************/
 1239         void DescMgr_CanDiagDtcControlSettingOff(void)
 1240         {
 1241  1          dtc_control_setting_on_off = FALSE;
 1242  1      }
 1243         
 1244         /***********************************************************************
 1245         * FUNCTION    : DescMgr_CanDiagDtcControlSettingCheck
 1246         * DESCRIPTION : TRUE:means control dtc setting is on,
 1247         *               FALSE:means control dtc setting is off.
 1248         * INPUTS      : none
 1249         * RETURN      : none
 1250         ***********************************************************************/
 1251         BOOLEAN DescMgr_CanDiagDtcControlSettingCheck(void)
 1252         {
 1253  1          return dtc_control_setting_on_off;
 1254  1      }
 1255         
 1256         /**** $14 ****/
 1257         /***********************************************************************
 1258         * FUNCTION    : DescMgr_CanDiagClearDtcDataStart
 1259         * DESCRIPTION : none
 1260         * INPUTS      : none
 1261         * RETURN      : none
 1262         ***********************************************************************/
 1263         void DescMgr_CanDiagClearDtcDataStart(void)
 1264         {
 1265  1          /* do not care about last time, just reset the whole clear things */
 1266  1          dtc_status_svc14_clear_counter = DTC_STATUS_SVC14_CLEAR_START; /* clear begin */
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 22  

 1267  1          
 1268  1          /* Adjust dtc record enable mask */
 1269  1          DescMgr_CanDigDtcRecordEnableAdjust();
 1270  1      }
 1271         
 1272         /***********************************************************************
 1273         * FUNCTION    : DescMgr_CanDiagDtcStatusServiceClearAll
 1274         * DESCRIPTION : Do not clear all the dtc status at the same time, it would cost worse CPU/thread load,
 1275         *               So just separate the clear action, Called by desc_delay_service_task to do this job.
 1276         * INPUTS      : none
 1277         * RETURN      : none
 1278         ***********************************************************************/
 1279         DESC_MGR_STAT BOOLEAN DescMgr_CanDiagDtcStatusServiceClearAll(void)
 1280         {
 1281  1          BOOLEAN clear_finished = FALSE;
 1282  1      
 1283  1          if (dtc_status_svc14_clear_counter < DTC_CODE_MAX_NUM)
 1284  1          {
 1285  2                      DescMgr_DtcStatusDataReport(dtc_status_svc14_clear_counter, DTC_TEST_CLEAR);
 1286  2      
 1287  2      #ifdef DTC_AGING_COUNTER
 1288  2                      memset(dtc_aged_count, DTC_STATUS_AGING_CNT_RESET, DTC_CODE_MAX_NUM);
 1289  2                      memset(dtc_aging_count, DTC_STATUS_AGING_CNT_RESET, DTC_CODE_MAX_NUM);
 1290  2                      memset(dtc_pending_count, DTC_STATUS_AGING_CNT_RESET, DTC_CODE_MAX_NUM);        
 1291  2                      memset(dtc_occurance_count, DTC_STATUS_AGING_CNT_RESET, DTC_CODE_MAX_NUM);
 1292  2      #endif
 1293  2              dtc_status_svc14_clear_counter++;
 1294  2                      clear_finished = FALSE;
 1295  2          }
 1296  1          else
 1297  1          {
 1298  2                      /* Adjust dtc record enable mask */
 1299  2              DescMgr_CanDigDtcRecordEnableAdjust();    
 1300  2              dtc_status_svc14_clear_counter = DTC_STATUS_SVC14_CLEAR_FINISHED;  
 1301  2              clear_finished = TRUE;
 1302  2          }
 1303  1          
 1304  1          return clear_finished;
 1305  1      }
 1306         
 1307         /***********************************************************************
 1308         * FUNCTION    : DescMgr_CanDiagDtcStatusServiceClearFinished
 1309         * DESCRIPTION : none                        
 1310         * INPUTS      : none
 1311         * RETURN      : none
 1312         ***********************************************************************/
 1313         DESC_MGR_STAT BOOLEAN DescMgr_CanDiagDtcStatusServiceClearFinished(void)
 1314         {
 1315  1          return ((DTC_STATUS_SVC14_CLEAR_FINISHED == dtc_status_svc14_clear_counter) ? 1u : 0u);
 1316  1      }
 1317         
 1318         /***********************************************************************
 1319         * FUNCTION    : DescMgr_CanDigDtcRecordEnableAdjust
 1320         * DESCRIPTION : none
 1321         * INPUTS      : none
 1322         * RETURN      : none
 1323         ***********************************************************************/
 1324         DESC_MGR_STAT void DescMgr_CanDigDtcRecordEnableAdjust(void)
 1325         {
 1326  1          /* diagnosis function start-up init delay according to vehicle manufacturer */
 1327  1          if (CAN_DIAG_INIT_DELAY_TIMEOUT != can_diag_init_delay_timer)
 1328  1          {
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 23  

 1329  2              /* all dtc record disable */
 1330  2              dtc_record_enable_mask = DTC_RECORD_ENABLE_NONE;
 1331  2              
 1332  2              return;
 1333  2          }
 1334  1          else
 1335  1          {
 1336  2              /* Disable here, because we do not know the other situations, so let other judgement following to 
             -do this job. */
 1337  2              dtc_record_enable_mask = DTC_RECORD_ENABLE_NONE;
 1338  2          }
 1339  1      
 1340  1          /* dtc eeprom init delay */
 1341  1          if (DTC_INIT_STEP_FINISHED != dtc_eeprom_init_step)
 1342  1          {
 1343  2              /* all dtc record disable */
 1344  2              dtc_record_enable_mask = DTC_RECORD_ENABLE_NONE;
 1345  2              
 1346  2              return;    
 1347  2          }
 1348  1          else
 1349  1          {
 1350  2              /* Disable here, because we do not know the other situations, so let other judgement following to 
             -do this job. */
 1351  2              dtc_record_enable_mask = DTC_RECORD_ENABLE_NONE;        
 1352  2          }
 1353  1      
 1354  1          /* service $14 clear dtc eeprom init delay */
 1355  1          if (DTC_STATUS_SVC14_CLEAR_FINISHED != dtc_status_svc14_clear_counter)
 1356  1          {
 1357  2              /* all dtc record disable */
 1358  2              dtc_record_enable_mask = DTC_RECORD_ENABLE_NONE;
 1359  2              
 1360  2              return;    
 1361  2          }
 1362  1          else
 1363  1          {
 1364  2              /* Disable here, because we do not know the other situations, so let other judgement following to 
             -do this job. */
 1365  2              dtc_record_enable_mask = DTC_RECORD_ENABLE_NONE;        
 1366  2          }
 1367  1      
 1368  1          /* other delay according to vehicle manufacturer */
 1369  1              // TODO:System power voltage status 9-16V.      
 1370  1          if (1)  /*if power out range of [9-16v],stop candiag*/
 1371  1          {
 1372  2              dtc_record_enable_mask = (dtc_record_enable_mask | DTC_RECORD_ENALBE_BDY);//DTC_RECORD_ENABLE_OP_V
             -OLT
 1373  2      
 1374  2              if (CAN_DIAG_BAT_VOLT_RECOVER_DELAY_TIMEOUT != can_diag_bat_volt_recover_delay_timer)
 1375  2              {
 1376  3                  dtc_record_enable_mask = (dtc_record_enable_mask & (~DTC_RECORD_ENABLE_NM));
 1377  3                  dtc_record_enable_mask = (dtc_record_enable_mask & (~DTC_RECORD_ENALBE_BDY));
 1378  3      
 1379  3                  return;
 1380  3              }
 1381  2              else
 1382  2              {
 1383  3                  dtc_record_enable_mask = (dtc_record_enable_mask | DTC_RECORD_ENALBE_BDY);
 1384  3      
 1385  3                  if (CAN_DIAG_NM_INIT_DELAY_TIMEOUT == can_diag_init_nm_delay_timer)
 1386  3                  {
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 24  

 1387  4                      dtc_record_enable_mask = (dtc_record_enable_mask | DTC_RECORD_ENABLE_NM);
 1388  4                  }
 1389  3                  else
 1390  3                  {
 1391  4                      dtc_record_enable_mask = (dtc_record_enable_mask & (~DTC_RECORD_ENABLE_NM));
 1392  4                  }
 1393  3              }
 1394  2          }
 1395  1          else
 1396  1          {
 1397  2              dtc_record_enable_mask = (dtc_record_enable_mask|DTC_RECORD_ENALBE_BDY);//DTC_RECORD_ENABLE_OP_VOL
             -T
 1398  2          }
 1399  1      
 1400  1      }
 1401         
 1402         /**** $19 ****/
 1403         
 1404         /***********************************************************************
 1405         * FUNCTION    : DescMgr_CanDiagGetDtcCount
 1406         * DESCRIPTION : none
 1407         * INPUTS      : INT8U status_mask
 1408         * RETURN      : none
 1409         ***********************************************************************/
 1410         INT16U DescMgr_CanDiagGetDtcCount(INT8U status_mask)
 1411         {
 1412  1          INT16U dtc_count = 0u;
 1413  1          INT8U record_count = 0u;
 1414  1      
 1415  1          for (record_count=0u; record_count<DTC_CODE_MAX_NUM; record_count++)
 1416  1          {
 1417  2              if ((dtc_current_status_record[record_count].dtc_status.status_byte & status_mask) != 0u)
 1418  2              {
 1419  3                  dtc_count++;
 1420  3              }
 1421  2          }
 1422  1          
 1423  1          return dtc_count;
 1424  1      }
 1425         
 1426         /***********************************************************************
 1427         * FUNCTION    : DescMgr_CanDiagGetDtcStatusByStatusMask
 1428         * DESCRIPTION : none
 1429         * INPUTS      : INT8U *p_dtc, INT8U status_mask
 1430         * RETURN      : none
 1431         ***********************************************************************/
 1432         INT16U DescMgr_CanDiagGetDtcStatusByStatusMask(INT8U *p_dtc, INT8U status_mask)
 1433         {
 1434  1          INT16U dtc_count = 0u;
 1435  1          INT8U record_count = 0u;
 1436  1      
 1437  1          for (record_count=0u; record_count<DTC_CODE_MAX_NUM; record_count++)
 1438  1          {
 1439  2              if ((dtc_current_status_record[record_count].dtc_status.status_byte & status_mask) != 0u)
 1440  2              {
 1441  3                  *p_dtc++ = dtc_code_data[record_count].dtc_bytes.dtc_high_byte;
 1442  3                  *p_dtc++ = dtc_code_data[record_count].dtc_bytes.dtc_middle_byte;
 1443  3                  *p_dtc++ = dtc_code_data[record_count].dtc_bytes.dtc_low_byte;
 1444  3                  *p_dtc++ = dtc_current_status_record[record_count].dtc_status.status_byte;
 1445  3                  
 1446  3                  dtc_count++;
 1447  3              }
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 25  

 1448  2          }
 1449  1          
 1450  1          return dtc_count;
 1451  1      }
 1452         
 1453         /***********************************************************************
 1454         * FUNCTION    : DescMgr_CanDiagGetSupportedDtc
 1455         * DESCRIPTION : none
 1456         * INPUTS      : *p_dtc
 1457         * RETURN      : none
 1458         ***********************************************************************/
 1459         INT16U DescMgr_CanDiagGetSupportedDtc(INT8U *p_dtc)
 1460         {
 1461  1          INT16U dtc_count = 0u;
 1462  1          INT8U record_count = 0u;
 1463  1      
 1464  1          for (record_count=0u; record_count<DTC_CODE_MAX_NUM; record_count++)
 1465  1          {
 1466  2              *p_dtc++ = dtc_code_data[record_count].dtc_bytes.dtc_high_byte;
 1467  2              *p_dtc++ = dtc_code_data[record_count].dtc_bytes.dtc_middle_byte;
 1468  2              *p_dtc++ = dtc_code_data[record_count].dtc_bytes.dtc_low_byte;
 1469  2              *p_dtc++ = dtc_current_status_record[record_count].dtc_status.status_byte;
 1470  2              
 1471  2              dtc_count++;
 1472  2          }
 1473  1              
 1474  1          return dtc_count;
 1475  1      }
 1476         
 1477         /***********************************************************************
 1478         * FUNCTION    : DescMgr_CanDiagGetSnapshotData
 1479         * DESCRIPTION : none
 1480         * INPUTS      : INT8U *res_data, INT8U *req_dtc
 1481         * RETURN      : none
 1482         ***********************************************************************/
 1483         void DescMgr_CanDiagGetSnapshotData(INT8U *res_data, INT8U *req_dtc)
 1484         {
 1485  1          INT8U record_count;
 1486  1              
 1487  1              for (record_count=0u; record_count<DTC_CODE_MAX_NUM; record_count++)   
 1488  1          {
 1489  2              if ((dtc_code_data[record_count].dtc_bytes.dtc_high_byte == req_dtc[2]) 
 1490  2                       && (dtc_code_data[record_count].dtc_bytes.dtc_middle_byte == req_dtc[3])
 1491  2                       && (dtc_code_data[record_count].dtc_bytes.dtc_low_byte == req_dtc[4]))
 1492  2              {
 1493  3                      if ((dtc_current_status_record[record_count].dtc_status.status_byte & DTC_STATUS_AVAILABILITY_MAS
             -K) != 0)
 1494  3                      {
 1495  4                              DescMgr_ReturnSnapshotData(res_data, record_count);
 1496  4                              }
 1497  3                  else
 1498  3                  {
 1499  4                      DescMgr_ReturnSnapshotDataDefault(res_data, record_count);
 1500  4                  }
 1501  3              }
 1502  2          }
 1503  1      }
 1504         
 1505         /***********************************************************************
 1506         * FUNCTION    : DescMgr_ReturnSnapshotData
 1507         * DESCRIPTION : none
 1508         * INPUTS      : INT8U *res_data, DTC_CODE_NUM_TYPE dtc_number
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 26  

 1509         * RETURN      : none
 1510         ***********************************************************************/
 1511         DESC_MGR_STAT void DescMgr_ReturnSnapshotData(INT8U *res_data, DTC_CODE_NUM_TYPE dtc_number)
 1512         {
 1513  1          *(res_data+0) = dtc_code_data[dtc_number].dtc_bytes.dtc_high_byte;            /* DTCHighByte */
 1514  1          *(res_data+1) = dtc_code_data[dtc_number].dtc_bytes.dtc_middle_byte;          /* DTCMiddleByte */
 1515  1          *(res_data+2) = dtc_code_data[dtc_number].dtc_bytes.dtc_low_byte;             /* DTCLowByte */
 1516  1          *(res_data+3) = dtc_current_status_record[dtc_number].dtc_status.status_byte; /* statusOfDTC */     
 1517  1          *(res_data+4) = 0x01; /* DTC Snapshot Record Number */   
 1518  1          *(res_data+5) = 0x07; /* DTC Snapshot Record Number Of Identifiers */
 1519  1      
 1520  1          *(res_data+6) = 0x19;
 1521  1          *(res_data+7) = 0xA0;
 1522  1          *(res_data+8) = dtc_snapshot_data_record[dtc_number].DcVoltage_High_Byte;
 1523  1          *(res_data+9) = dtc_snapshot_data_record[dtc_number].DcVoltage_Low_Byte;
 1524  1      
 1525  1          *(res_data+10) = 0x19;
 1526  1          *(res_data+11) = 0xA1;
 1527  1          *(res_data+12) = dtc_snapshot_data_record[dtc_number].OutputCurrent_High_Byte;
 1528  1          *(res_data+13) = dtc_snapshot_data_record[dtc_number].OutputCurrent_Low_Byte;
 1529  1      
 1530  1          *(res_data+14) = 0x19;
 1531  1          *(res_data+15) = 0xA2;
 1532  1          *(res_data+16) = dtc_snapshot_data_record[dtc_number].TargetFrequency_High_Byte;
 1533  1          *(res_data+17) = dtc_snapshot_data_record[dtc_number].TargetFrequency_Low_Byte;     
 1534  1      
 1535  1          *(res_data+18) = 0x19;
 1536  1          *(res_data+19) = 0xA3;
 1537  1          *(res_data+20) = dtc_snapshot_data_record[dtc_number].ActualFrequency_High_Byte;
 1538  1          *(res_data+21) = dtc_snapshot_data_record[dtc_number].ActualFrequency_Low_Byte;     
 1539  1      
 1540  1          *(res_data+22) = 0x19;
 1541  1          *(res_data+23) = 0xA4;
 1542  1          *(res_data+24) = dtc_snapshot_data_record[dtc_number].TargetTorque_High_Byte;
 1543  1          *(res_data+25) = dtc_snapshot_data_record[dtc_number].TargetTorque_Low_Byte;
 1544  1      
 1545  1          *(res_data+26) = 0x19;
 1546  1          *(res_data+27) = 0xA5;
 1547  1          *(res_data+28) = dtc_snapshot_data_record[dtc_number].MotorTemperature;
 1548  1      
 1549  1          *(res_data+29) = 0x19;
 1550  1          *(res_data+30) = 0xA6;
 1551  1          *(res_data+31) = dtc_snapshot_data_record[dtc_number].EcuTemperature;       
 1552  1      
 1553  1          *(res_data+32) = 0x19;
 1554  1          *(res_data+33) = 0xA7;
 1555  1          *(res_data+34) = dtc_snapshot_data_record[dtc_number].ExtPowerVoltage_High_Byte;
 1556  1          *(res_data+35) = dtc_snapshot_data_record[dtc_number].ExtPowerVoltage_Low_Byte;     
 1557  1      }
 1558         
 1559         /***********************************************************************
 1560         * FUNCTION    : DescMgr_ReturnSnapshotDataDefault
 1561         * DESCRIPTION : none
 1562         * INPUTS      : INT8U *res_data, DTC_CODE_NUM_TYPE dtc_number
 1563         * RETURN      : none
 1564         ***********************************************************************/
 1565         DESC_MGR_STAT void DescMgr_ReturnSnapshotDataDefault(INT8U *res_data, DTC_CODE_NUM_TYPE dtc_number)
 1566         {
 1567  1          *(res_data+0) = dtc_code_data[dtc_number].dtc_bytes.dtc_high_byte;            /* DTCHighByte */
 1568  1          *(res_data+1) = dtc_code_data[dtc_number].dtc_bytes.dtc_middle_byte;          /* DTCMiddleByte */
 1569  1          *(res_data+2) = dtc_code_data[dtc_number].dtc_bytes.dtc_low_byte;             /* DTCLowByte */
 1570  1          *(res_data+3) = dtc_current_status_record[dtc_number].dtc_status.status_byte; /* statusOfDTC */     
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 27  

 1571  1          *(res_data+4) = 0x01; /* DTC Snapshot Record Number */   
 1572  1          *(res_data+5) = 0x07; /* DTC Snapshot Record Number Of Identifiers */
 1573  1      
 1574  1          *(res_data+6) = 0x19;
 1575  1          *(res_data+7) = 0xA0;
 1576  1          *(res_data+8) = 0x00;
 1577  1          *(res_data+9) = 0x00;
 1578  1      
 1579  1          *(res_data+10) = 0x19;
 1580  1          *(res_data+11) = 0xA1;
 1581  1          *(res_data+12) = 0x00;
 1582  1          *(res_data+13) = 0x00;
 1583  1      
 1584  1          *(res_data+14) = 0x19;
 1585  1          *(res_data+15) = 0xA2;
 1586  1          *(res_data+16) = 0x00;
 1587  1          *(res_data+17) = 0x00;      
 1588  1      
 1589  1          *(res_data+18) = 0x19;
 1590  1          *(res_data+19) = 0xA3;
 1591  1          *(res_data+20) = 0x00;
 1592  1          *(res_data+21) = 0x00;      
 1593  1      
 1594  1          *(res_data+22) = 0x19;
 1595  1          *(res_data+23) = 0xA4;
 1596  1          *(res_data+24) = 0x00;
 1597  1          *(res_data+25) = 0x00;
 1598  1      
 1599  1          *(res_data+26) = 0x19;
 1600  1          *(res_data+27) = 0xA5;
 1601  1          *(res_data+28) = 0x00;
 1602  1      
 1603  1          *(res_data+29) = 0x19;
 1604  1          *(res_data+30) = 0xA6;
 1605  1          *(res_data+31) = 0x00;      
 1606  1      
 1607  1          *(res_data+32) = 0x19;
 1608  1          *(res_data+33) = 0xA7;
 1609  1          *(res_data+34) = 0x00;
 1610  1          *(res_data+35) = 0x00;      
 1611  1      }
 1612         
 1613         /***********************************************************************
 1614         * FUNCTION    : DescMgr_CanDiagGetExtendData
 1615         * DESCRIPTION : none
 1616         * INPUTS      : *p_dtc
 1617         * RETURN      : none
 1618         ***********************************************************************/
 1619         void DescMgr_CanDiagGetExtendData(INT8U *res_data, INT8U *req_dtc)
 1620         {
 1621  1          INT8U record_count;
 1622  1              
 1623  1              for (record_count=0u; record_count<DTC_CODE_MAX_NUM; record_count++)   //added by uidq2008
 1624  1          {
 1625  2              if ((dtc_code_data[record_count].dtc_bytes.dtc_high_byte == req_dtc[2]) 
 1626  2                      &&  (dtc_code_data[record_count].dtc_bytes.dtc_middle_byte == req_dtc[3])
 1627  2                      &&  (dtc_code_data[record_count].dtc_bytes.dtc_low_byte == req_dtc[4]))
 1628  2              {
 1629  3                      if ((dtc_current_status_record[record_count].dtc_status.status_byte & DTC_STATUS_AVAILABILITY_MAS
             -K) != 0)
 1630  3                      {
 1631  4                              DescMgr_ReturnExtendData(res_data, record_count, req_dtc[5]);
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 28  

 1632  4                              }
 1633  3                  else
 1634  3                  {
 1635  4                      DescMgr_ReturnExtendDataDefault(res_data, record_count, req_dtc[5]);
 1636  4                  }
 1637  3              }
 1638  2          }
 1639  1      }
 1640         
 1641         /***********************************************************************
 1642         * FUNCTION    : DescMgr_ReturnExtendData
 1643         * DESCRIPTION : none
 1644         * INPUTS      : *p_dtc
 1645         * RETURN      : none
 1646         ***********************************************************************/
 1647         DESC_MGR_STAT void DescMgr_ReturnExtendData(INT8U *res_data, DTC_CODE_NUM_TYPE dtc_number, INT8U RecordNum
             -)
 1648         {
 1649  1          *(res_data+0) = dtc_code_data[dtc_number].dtc_bytes.dtc_high_byte;            /* DTCHighByte */
 1650  1          *(res_data+1) = dtc_code_data[dtc_number].dtc_bytes.dtc_middle_byte;              /* DTCMiddleByte */
 1651  1          *(res_data+2) = dtc_code_data[dtc_number].dtc_bytes.dtc_low_byte;             /* DTCLowByte */
 1652  1          *(res_data+3) = dtc_current_status_record[dtc_number].dtc_status.status_byte; /* statusOfDTC */
 1653  1              
 1654  1          switch (RecordNum)    
 1655  1          {
 1656  2              case 0x01: /*Fault occurrence counter */
 1657  2                  *(res_data+4) = 0x01;
 1658  2                  *(res_data+5) = dtc_occurance_count[dtc_number]; 
 1659  2                  break;
 1660  2                              
 1661  2              case 0x02: /*Fault pending counter  */
 1662  2                  *(res_data+4) = 0x02;
 1663  2                  *(res_data+5) = dtc_pending_count[dtc_number];      
 1664  2                  break;
 1665  2                              
 1666  2              case 0x03: /* DTC Aging counter */
 1667  2                  *(res_data+4) = 0x03;
 1668  2                  *(res_data+5) = dtc_aging_count[dtc_number];        
 1669  2                  break;
 1670  2                              
 1671  2              case 0x04: /* DTC Aged counter */
 1672  2                  *(res_data+4) = 0x04;
 1673  2                  *(res_data+5) = dtc_aged_count[dtc_number]; 
 1674  2                  break;
 1675  2                              
 1676  2              case 0xFF:
 1677  2                              *(res_data+4) = 0x01;
 1678  2                              *(res_data+5) = dtc_occurance_count[dtc_number];        
 1679  2                              *(res_data+6) = 0x02;
 1680  2                              *(res_data+7) = dtc_pending_count[dtc_number];  
 1681  2                              *(res_data+8) = 0x03;
 1682  2                              *(res_data+9) = dtc_aging_count[dtc_number];    
 1683  2                              *(res_data+10) = 0x04;
 1684  2                              *(res_data+11) = dtc_aged_count[dtc_number];    
 1685  2                  break;
 1686  2                              
 1687  2              default:
 1688  2                  break;
 1689  2          }
 1690  1      }
 1691         
 1692         /***********************************************************************
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 29  

 1693         * FUNCTION    : DescMgr_ReturnExtendDataDefault
 1694         * DESCRIPTION : none
 1695         * INPUTS      : *p_dtc
 1696         * RETURN      : none
 1697         ***********************************************************************/
 1698         DESC_MGR_STAT void DescMgr_ReturnExtendDataDefault(INT8U *res_data, DTC_CODE_NUM_TYPE dtc_number, INT8U Re
             -cordNum)
 1699         {
 1700  1          *(res_data+0) = dtc_code_data[dtc_number].dtc_bytes.dtc_high_byte;            /* DTCHighByte */
 1701  1          *(res_data+1) = dtc_code_data[dtc_number].dtc_bytes.dtc_middle_byte;              /* DTCMiddleByte */
 1702  1          *(res_data+2) = dtc_code_data[dtc_number].dtc_bytes.dtc_low_byte;             /* DTCLowByte */
 1703  1          *(res_data+3) = dtc_current_status_record[dtc_number].dtc_status.status_byte; /* statusOfDTC */
 1704  1              
 1705  1          switch (RecordNum)    
 1706  1          {
 1707  2              case 0x01: /* Fault occurrence counter */
 1708  2                  *(res_data+4) = 0x01;
 1709  2                  *(res_data+5) = 0x00;       
 1710  2                  break;
 1711  2                              
 1712  2              case 0x02: /* Fault pending counter  */
 1713  2                  *(res_data+4) = 0x02;
 1714  2                  *(res_data+5) = 0x00;       
 1715  2                  break;
 1716  2                              
 1717  2              case 0x03: /* DTC Aging counter */
 1718  2                  *(res_data+4) = 0x03;
 1719  2                  *(res_data+5) = 0x00;       
 1720  2                  break;
 1721  2                              
 1722  2              case 0x04: /* DTC Aged counter */
 1723  2                  *(res_data+4) = 0x04;
 1724  2                  *(res_data+5) = 0x00;       
 1725  2                  break;
 1726  2                              
 1727  2              case 0xFF:
 1728  2                              *(res_data+4) = 0x01;
 1729  2                              *(res_data+5) = 0x00;   
 1730  2                              *(res_data+6) = 0x02;
 1731  2                              *(res_data+7) = 0x00;   
 1732  2                              *(res_data+8) = 0x03;
 1733  2                              *(res_data+9) = 0x00;
 1734  2                              *(res_data+10) = 0x04;
 1735  2                              *(res_data+11) = 0x00;  
 1736  2                  break;
 1737  2                              
 1738  2              default:
 1739  2                  break;
 1740  2          }
 1741  1      }
 1742         
 1743         static INT8U uVoltageLowTimeoutCnt = 0u;
 1744         static INT8U uVoltageLowRecoverCnt = 0u;
 1745         static BOOLEAN bVehiclePowerVoltageLow = FALSE;
 1746         /*****************************************************************************************
 1747         *  Name        : CanDiagApp_DTC_VehiclePowerVoltageLow
 1748         *  Description : vehicle power voltage low
 1749                          operate condition: 1)ECU power on 2)KL30 node: battery connect 3)KL15 node: IGN ON
 1750                          DTC set condition: power voltage lower than 9V continue 1s
 1751                          DTC resume condition: power voltage higher than 9.5V continue 1s
 1752         *  Parameter   : none
 1753         *  Returns     : none 
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 30  

 1754         *****************************************************************************************/
 1755         void CanDiagApp_DTC_VehiclePowerVoltageLow(void)
 1756         {
 1757  1              static INT16U uVehicleVoltage = 0u;
 1758  1              const T_ADC_APP *ptr = AdcApp_SampleData();
 1759  1      
 1760  1              if (FALSE == bVehiclePowerVoltageLow)
 1761  1              {
 1762  2                      if (ptr->vehiclePowerVoltage < POWER_9V_VOLTAGE)
 1763  2                      {
 1764  3                              uVoltageLowRecoverCnt = 0u;
 1765  3      
 1766  3                              uVoltageLowTimeoutCnt++;
 1767  3                              if (uVoltageLowTimeoutCnt >= DELAY_1s)          
 1768  3                              {
 1769  4                                      uVoltageLowTimeoutCnt = DELAY_1s;
 1770  4                                      bVehiclePowerVoltageLow = TRUE;
 1771  4      
 1772  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1773  4                          {
 1774  5                                              DescMgr_DtcStatusDataReport(DTC_VEHICLE_POWER_VOLTAGE_LOW, DTC_TEST_FAILED);
 1775  5                                      }               
 1776  4                              }                       
 1777  3                      }
 1778  2                      else
 1779  2                      {
 1780  3                              uVoltageLowTimeoutCnt = 0u;
 1781  3                              uVoltageLowRecoverCnt = 0u;
 1782  3                              bVehiclePowerVoltageLow = FALSE;
 1783  3                      }
 1784  2              }
 1785  1              else
 1786  1              {
 1787  2                      if (ptr->vehiclePowerVoltage >= POWER_9_5V_VOLTAGE)
 1788  2                      {               
 1789  3                              uVoltageLowTimeoutCnt = 0u;
 1790  3      
 1791  3                              uVoltageLowRecoverCnt++;
 1792  3                              if (uVoltageLowRecoverCnt >= DELAY_1s)
 1793  3                      {
 1794  4                                      uVoltageLowRecoverCnt = DELAY_1s;
 1795  4                                      bVehiclePowerVoltageLow = FALSE;
 1796  4      
 1797  4                                      if (TRUE == DescMgr_CanDiagDtcRecordBodyEnableCheck())
 1798  4                          {
 1799  5                                              DescMgr_DtcStatusDataReport(DTC_VEHICLE_POWER_VOLTAGE_LOW, DTC_TEST_PASSED);
 1800  5                          }
 1801  4                      }                       
 1802  3                      }
 1803  2                      else
 1804  2                      {
 1805  3                              uVoltageLowTimeoutCnt = 0u;
 1806  3                              uVoltageLowRecoverCnt = 0u;
 1807  3                              bVehiclePowerVoltageLow = TRUE;
 1808  3                      }
 1809  2              }
 1810  1      }
 1811         
 1812         void CanDescDtc_TaskEntry(void)
 1813         { 
 1814  1          /* Diagnosis init, dtc record enable delay */
 1815  1          if(can_diag_init_delay_timer > CAN_DIAG_INIT_DELAY_TIMEOUT)
C166 COMPILER V7.57.0, DESC_MGR                                                            11/13/2020 15:09:31 PAGE 31  

 1816  1          {
 1817  2              can_diag_init_delay_timer--;
 1818  2      
 1819  2              if(can_diag_init_delay_timer == CAN_DIAG_INIT_DELAY_TIMEOUT)
 1820  2              {
 1821  3                  /* Adjust dtc record enable mask */
 1822  3                  DescMgr_CanDigDtcRecordEnableAdjust();
 1823  3              }
 1824  2          }
 1825  1      
 1826  1          DescMgr_CanDiagDtcEepromHandle();
 1827  1      
 1828  1      #if 0   
                  can_desc_delay_service_monitor();
                  Get_Software_Version_Status();
                  EEP_Write_Status_Monitor();
                  EEP_Status_Monitor();
              #endif
 1834  1      
 1835  1              CanDiagApp_DTC_VehiclePowerVoltageLow();
 1836  1      }
 1837         
 1838         /* _END_OF_DESC_DTC_MGR_ */


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        4734     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          23     --------
  FAR-DATA SIZE    =         728     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =         886     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
