C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 1   


C166 COMPILER V7.57.0, COMPILATION OF MODULE BOOSTER
OBJECT MODULE PLACED IN .\Obj\booster.obj
COMPILER INVOKED BY: C:\Keil_v5\C166\BIN\C166.EXE src\app\alogrithm\booster.c MODV2 LARGE BROWSE INCDIR(.\src;.\src\bsw;
                    -.\src\driver;.\src\interaction;.\src\app\adc;.\src\app\alogrithm;.\src\app\can;.\src\app\ccp;.\src\app\diagnostic;.\src\
                    -app\mode control;.\src\app\task;.\src\app\Fun;.\src\app\rtos;.\src\bsw\can;.\src\bsw\desc;.\src\bsw\nm;.\src\app\time me
                    -asure;.\src\app\rte) MODV2 DEBUG PRINT(.\Lst\booster.lst) OBJECT(.\Obj\booster.obj) 

 stmt lvl     source

    1         /***********************************************************************
    2         *   Copyright (C) JWD Automotive Co., Ltd.                                                  
    3         * 
    4         *               All Rights Reserved.                                                                
    5         *   Department : iCAS SW                                                                                            
    6         *   AUTHOR         :                                                                                                              
    7         ************************************************************************
    8         * Object        : 
    9         * Module        : booster.c
   10         * Instance      : 
   11         * Description   : booster brake algorithm
   12         *-----------------------------------------------------------------------
   13         * Version: v0.1
   14         * Date   : Dec 7,2019 
   15         * Author : Gao zhengzhong
   16         ***********************************************************************/
   17         /*-History--------------------------------------------------------------
   18         * Version    Date           Name            Changes and comments
   19         ------------------------------------------------------------------------
   20         * 0.1          Dec 7,2019     Gao Zhengzhong  Initial version
   21         *=====================================================================*/
   22         
   23         #include <stdlib.h>
   24         #include <string.h>
   25         
   26         #define BOOSTER_GLOBALS
   27         #include "booster.h"
   28         #include "booster_Cfg.h"
   29         
   30         #include "adc_sample.h"
   31         #include "rte.h"
   32         #include "energy_recovery.h"
   33         #include "wire_control.h"
   34         #include "pid.h"
   35         #include "FLTD.h"
   36         #include "pwm.h"
   37         
   38         
   39         
   40         /**** Definition of variables ****/
   41         static T_BOOSTER tBooster = {0};
   42         INT16S pedalRateAccumulate = 0;
   43         static BOOLEAN g_energyRecoverHitFlag = FALSE;
   44         static INT16U timeDetectCount = 0;
   45         
   46         /**** Declaration of functions ****/
   47         static void Booster_systemModeJudge(void);
   48         static void Booster_pressureSensorNormalJudge(void);
   49         static void Booster_OnlyLocationLoop(void);
   50         static void Booster_OnlyCurrentLoop(void);
   51         static void Booster_LocationAndCurrentLoop(void);
   52         
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 2   

   53         static INT16U Booster_calcCylinderObjLocationFromPedal(INT16U pedalLoc);
   54         INT16U Booster_calcForwardPwm(INT16S objCurrent);
   55         static INT16U Booster_calcMotorObjCurrentFromPedal(INT16U pedalLoc);
   56         static void Booster_PedalLocationRateCalculation(void);
   57         static void Booster_CylinderLocationRateCalculation(void);
   58         static INT16U Booster_CurrentCompensation(INT16U calcCurrent);
   59         static void Booster_ClosedLoopControl(void);
   60         
   61         static void Booster_JudgeEnergyRecoveryCondition(void);
   62         static void Booster_BrakeStatusMashine(void);
   63         static void Booster_BrakeForceDistribution(void);
   64         static void Booster_mcuObjTorqueCheck(INT16S* torque);
   65         static INT16U Booster_CylinderMinLocationCheck(void);
   66         
   67         static INT16U Booster_CalculateMixBrakeCylinderLocationFromTorque(INT16S objTorque);
   68         static INT16U Booster_RegenerationBrakeQuitSpeed(INT16S torque);
   69         static INT16S Booster_CalculateBrakeTorque(INT16U objLoc);
   70         static void Booster_PedalLocationPredict(void);
   71         
   72         
   73         
   74         /***********************************************************************
   75         *  Name        : Booster_Init
   76         *  Description : After power on, initiliaze booster alogrithm variable
   77         *  Parameter   : None
   78         *  Returns     : None
   79         ***********************************************************************/
   80         void Booster_Init(void)
   81         {
   82  1              memset(&tBooster, 0, sizeof(tBooster));
   83  1              
   84  1              tBooster.temperatureProtectCoeff = PROTECT_INIT_COEFF;
   85  1              tBooster.currentDampCoeff = PROTECT_INIT_COEFF;
   86  1              tBooster.cylinderDampCoeff = PROTECT_INIT_COEFF;
   87  1              
   88  1              tBooster.pedalToCylinderArrayLength = sizeof(pedal_To_cylinder[0]) / sizeof(INT16U);
   89  1              tBooster.cylinderToCurrentArrayLength = sizeof(cylinder_To_current[0]) / sizeof(INT16U);
   90  1              tBooster.currentToPwmArrayLength = sizeof(current_To_pwm[0]) / sizeof(INT16U);
   91  1              tBooster.pedalToCurrentArrayLength = sizeof(pedal_To_current[0]) / sizeof(INT16U);
   92  1      }
   93         
   94         /***********************************************************************
   95         *  Name        : Booster_DeInit
   96         *  Description : During running, need initilize booster algorithm variable
   97         *  Parameter   : None
   98         *  Returns     : None
   99         ***********************************************************************/
  100         void Booster_DeInit(void)
  101         {
  102  1              return;
  103  1      }
  104         
  105         /***********************************************************************
  106         *  Name        : Booster_Algorithm
  107         *  Description : Booster control algorithm
  108         *  Parameter   : None
  109         *  Returns     : None
  110         ***********************************************************************/
  111         void Booster_Algorithm(void)
  112         {
  113  1              const FLTD_faultActType* FLTDAct_ptr = FLTD_FltActFlgData();
  114  1              const T_ADC_APP *adcApp_ptr = AdcApp_SampleData();      
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 3   

  115  1              
  116  1              tBooster.brakePedalLocation = adcApp_ptr->brakePedalLocation1;
  117  1              tBooster.mainCylinderLocation = adcApp_ptr->mainCylinderLocation1;
  118  1              tBooster.motorCurrent = adcApp_ptr->brakeMotorCurrent;
  119  1              tBooster.cylinderPressure = adcApp_ptr->mainCylinderPressure;
  120  1              tBooster.environmentTemperature = adcApp_ptr->environmentTemperature;
  121  1              
  122  1      #if (ENABLE == FUNC_BRAKE_ENERGY_RECOVERY)
  123  1              tBooster.mcuMotorMaxiumTorque = MCU_MotToqLmt * 0.5 - 4000;
  124  1              tBooster.mcuMotorActualTorque = MCU_MotActuToq * 0.5 - 4000;
  125  1      #endif
  126  1              
  127  1              Booster_systemModeJudge();
  128  1                      
  129  1              Booster_PedalLocationRateCalculation();
  130  1              Booster_CylinderLocationRateCalculation();
  131  1              Booster_CalculateTemperatureProtectCoeff();
  132  1              Booster_CalcTimeOutProtectCoef();
  133  1              Booster_PedalLocationPredict();
  134  1              Booster_BrakeStatusMashine();
  135  1              
  136  1              WireControl_Algorithm();
  137  1              Booster_pressureSensorNormalJudge();
  138  1              
  139  1              if((TRUE == FLTDAct_ptr->fixedDecelerationFlg) || (3 == gRTE_pidTypeSw))
  140  1              {
  141  2                      gRTE_pidTypeSts = 3;
  142  2                      if(BoosterBrakeMode == BrakeSysMode)
  143  2                      {
  144  3                              if(TRUE == g_inBrakeSwValidSts)
  145  3                              {
  146  4                                      Pwm_Control(700);
  147  4                              }
  148  3                              else
  149  3                              {
  150  4                                      Pwm_Control(0);
  151  4                              }
  152  3                      }
  153  2                      else if(WireCtrlBrakeMode == BrakeSysMode)
  154  2                      {
  155  3                              if((TRUE == g_wireControlEnFlag) && (g_wireControlObjPressure > 0))
  156  3                              {
  157  4                                      Pwm_Control(700);
  158  4                              }
  159  3                              else
  160  3                              {
  161  4                                      Pwm_Control(0);
  162  4                              }
  163  3                      }
  164  2              }
  165  1      #if 1
  166  1              else
  167  1              {
  168  2                      gRTE_pidTypeSts = 2;
  169  2                      Booster_OnlyCurrentLoop();
  170  2                      WireControl_CurrentToPressure();
  171  2              }
  172  1      #else
                      else if((TRUE == FLTDAct_ptr->brakingDependsOnCurrentFlg) || (2 == gRTE_pidTypeSw) || (TRUE == g_cylinder
             -ExhaustEnFlag))
                      {
                              gRTE_pidTypeSts = 2;
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 4   

                              Booster_OnlyCurrentLoop();
                              WireControl_CurrentToPressure();
                      }
                      else if((TRUE == FLTDAct_ptr->brakingDependsOnCylinderFlg) ||(1 == gRTE_pidTypeSw))
                      {
                              gRTE_pidTypeSts = 1;
                              Booster_OnlyLocationLoop();
                              WireControl_CylinderToPressure();
                      }
                      else if(0 == gRTE_pidTypeSw)
                      {
                              gRTE_pidTypeSts = 0;
                              Booster_LocationAndCurrentLoop();
                              WireControl_CylinderToPressure();
                      }
                      
              #endif
  193  1              
  194  1      }
  195         
  196         /***********************************************************************
  197         *  Name        : Booster_systemModeJudge
  198         *  Description : booster system mode judge. 0: booster mode ; 1: wireControl mode 
  199         *  Parameter   : None
  200         *  Returns     : None
  201         ***********************************************************************/
  202         static void Booster_systemModeJudge(void)
  203         {
  204  1              static INT8U brakeSysModeLast = 0;
  205  1              const FLTD_faultActType* FLTDAct_ptr = FLTD_FltActFlgData();
  206  1              const T_ADC_APP *adcApp_ptr = AdcApp_SampleData();      
  207  1              
  208  1              /*---------------Ì¤°å¸ÉÔ¤µÄÅÐ¶ÏÂß¼­------------------------*/
  209  1      #if (0 != BRAKE_SIGNAL_SOURCE)
                      if((TRUE == g_wireControlEnFlag) || (TRUE == g_cylinderExhaustEnFlag))
                      {
                              if((TRUE == g_inBrakeSwValidSts)
                                      || ((FALSE == FLTDAct_ptr->fixedDecelerationFlg) && (adcApp_ptr->brakePedalLocation1 > BRAKE_PEDAL_LOCA
             -TION_VALID)))
                              {
                                      BrakeSysMode = BoosterBrakeMode;
                                      
                                      if(brakeSysModeLast != BrakeSysMode)
                                      {
                                              g_pedalInterveneFlag = TRUE;
                                      }
                              }
                              else
                              {
                                      BrakeSysMode = WireCtrlBrakeMode;
                              }       
                      }
                      else
                      {
                              BrakeSysMode = BoosterBrakeMode;
                      }
                      brakeSysModeLast = BrakeSysMode;
              #else
  233  1              BrakeSysMode = WireCtrlBrakeMode;
  234  1      #endif
  235  1      }
  236         
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 5   

  237         
  238         /***********************************************************************
  239         *  Name        : Booster_pressureSensorNormalJudge
  240         *  Description : pressure sensor fault judge
  241         *  Parameter   : None
  242         *  Returns     : None
  243         ***********************************************************************/
  244         static void Booster_pressureSensorNormalJudge(void)
  245         {
  246  1              static INT16U faultTimeCnt = 0;
  247  1              static INT16U recoverTimeCnt = 0;
  248  1              static BOOLEAN pressureFaultFlag = TRUE;
  249  1              const T_PID* ptr_Pid = Pid_AlogrithmData();
  250  1              
  251  1              if((FALSE == gRTE_wireControlPressureLoopFlag))
  252  1              {
  253  2                      if( (g_wireControlActualPressure >= 10) && (g_wireControlObjPressure >= 10) ) // added to avoid motor re
             -versal motion, for the case of brake system pre-pressed
  254  2                      {
  255  3                              if(recoverTimeCnt < 200)
  256  3                              {
  257  4                                      recoverTimeCnt++;
  258  4                              }
  259  3                              else
  260  3                              {
  261  4                                      recoverTimeCnt = 0;
  262  4                                      pressureFaultFlag = FALSE;
  263  4                              }
  264  3                      }
  265  2                      else
  266  2                      {
  267  3                              recoverTimeCnt = 0;
  268  3                      }
  269  2              }
  270  1              else
  271  1              {
  272  2                      if(g_wireControlObjPressure < 10)
  273  2                      {
  274  3                              faultTimeCnt = 0;
  275  3                              pressureFaultFlag = TRUE;
  276  3                      }
  277  2                      
  278  2                      if(ABSOLUTE(ptr_Pid->pressure.ObjectValue, g_wireControlActualPressure) >= 30) //The error exceeds 3Mpa
  279  2                      {
  280  3                              if(faultTimeCnt < 350)
  281  3                              {
  282  4                                      faultTimeCnt++;
  283  4                              }
  284  3                              else
  285  3                              {
  286  4                                      faultTimeCnt = 0;
  287  4                                      pressureFaultFlag = TRUE;
  288  4                              }
  289  3                      }
  290  2                      else
  291  2                      {
  292  3                              faultTimeCnt = 0;
  293  3                      }
  294  2              }
  295  1              
  296  1              if((FALSE == g_PressureSensorFaultFlag) && (FALSE == pressureFaultFlag))
  297  1              {
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 6   

  298  2                      gRTE_wireControlPressureLoopFlag = TRUE;
  299  2              }
  300  1              else
  301  1              {
  302  2                      gRTE_wireControlPressureLoopFlag = FALSE;
  303  2              }
  304  1      }
  305         
  306         
  307         /***********************************************************************
  308         *  Name        : Booster_LocationAndCurrentLoop
  309         *  Description : Booster control algorithm
  310         *  Parameter   : None
  311         *  Returns     : None
  312         ***********************************************************************/
  313         static void Booster_LocationAndCurrentLoop(void)
  314         {
  315  1              INT32U tempCylinderObjLoc = 0;
  316  1              INT32U tempObjPressure = 0;
  317  1              const T_WIRE_CONTROL* ptr_WireControl = WireControl_AlogrithmData();
  318  1              
  319  1              /* Single - location ring differentiates assisted braking and wire - controlled braking.
  320  1                      The source of the target location is different */
  321  1              if(BoosterBrakeMode == BrakeSysMode)
  322  1              {
  323  2                      tempCylinderObjLoc = Booster_calcCylinderObjLocationFromPedal(tBooster.brakePedalLocation);
  324  2              }
  325  1              else if(WireCtrlBrakeMode == BrakeSysMode)
  326  1              {
  327  2                      if(FALSE == gRTE_wireControlPressureLoopFlag)
  328  2                      {
  329  3                              tempCylinderObjLoc = WireControl_PressureToCylinder(ptr_WireControl->cylinderObjPressure);
  330  3                      }
  331  2                      else
  332  2                      {
  333  3                              /* Pressure ring protection */
  334  3                              tempObjPressure = ptr_WireControl->cylinderObjPressure;
  335  3                              tBooster.protectCoeff = MIN(tBooster.cylinderDampCoeff, tBooster.temperatureProtectCoeff);
  336  3                              tempObjPressure = tempObjPressure * tBooster.protectCoeff / PROTECT_INIT_COEFF;
  337  3                              if((tBooster.protectCoeff < PROTECT_INIT_COEFF) 
  338  3                                      && (PROTECT_INIT_COEFF == tBooster.temperatureProtectCoeff)
  339  3                                      && (tempObjPressure < gRTE_dampMinPressure))
  340  3                              {
  341  4                                      tempObjPressure = gRTE_dampMinPressure;
  342  4                              }
  343  3                              (void)Pid_PressureClosedLoopControl(tempObjPressure);
*** WARNING C192 IN LINE 343 OF src\app\alogrithm\booster.c: 'parameter 1': value truncated
  344  3                              return;
  345  3                      }
  346  2              }
  347  1              
  348  1              /*---------- Cylinder Damping Protection ----------------*/
  349  1              tBooster.protectCoeff = MIN(tBooster.cylinderDampCoeff, tBooster.temperatureProtectCoeff);
  350  1              tempCylinderObjLoc = tempCylinderObjLoc * tBooster.protectCoeff / PROTECT_INIT_COEFF;
  351  1              if((tBooster.protectCoeff < PROTECT_INIT_COEFF) 
  352  1                      && (PROTECT_INIT_COEFF == tBooster.temperatureProtectCoeff)
  353  1                      && (tempCylinderObjLoc < gRTE_dampMinCylinder))
  354  1              {
  355  2                      tBooster.mainCylinderObjLocation = gRTE_dampMinCylinder;
  356  2              }
  357  1              else
  358  1              {
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 7   

  359  2                      tBooster.mainCylinderObjLocation = (INT16U)tempCylinderObjLoc;
  360  2              }
  361  1              
  362  1              
  363  1              if(BoosterBrakeMode == BrakeSysMode)
  364  1              {
  365  2                      Booster_BrakeForceDistribution();
  366  2              }
  367  1              Booster_ClosedLoopControl();
  368  1      }
  369         
  370         /***********************************************************************
  371         *  Name        : Booster_OnlyLocationLoop
  372         *  Description : Booster control algorithm
  373         *  Parameter   : None
  374         *  Returns     : None
  375         ***********************************************************************/
  376         static void Booster_OnlyLocationLoop(void)
  377         {
  378  1              INT32U tempCylinderObjLoc = 0;
  379  1              INT32U tempObjPressure = 0;
  380  1              const T_WIRE_CONTROL* ptr_WireControl = WireControl_AlogrithmData();
  381  1              
  382  1              /* Single - location ring differentiates assisted braking and wire - controlled braking.
  383  1                      The source of the target location is different */
  384  1              if(BoosterBrakeMode == BrakeSysMode)
  385  1              {
  386  2                      tempCylinderObjLoc = Booster_calcCylinderObjLocationFromPedal(tBooster.brakePedalLocation);
  387  2              }
  388  1              else if(WireCtrlBrakeMode == BrakeSysMode)
  389  1              {
  390  2                      if(FALSE == gRTE_wireControlPressureLoopFlag)
  391  2                      {
  392  3                              tempCylinderObjLoc = WireControl_PressureToCylinder(ptr_WireControl->cylinderObjPressure);
  393  3                      }
  394  2                      else
  395  2                      {
  396  3                              /* Pressure ring protection */
  397  3                              tempObjPressure = ptr_WireControl->cylinderObjPressure;
  398  3                              tBooster.protectCoeff = MIN(tBooster.cylinderDampCoeff, tBooster.temperatureProtectCoeff);
  399  3                              tempObjPressure = tempObjPressure * tBooster.protectCoeff / PROTECT_INIT_COEFF;
  400  3                              if((tBooster.protectCoeff < PROTECT_INIT_COEFF) 
  401  3                                      && (PROTECT_INIT_COEFF == tBooster.temperatureProtectCoeff)
  402  3                                      && (tempObjPressure < gRTE_dampMinPressure))
  403  3                              {
  404  4                                      tempObjPressure = gRTE_dampMinPressure;
  405  4                              }
  406  3                              (void)Pid_PressureClosedLoopControl(tempObjPressure);
*** WARNING C192 IN LINE 406 OF src\app\alogrithm\booster.c: 'parameter 1': value truncated
  407  3                              return;
  408  3                      }
  409  2              }
  410  1              
  411  1              /*---------- Cylinder Damping Protection ----------------*/
  412  1              tBooster.protectCoeff = MIN(tBooster.cylinderDampCoeff, tBooster.temperatureProtectCoeff);
  413  1              tempCylinderObjLoc = tempCylinderObjLoc * tBooster.protectCoeff / PROTECT_INIT_COEFF;
  414  1              if((tBooster.protectCoeff < PROTECT_INIT_COEFF) 
  415  1                      && (PROTECT_INIT_COEFF == tBooster.temperatureProtectCoeff)
  416  1                      && (tempCylinderObjLoc < gRTE_dampMinCylinder))
  417  1              {
  418  2                      tBooster.mainCylinderObjLocation = gRTE_dampMinCylinder;
  419  2              }
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 8   

  420  1              else
  421  1              {
  422  2                      tBooster.mainCylinderObjLocation = (INT16U)tempCylinderObjLoc;
  423  2              }
  424  1              
  425  1              (void)Pid_OnlyLocationClosedLoopControl(tBooster.mainCylinderObjLocation);
  426  1      }
  427         
  428         
  429         /***********************************************************************
  430         *  Name        : Booster_OnlyCurrentLoop
  431         *  Description : Booster control algorithm
  432         *  Parameter   : None
  433         *  Returns     : None
  434         ***********************************************************************/
  435         static void Booster_OnlyCurrentLoop(void)
  436         {
  437  1              INT16U feedForwardPwm = 0;
  438  1              INT16S feedBackPwm = 0;
  439  1              INT32U tempObjCurrent = 0;      
  440  1              INT32U tempObjPressure = 0;
  441  1              const T_WIRE_CONTROL* ptr_WireControl = WireControl_AlogrithmData();
  442  1              
  443  1              /* Single - current ring differentiates assisted braking and wire - controlled braking.
  444  1                      The source of the target current is different */
  445  1              if(BoosterBrakeMode == BrakeSysMode)
  446  1              {
  447  2                      tempObjCurrent = Booster_calcMotorObjCurrentFromPedal(tBooster.brakePedalLocation);
  448  2              }
  449  1              else if(WireCtrlBrakeMode == BrakeSysMode)
  450  1              {
  451  2                      if((FALSE == gRTE_wireControlPressureLoopFlag) || (TRUE == g_cylinderExhaustEnFlag)) //Exhaust mode also
             - uses current PID
  452  2                      {
  453  3                              tempObjCurrent = WireControl_PressureToCurrent(ptr_WireControl->cylinderObjPressure);
  454  3                      }
  455  2                      else
  456  2                      {
  457  3                              /* Pressure ring protection */
  458  3                              tempObjPressure = ptr_WireControl->cylinderObjPressure;
  459  3                              tBooster.protectCoeff = MIN(tBooster.cylinderDampCoeff, tBooster.temperatureProtectCoeff);
  460  3                              tempObjPressure = tempObjPressure * tBooster.protectCoeff / PROTECT_INIT_COEFF;
  461  3                              if((tBooster.protectCoeff < PROTECT_INIT_COEFF) 
  462  3                                      && (PROTECT_INIT_COEFF == tBooster.temperatureProtectCoeff)
  463  3                                      && (tempObjPressure < gRTE_dampMinPressure))
  464  3                              {
  465  4                                      tempObjPressure = gRTE_dampMinPressure;
  466  4                              }
  467  3                              (void)Pid_PressureClosedLoopControl(tempObjPressure);
*** WARNING C192 IN LINE 467 OF src\app\alogrithm\booster.c: 'parameter 1': value truncated
  468  3                              return;
  469  3                      }
  470  2              }
  471  1              
  472  1              /*---------- Current Damping Protection ----------------*/
  473  1              tBooster.protectCoeff = MIN(tBooster.currentDampCoeff, tBooster.temperatureProtectCoeff);
  474  1              tempObjCurrent = tempObjCurrent * tBooster.protectCoeff / PROTECT_INIT_COEFF;
  475  1              if((tBooster.protectCoeff < PROTECT_INIT_COEFF) 
  476  1                      && (PROTECT_INIT_COEFF == tBooster.temperatureProtectCoeff)
  477  1                      && (tempObjCurrent < gRTE_dampMinCurrent))
  478  1              {
  479  2                      tBooster.brakeMotorObjCurrent = gRTE_dampMinCurrent;
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 9   

  480  2              }
  481  1              else
  482  1              {
  483  2                      tBooster.brakeMotorObjCurrent = (INT16U)tempObjCurrent;
  484  2              }
  485  1      
  486  1              
  487  1              feedForwardPwm = Booster_calcForwardPwm(tBooster.brakeMotorObjCurrent);
  488  1              feedBackPwm = Pid_CurrentClosedLoopControl(tBooster.brakeMotorObjCurrent);
  489  1              tBooster.calcForwardPwm = feedForwardPwm;
  490  1              
  491  1              Pwm_Control(feedForwardPwm + feedBackPwm);
  492  1      }
  493         
  494         /***********************************************************************
  495         *  Name        : Booster_CalculateTemperatureProtectCoeff
  496         *  Description : Detect temperature to calculate setting main cylinder curve
  497         *                temperature protect compensation coeff, decline output PWM
  498         *                to protect brake motor.
  499         *  Parameter   : None
  500         *  Returns     : None
  501         ***********************************************************************/
  502         void Booster_CalculateTemperatureProtectCoeff(void)
  503         {
  504  1              static INT16U tempDetectCount = 0;
  505  1              static INT16U tempProtectCount = 0;
  506  1              static BOOLEAN highTemperatureFlag = FALSE;
  507  1              const T_ADC_APP *ptr_adcApp = AdcApp_SampleData();
  508  1      
  509  1              if (FALSE == highTemperatureFlag)
  510  1              {
  511  2                      /* Judge environment temperature higher than setting protect trigger condition,
  512  2                       * set compensation coeff to decline output to protect brake motor. */
  513  2                      if (ptr_adcApp->environmentTemperature >= TEMPERATURE_PROTECT_TRIGGER)
  514  2                      {
  515  3                              tempDetectCount++;
  516  3                              if (tempDetectCount > TEMPERATURE_PROTECT_DETECT_TIME)
  517  3                              {
  518  4                                      tempDetectCount = 0;
  519  4                                      highTemperatureFlag = TRUE;
  520  4                              }
  521  3                      }
  522  2                      else
  523  2                      {
  524  3                              tempProtectCount++;
  525  3                              if (tempProtectCount > TEMPERATURE_PROTECT_EXCUTE_TIME)
  526  3                              {
  527  4                                      tempProtectCount = 0;   
  528  4                                      if (tBooster.temperatureProtectCoeff < PROTECT_INIT_COEFF)
  529  4                                      {
  530  5                                              tBooster.temperatureProtectCoeff++;
  531  5                                      }
  532  4                              }
  533  3                      }
  534  2              }
  535  1              else
  536  1              {
  537  2                      /* Judge environment temperature lower than release protect trigger condition,
  538  2                       * resume initialize coeff to make brake motor normal output. If keeping temperature
  539  2                       * protect more than timeout, further reduce output in cycle. */
  540  2                      if (ptr_adcApp->environmentTemperature <= TEMPERATURE_PROTECT_RELEASE)
  541  2                      {
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 10  

  542  3                              tempDetectCount++;
  543  3                              if (tempDetectCount > TEMPERATURE_PROTECT_DETECT_TIME)
  544  3                              {
  545  4                                      tempDetectCount = 0;
  546  4                                      highTemperatureFlag = FALSE;
  547  4                              }
  548  3                      }
  549  2                      else
  550  2                      {
  551  3                              tempProtectCount++;
  552  3                              if (tempProtectCount > TEMPERATURE_PROTECT_EXCUTE_TIME)
  553  3                              {
  554  4                                      tempProtectCount = 0;   
  555  4                                      if (tBooster.temperatureProtectCoeff > TEMPERATURE_PROTECT_SET_COEFF)
  556  4                                      {
  557  5                                              tBooster.temperatureProtectCoeff--;
  558  5                                      }
  559  4                              }
  560  3                      }
  561  2              }
  562  1      }
  563         
  564         
  565         /***********************************************************************
  566         *  Name        : Booster_CalcTimeOutProtectCoef
  567         *  Description : The system PWM output time exceeds a certain value, reduces the output, protects the hard
             -ware 
  568         *  Parameter   : None
  569         *  Returns     : None
  570         ***********************************************************************/
  571         void Booster_CalcTimeOutProtectCoef(void)
  572         {
  573  1              static INT16U timeProtectCount = 0;
  574  1              static BOOLEAN timeOutFlag = FALSE;
  575  1              static INT8U pedalReturnTimeCnt = 0;
  576  1              static INT8U g_wireControlObjPressureLast = 0;
  577  1              const T_PWM* Pwm_ptr = Pwm_ControlData();
  578  1              const T_ADC_APP *adcApp_ptr = AdcApp_SampleData();      
  579  1              const FLTD_faultActType* FLTDAct_ptr = FLTD_FltActFlgData();
  580  1              
  581  1              /* reset time */
  582  1              if(BoosterBrakeMode == BrakeSysMode)
  583  1              {
  584  2                      if((FALSE == g_inBrakeSwValidSts)
  585  2                              || ((FALSE == FLTDAct_ptr->fixedDecelerationFlg) && (adcApp_ptr->brakePedalLocation1 < BRAKE_PEDAL_LOCA
             -TION_VALID)))
  586  2                      {
  587  3                              timeDetectCount = 0;
  588  3                      }
  589  2              }
  590  1              else if(WireCtrlBrakeMode == BrakeSysMode)
  591  1              {
  592  2                      if(0 == g_wireControlObjPressure)
  593  2                      //if(g_wireControlObjPressure < (gRTE_dampMinPressure / 100 - 5))
  594  2                      {
  595  3                              timeDetectCount = 0;
  596  3                      }
  597  2              }
  598  1              
  599  1              if(FALSE == timeOutFlag)
  600  1              {
  601  2                      pedalReturnTimeCnt = 0;
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 11  

  602  2                      if((Pwm_ptr->motorCtrl - PWM_AMPLITUDE_DEFAULT) >= gRTE_pwmProtectThreshold)
  603  2                      {
  604  3                              timeDetectCount++;
  605  3                              if(timeDetectCount > PWM_TIMEOUT_PROTECT_DETECT_TIME)
  606  3                              {
  607  4                                      timeDetectCount = 0;
  608  4                                      timeOutFlag = TRUE;
  609  4                              }
  610  3                      }
  611  2                      else
  612  2                      {
  613  3                              timeProtectCount++;
  614  3                              if(timeProtectCount > PWM_TIMEOUT_PROTECT_EXCUTE_TIME)
  615  3                              {
  616  4                                      timeProtectCount = 0;
  617  4                                      if (tBooster.currentDampCoeff < PROTECT_INIT_COEFF)
  618  4                                      {
  619  5                                              tBooster.currentDampCoeff++;
  620  5                                      }
  621  4                                      if (tBooster.cylinderDampCoeff < PROTECT_INIT_COEFF)
  622  4                                      {
  623  5                                              tBooster.cylinderDampCoeff++;
  624  5                                      }                                                       
  625  4                              }
  626  3                      }
  627  2              }
  628  1              else
  629  1              {
  630  2                      if(BoosterBrakeMode == BrakeSysMode)
  631  2                      {
  632  3                              if((FALSE == g_inBrakeSwValidSts) || (tBooster.pedalRate < -80) || (TRUE == g_pedalInterveneFlag))
  633  3                              {
  634  4                                      if(pedalReturnTimeCnt > 10)
  635  4                                      {
  636  5                                              timeOutFlag = FALSE;
  637  5                                              timeDetectCount = 0;
  638  5                                      
  639  5                                              g_pedalInterveneFlag = FALSE;
  640  5                                              tBooster.currentDampCoeff = PROTECT_INIT_COEFF;
  641  5                                              tBooster.cylinderDampCoeff = PROTECT_INIT_COEFF;
  642  5                                      }
  643  4                                      else
  644  4                                      {
  645  5                                              pedalReturnTimeCnt++;
  646  5                                      }
  647  4                              }
  648  3                      }
  649  2                      else if(WireCtrlBrakeMode == BrakeSysMode)
  650  2                      {
  651  3                              //if((0 == g_wireControlObjPressure) && (0 != g_wireControlObjPressureLast))
  652  3                              if(g_wireControlObjPressure < (gRTE_dampMinPressure / 100 - 5))
  653  3                              {
  654  4                                      timeOutFlag = FALSE;
  655  4                                      timeDetectCount = 0;
  656  4                                      
  657  4                                      tBooster.currentDampCoeff = PROTECT_INIT_COEFF;
  658  4                                      tBooster.cylinderDampCoeff = PROTECT_INIT_COEFF;
  659  4                              }
  660  3                              
  661  3                              g_wireControlObjPressureLast = g_wireControlObjPressure;
  662  3                      }
  663  2      
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 12  

  664  2                      
  665  2                      timeProtectCount++;
  666  2                      if(timeProtectCount > PWM_TIMEOUT_PROTECT_EXCUTE_TIME)
  667  2                      {
  668  3                              timeProtectCount = 0;
  669  3      
  670  3                              if (tBooster.currentDampCoeff > CURRENT_PROTECT_SET_COEFF)
  671  3                              {
  672  4                                      tBooster.currentDampCoeff--;
  673  4                              }
  674  3                              if (tBooster.cylinderDampCoeff > CYLINDER_PROTECT_SET_COEFF)
  675  3                              {
  676  4                                      tBooster.cylinderDampCoeff--;
  677  4                              }
  678  3                      }
  679  2              }                  
  680  1      }
  681         
  682         
  683         /***********************************************************************
  684         *  Name        : Booster_calcCylinderObjLocationFromPedal
  685         *  Description : According to the brake pedal location to calculate the main cylinder object location.
  686         *  Parameter   : pedal Location
  687         *  Returns     : None
  688         ***********************************************************************/
  689         static INT16U Booster_calcCylinderObjLocationFromPedal(INT16U pedalLoc)
  690         {
  691  1              INT16U tempMainCylinderObjLoc = 0;
  692  1              
  693  1              tempMainCylinderObjLoc = lookupTable_1D(pedalLoc, pedal_To_cylinder[0], pedal_To_cylinder[1], tBooster.pe
             -dalToCylinderArrayLength - 1);
  694  1              
  695  1              return tempMainCylinderObjLoc;
  696  1      }
  697         
  698         
  699         /***********************************************************************
  700         *  Name        : Booster_calcForwardCurrent
  701         *  Description : The feedforward current is calculated according to the target stroke of the master cylind
             -er and pedal pedal speed
  702         *  Parameter   : None
  703         *  Returns     : feed Forward Current
  704         ***********************************************************************/
  705         INT16U Booster_calcForwardCurrent(INT16U objLoc)
  706         {
  707  1              INT16S compCurrent = 0;
  708  1              INT16U feedForwardCurrent = 0;
  709  1      
  710  1              feedForwardCurrent = lookupTable_1D(objLoc, cylinder_To_current[0], cylinder_To_current[1], tBooster.cyli
             -nderToCurrentArrayLength - 1);
  711  1      
  712  1              /* Calculate the compensation current based on the given current and pedal speed */
  713  1              compCurrent = Booster_CurrentCompensation(feedForwardCurrent);
  714  1              
  715  1      #if 0
                      /* Pedal travel less than 2mm, the current is fixed at 2.2A, improve the motor response speed*/
                      if(ptr_adc->brakePedalLocation1 < 200)
                      {
                              feedForwardCurrent = 200;
                      }
              #endif
  722  1              
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 13  

  723  1              return feedForwardCurrent;
  724  1      }
  725         
  726         
  727         /***********************************************************************
  728         *  Name        : Booster_calcForwardPwm
  729         *  Description : According to the PV characteristic, the target current is used to calculate the feed forw
             -ard PWM 
  730         *  Parameter   : void
  731         *  Returns     : feedForwardPwm
  732         ***********************************************************************/
  733         INT16U Booster_calcForwardPwm(INT16S objCurrent)
  734         {
  735  1              INT16U feedForwardPwm = 0;
  736  1              INT16U objCurrentAbsolute = 0;
  737  1              
  738  1              if(objCurrent <= 0)
  739  1              {
  740  2                      return 0;
  741  2              }
  742  1              else
  743  1              {
  744  2                      objCurrentAbsolute = objCurrent;
  745  2              }
  746  1              
  747  1              feedForwardPwm = lookupTable_1D(objCurrentAbsolute, current_To_pwm[0], current_To_pwm[1], tBooster.curren
             -tToPwmArrayLength - 1);
  748  1      
  749  1              return feedForwardPwm;
  750  1      }
  751         
  752         
  753         /***********************************************************************
  754         *  Name        : Booster_calcMotorObjCurrentFromPedal
  755         *  Description : According to the brake pedal location to calculate the object current.
  756         *  Parameter   : pedal location
  757         *  Returns     : None
  758         ***********************************************************************/
  759         static INT16U Booster_calcMotorObjCurrentFromPedal(INT16U pedalLoc)
  760         {
  761  1              INT16U tempObjCurrent = 0;      
  762  1              
  763  1              tempObjCurrent = lookupTable_1D(pedalLoc, pedal_To_current[0], pedal_To_current[1], tBooster.pedalToCurre
             -ntArrayLength - 1);
  764  1              
  765  1              return tempObjCurrent;
  766  1      }
  767         
  768         
  769         /***********************************************************************
  770         *  Name        : Booster_PedalLocationRateCalculation
  771         *  Description : 
  772         *  Parameter   : None
  773         *  Returns     : None
  774         ***********************************************************************/
  775         static void Booster_PedalLocationRateCalculation(void)
  776         {
  777  1              static INT16U travel[4] = {0u};
  778  1              const T_ADC_APP *adcApp_ptr = AdcApp_SampleData();
  779  1              tBooster.pedalRate  = 2 * adcApp_ptr->brakePedalLocation1 + travel[3] - travel[1] - 2 * travel[0];
  780  1              
  781  1              /* update travel data buffer */
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 14  

  782  1              travel[0] = travel[1];
  783  1              travel[1] = travel[2];
  784  1              travel[2] = travel[3];          
  785  1              travel[3] = adcApp_ptr->brakePedalLocation1;
  786  1      }
  787         
  788         /***********************************************************************
  789         *  Name        : Pid_CylinderLocationRateCalculation
  790         *  Description : 
  791         *  Parameter   : None
  792         *  Returns     : None
  793         ***********************************************************************/
  794         static void Booster_CylinderLocationRateCalculation(void)
  795         {
  796  1              static INT16U travel[4] = {0u};
  797  1              const T_ADC_APP *adcApp_ptr = AdcApp_SampleData();
  798  1      
  799  1              tBooster.cylinderRate = 2 * adcApp_ptr->mainCylinderLocation1 + travel[3] - travel[1] - 2 * travel[0];
  800  1      
  801  1              /* update travel data buffer */
  802  1              travel[0] = travel[1];
  803  1              travel[1] = travel[2];
  804  1              travel[2] = travel[3];  
  805  1              travel[3] = adcApp_ptr->mainCylinderLocation1;  
  806  1      }
  807         
  808         
  809         
  810         /***********************************************************************
  811         *  Name        : Booster_CurrentCompensation
  812         *  Description : Calculate the compensation current based on the given current and pedal speed
  813         *  Parameter   : current value according to cylinder travel
  814         *  Returns     : compensation current
  815         ***********************************************************************/
  816         static INT16U Booster_CurrentCompensation(INT16U calcCurrent)
  817         {
  818  1              INT16U compensationCurrent = 0;
  819  1              INT16S pedalRate = 0;
  820  1              INT16S pedalRateTemp = 0;
  821  1              
  822  1              INT16U u=0; // temp var
  823  1      
  824  1              /* Calculate the pedal movement speed */
  825  1              pedalRate = tBooster.pedalRate * 5;
  826  1              if(pedalRate < -250)
  827  1              {
  828  2                      pedalRateTemp = -250;
  829  2              }
  830  1              else if(pedalRate > 250)
  831  1              {
  832  2                      pedalRateTemp = 250;
  833  2              }
  834  1              else
  835  1              {
  836  2                      pedalRateTemp = pedalRate;
  837  2              }
  838  1              pedalRateAccumulate = pedalRateAccumulate - pedalRateAccumulate / 64;
  839  1              pedalRateAccumulate = pedalRateAccumulate + pedalRateTemp;
  840  1              
  841  1              /* If the feedforward current is greater than 4.5A and the brake pedal in the return or very slow to go *
             -/
  842  1              if((calcCurrent > 450) && (pedalRateAccumulate < 160))
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 15  

  843  1              {
  844  2      //              pedalRateTemp = 160 - pedalRateAccumulate;
  845  2      //              pedalRateTemp = pedalRateTemp / 80;
  846  2      //              if(pedalRateTemp > 10)
  847  2      //              {
  848  2      //                      pedalRateTemp = 10;
  849  2      //              }
  850  2      //              compensationCurrent = - (pedalRateTemp * 100);
  851  2                      
  852  2                      /* modified by temp var u 20200330 */
  853  2                      u = 160 - pedalRateAccumulate;
  854  2                      u = u / 80;
  855  2                      if(u > 10)
  856  2                      {
  857  3                              u = 10;
  858  3                      }
  859  2                      
  860  2                      compensationCurrent =  (u * 100);
  861  2                      /* modified by temp var u 20200330 end */               
  862  2                      
  863  2                      if(ABS(compensationCurrent) < 200)
*** WARNING C115 IN LINE 863 OF src\app\alogrithm\booster.c: '-' applied to unsigned type, result still unsigned
  864  2                      {
  865  3                              compensationCurrent = 200;
  866  3                      }
  867  2              }
  868  1              else
  869  1              {
  870  2                      compensationCurrent = 0;
  871  2              }
  872  1              
  873  1              return compensationCurrent;
  874  1      }
  875         
  876         
  877         /***********************************************************************
  878         *  Name        : Booster_ClosedLoopControl
  879         *  Description : Brake booster control alogrithm
  880         *  Parameter   : None
  881         *  Returns     : None
  882         ***********************************************************************/
  883         static void Booster_ClosedLoopControl(void)
  884         {
  885  1              INT16U feedForwardCurrent = 0; 
  886  1              INT16S feedBackCurrent = 0;
  887  1              
  888  1              INT16U feedForwardPwm = 0; 
  889  1              INT16S feedBackPwm = 0;
  890  1              
  891  1              feedForwardCurrent = Booster_calcForwardCurrent(tBooster.mainCylinderObjLocation);
  892  1              feedBackCurrent = Pid_LocationClosedLoopControl(tBooster.mainCylinderObjLocation);
  893  1              tBooster.calcForwardCurrent = feedForwardCurrent;
  894  1              
  895  1              tBooster.brakeMotorObjCurrent = feedForwardCurrent + feedBackCurrent;
  896  1      
  897  1              
  898  1              /* The target current is not negative */        
  899  1              if(tBooster.brakeMotorObjCurrent < 0)
  900  1              {
  901  2                      tBooster.brakeMotorObjCurrent = 0;
  902  2              }
  903  1              else if(tBooster.brakeMotorObjCurrent > gRTE_controlMaxCurrent)
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 16  

  904  1              {
  905  2                      tBooster.brakeMotorObjCurrent = gRTE_controlMaxCurrent; 
  906  2              }       
  907  1              
  908  1              feedForwardPwm = Booster_calcForwardPwm(tBooster.brakeMotorObjCurrent);
  909  1              feedBackPwm = Pid_CurrentClosedLoopControl(tBooster.brakeMotorObjCurrent);
  910  1              tBooster.calcForwardPwm = feedForwardPwm;
  911  1              
  912  1              Pwm_Control(feedForwardPwm + feedBackPwm);
  913  1      }
  914         
  915         
  916         
  917         /***********************************************************************
  918         *  Name        : Booster_JudgeEnergyRecoveryCondition
  919         *  Description : Judge brake energy recovery condition
  920         *  Parameter   : None
  921         *  Returns     : None
  922         ***********************************************************************/
  923         static void Booster_JudgeEnergyRecoveryCondition(void)
  924         {
  925  1              const T_ADC_APP *ptr_adc = AdcApp_SampleData(); 
  926  1      
  927  1              /* Brake energy recovery condition include:
  928  1               * 1) MCU motor actual speed more than default value
  929  1               * 2) brake pedal location less than 13mm(not emergency brake)
  930  1               * 3) VCU allow brake energy recovery(CAN signal)
  931  1               * 4) TODO:brake pedal location change speed meet condition 
  932  1               */     
  933  1              if ((VCU_VehicleSpeed > RB_END_OF_QUIT_SPEED)
  934  1                      //&& (ptr_adc->brakePedalLocation1 < PEDAL_ENERGY_RECOVERY_RANG) 
  935  1                      && (TRUE == MCU_AllowFeedbackFlag)
  936  1                  && (tBooster.pedalRate < 250)
  937  1                      && (FALSE == g_energyRecoverHitFlag)
  938  1      //              && 0    // disable      // 20200921 am
  939  1                      )
  940  1              {
  941  2                      tBooster.meetEnergyRecoveryCondition = TRUE;
  942  2              }
  943  1              else
  944  1              {
  945  2                      tBooster.meetEnergyRecoveryCondition = FALSE;
  946  2              }
  947  1              
  948  1      }
  949         
  950         
  951         /***********************************************************************
  952         *  Name        : Booster_BrakeStatusMashine
  953         *  Description : None
  954         *  Parameter   : None
  955         *  Returns     : None
  956         ***********************************************************************/
  957         static void Booster_BrakeStatusMashine(void)
  958         {
  959  1              FP32 u = 0.0;
  960  1              static INT16U brakeStatusCount = 0u;
  961  1              static INT16U hybridBrakeReleaseCount = 0u;
  962  1              const T_ADC_APP *ptr_adc = AdcApp_SampleData();
  963  1              static E_STATUS_BRAKE brakeStatusLast = STATUS_INIT_BRAKE;
  964  1              
  965  1              if(tBooster.brakeStatus != brakeStatusLast)
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 17  

  966  1              {
  967  2                      brakeStatusCount = 0u;
  968  2                      hybridBrakeReleaseCount = 0u;
  969  2              }
  970  1              brakeStatusLast = tBooster.brakeStatus;
  971  1              
  972  1              switch (tBooster.brakeStatus)
  973  1              {
  974  2                      case STATUS_INIT_BRAKE:
  975  2                              g_energyRecoverHitFlag = FALSE;
  976  2                              if (ptr_adc->brakePedalLocation1 > BRAKE_PEDAL_LOCATION_VALID)
  977  2                              {
  978  3                                      tBooster.brakeStatus = STATUS_FRICTION_BRAKE;
  979  3                              }
  980  2                              break;
  981  2                              
  982  2                      case STATUS_FRICTION_BRAKE:
  983  2                              /* Not have brake switch signal and brake pedal resume init location, enter STATUS_TRANSIENT
  984  2                               * get ready to return STATUS_INIT_BRAKE. */
  985  2                              if (ptr_adc->brakePedalLocation1 <= BRAKE_PEDAL_LOCATION_VALID)
  986  2                              {                               
  987  3                                      tBooster.brakeStatus = STATUS_TRANSIENT;
  988  3                              }
  989  2      #if (ENABLE == FUNC_BRAKE_ENERGY_RECOVERY)
  990  2                              else
  991  2                              {
  992  3                                      if(((VCU_VehicleSpeed < 2500))
  993  3                                              || (VCU_VehicleSpeed > 7500)) // >75km/h
  994  3                                      {
  995  4                                              g_energyRecoverHitFlag = TRUE;
  996  4                                      }
  997  3                                      
  998  3                                      Booster_JudgeEnergyRecoveryCondition();
  999  3                                      /* Meet brake energy recovery condition keeping 80*3ms enter STATUS_HYBRID_BRAKE. */
 1000  3                                      if (TRUE == tBooster.meetEnergyRecoveryCondition)
 1001  3                                      {               
 1002  4                                              tBooster.brakeStatus = STATUS_HYBRID_BRAKE;
 1003  4                                      }
 1004  3                              }               
 1005  2      #endif
 1006  2                              break;
 1007  2                              
 1008  2                      case STATUS_TRANSIENT:
 1009  2                              g_energyRecoverHitFlag = FALSE;
 1010  2                      
 1011  2                              if (ptr_adc->brakePedalLocation1 > BRAKE_PEDAL_LOCATION_VALID)
 1012  2                              {
 1013  3                                      tBooster.brakeStatus = STATUS_FRICTION_BRAKE;
 1014  3                              }
 1015  2                              else
 1016  2                              {
 1017  3                                      if(brakeStatusCount >= 80u)
 1018  3                                      {
 1019  4                                              tBooster.brakeStatus = STATUS_INIT_BRAKE;
 1020  4                                      }
 1021  3                                      else
 1022  3                                      {
 1023  4                                              brakeStatusCount++;
 1024  4                                      }
 1025  3                              }
 1026  2                              break;
 1027  2                              
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 18  

 1028  2                      case STATUS_HYBRID_BRAKE:
 1029  2      
 1030  2                              Booster_JudgeEnergyRecoveryCondition();
 1031  2                      
 1032  2                              /* Not have brake switch signal and brake pedal resume init location, enter STATUS_TRANSIENT
 1033  2                               * get ready to return STATUS_INIT_BRAKE. */
 1034  2                              if (ptr_adc->brakePedalLocation1 <= BRAKE_PEDAL_LOCATION_VALID)
 1035  2                              {
 1036  3                                      tBooster.brakeStatus = STATUS_TRANSIENT;
 1037  3                              }
 1038  2                              else if((FALSE == tBooster.meetEnergyRecoveryCondition))                        
 1039  2                              {
 1040  3                                      /* If not meet brake energy recovery condition, enter STATUS_FRICTION_BRAKE at once*/
 1041  3                                      tBooster.brakeStatus = STATUS_FRICTION_BRAKE;
 1042  3                              }
 1043  2                              else if((VCU_VehicleSpeed < tBooster.rbQuitSpeed))
 1044  2                              {
 1045  3                                      tBooster.State4coef = 1;
 1046  3                                      tBooster.brakeStatus = STATUS_RELASE_HYBRID_BRAKE;
 1047  3                              }
 1048  2      
 1049  2                              break;
 1050  2      
 1051  2                      case STATUS_RELASE_HYBRID_BRAKE:
 1052  2                              
 1053  2                              Booster_JudgeEnergyRecoveryCondition();
 1054  2                      
 1055  2                              /* Not have brake switch signal and brake pedal resume init location, enter STATUS_TRANSIENT
 1056  2                               * get ready to return STATUS_INIT_BRAKE. */
 1057  2                              if ((ptr_adc->brakePedalLocation1 <= BRAKE_PEDAL_LOCATION_VALID))
 1058  2                              {
 1059  3                                      tBooster.brakeStatus = STATUS_TRANSIENT;
 1060  3                              }       
 1061  2                              else if((FALSE == tBooster.meetEnergyRecoveryCondition))
 1062  2                              {
 1063  3                                      tBooster.brakeStatus = STATUS_FRICTION_BRAKE;                   
 1064  3                              }
 1065  2                              else 
 1066  2                              {
 1067  3                                  if( VCU_VehicleSpeed < RB_END_OF_QUIT_SPEED )
 1068  3                                      {
 1069  4                                              tBooster.brakeStatus = STATUS_FRICTION_BRAKE; 
 1070  4                                      }
 1071  3                                      else if(VCU_VehicleSpeed > tBooster.rbQuitSpeed)
 1072  3                                      {
 1073  4                                              if(hybridBrakeReleaseCount > 80)
 1074  4                                              {
 1075  5                                                      tBooster.brakeStatus = STATUS_HYBRID_BRAKE;
 1076  5                                              }
 1077  4                                              else
 1078  4                                              {
 1079  5                                                      hybridBrakeReleaseCount++;
 1080  5                                              }
 1081  4                                      }
 1082  3                                      else
 1083  3                                      {
 1084  4                                              u = VCU_VehicleSpeed - RB_END_OF_QUIT_SPEED;
 1085  4                                              tBooster.State4coef = u / (FP32)(tBooster.rbQuitSpeed - RB_END_OF_QUIT_SPEED);
 1086  4                                      }
 1087  3                              }
 1088  2      
 1089  2                              break;
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 19  

 1090  2      
 1091  2                      default:
 1092  2                              brakeStatusCount = 0u;
 1093  2                              hybridBrakeReleaseCount = 0u;
 1094  2                              tBooster.brakeStatus = STATUS_INIT_BRAKE;
 1095  2                              break;
 1096  2              }
 1097  1      }
 1098                 
 1099         /***********************************************************************
 1100         *  Name        : Booster_BrakeForceDistribution
 1101         *  Description : Booster brake force distribution, include VCU motor torque and
 1102         *                brake motor friction torque.
 1103         *  Parameter   : None
 1104         *  Returns     : None
 1105         ***********************************************************************/
 1106         static void Booster_BrakeForceDistribution(void)
 1107         {
 1108  1              INT16U frictionObjLocation = 0;
 1109  1              static INT16U cylinderObjLocationDiff = 0;
 1110  1              static INT16S mcuMotorObjTorqueHybridBrakeLast = 0;
 1111  1              static INT16S mcuMotorObjTorqueReleaseHybridBrakeLast = 0;
 1112  1              
 1113  1              const T_ADC_APP *ptr_adc = AdcApp_SampleData();
 1114  1              
 1115  1              frictionObjLocation = Booster_CylinderMinLocationCheck();
 1116  1              
 1117  1              tBooster.totalObjLocation = tBooster.mainCylinderObjLocation;
 1118  1              tBooster.frictionObjLocation = frictionObjLocation;
 1119  1              
 1120  1              switch (tBooster.brakeStatus)
 1121  1              {
 1122  2                      case STATUS_INIT_BRAKE:
 1123  2                              tBooster.totalTorqueRequest = 0;
 1124  2                              tBooster.frictionBrakeObjTorque = 0;
 1125  2                              tBooster.mcuMotorObjTorque = 0;
 1126  2                  iCAS_Brake_MotToqReq_Flag = 1;              
 1127  2                              break;
 1128  2      
 1129  2      
 1130  2                      case STATUS_FRICTION_BRAKE:
 1131  2                              tBooster.mcuMotorObjTorque = 0;
 1132  2                          iCAS_Brake_MotToqReq_Flag = 1;
 1133  2                              break;
 1134  2                      
 1135  2                      case STATUS_TRANSIENT:
 1136  2                              if(tBooster.mcuMotorObjTorque < -20)
 1137  2                              {
 1138  3                                      tBooster.mcuMotorObjTorque += 10;
 1139  3                                      iCAS_Brake_MotToqReq_Flag = 0;
 1140  3                              }
 1141  2                              else
 1142  2                              {
 1143  3                                      tBooster.mcuMotorObjTorque = 0;
 1144  3                                      iCAS_Brake_MotToqReq_Flag = 1;
 1145  3                              }
 1146  2                              break;
 1147  2      
 1148  2                      case STATUS_HYBRID_BRAKE:       
 1149  2      
 1150  2                              /* Use main cylinder location to calculate total brake torque request. */
 1151  2                              tBooster.totalTorqueRequest = Booster_CalculateBrakeTorque(tBooster.mainCylinderObjLocation);
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 20  

 1152  2                      
 1153  2                              if(frictionObjLocation > MAIN_CYLINER_EMPTY_LOCATION)
 1154  2                              {
 1155  3                                      tBooster.frictionBrakeObjTorque = Booster_CalculateBrakeTorque(frictionObjLocation);    // sth strange he
             -re
 1156  3                              }
 1157  2                              else
 1158  2                              {
 1159  3                                      tBooster.frictionBrakeObjTorque = 0;
 1160  3                              }
 1161  2                              
 1162  2                              //tBooster.mcuMotorObjTorque = tBooster.totalTorqueRequest - tBooster.frictionBrakeObjTorque;
 1163  2                              tBooster.mcuMotorObjTorque = tBooster.totalTorqueRequest;
 1164  2                              
 1165  2                              /* The quit speed of regenerative braking is calculated according to the total braking force. */
 1166  2                              tBooster.rbQuitSpeed = Booster_RegenerationBrakeQuitSpeed(tBooster.totalTorqueRequest);
 1167  2                              
 1168  2                          if(tBooster.mcuMotorObjTorque < tBooster.mcuMotorMaxiumTorque)
 1169  2                              {
 1170  3                                      tBooster.mcuMotorObjTorque = tBooster.mcuMotorMaxiumTorque;
 1171  3                              }
 1172  2                              Booster_mcuObjTorqueCheck(&(tBooster.mcuMotorObjTorque));
 1173  2                              iCAS_Brake_MotToqReq_Flag = 0;
 1174  2                              
 1175  2                              mcuMotorObjTorqueHybridBrakeLast = tBooster.mcuMotorObjTorque;
 1176  2                              mcuMotorObjTorqueReleaseHybridBrakeLast = mcuMotorObjTorqueHybridBrakeLast;
 1177  2                              cylinderObjLocationDiff = tBooster.mainCylinderObjLocation - frictionObjLocation;
 1178  2                              
 1179  2                              tBooster.mainCylinderObjLocation = frictionObjLocation;
 1180  2      
 1181  2                              break;
 1182  2      
 1183  2                      case STATUS_RELASE_HYBRID_BRAKE:
 1184  2      
 1185  2                              /* Use main cylinder location to calculate total brake torque request. */
 1186  2                              tBooster.totalTorqueRequest = Booster_CalculateBrakeTorque(tBooster.mainCylinderObjLocation);               
 1187  2                          tBooster.mcuMotorObjTorque = EnergyRecovery_BrakeTorqueReduction(mcuMotorObjTorqueHybridBrakeLast, t
             -Booster.State4coef);
 1188  2                              if(tBooster.mcuMotorObjTorque < mcuMotorObjTorqueReleaseHybridBrakeLast)
 1189  2                              {
 1190  3                                      tBooster.mcuMotorObjTorque = mcuMotorObjTorqueReleaseHybridBrakeLast;
 1191  3                              }
 1192  2                              
 1193  2                              if(tBooster.mcuMotorObjTorque < tBooster.mcuMotorMaxiumTorque)
 1194  2                              {
 1195  3                                      tBooster.mcuMotorObjTorque = tBooster.mcuMotorMaxiumTorque;
 1196  3                              }
 1197  2                              
 1198  2                              Booster_mcuObjTorqueCheck(&(tBooster.mcuMotorObjTorque));
 1199  2                              mcuMotorObjTorqueReleaseHybridBrakeLast = tBooster.mcuMotorObjTorque;
 1200  2                              
 1201  2                              
 1202  2                              tBooster.mainCylinderObjLocation = frictionObjLocation + EnergyRecovery_ObjLocationIncrement(cylinderOb
             -jLocationDiff, tBooster.State4coef);
 1203  2                      
 1204  2                              break;
 1205  2      
 1206  2                      default:
 1207  2                              tBooster.totalTorqueRequest = 0;
 1208  2                              tBooster.frictionBrakeObjTorque = 0;
 1209  2                              break;
 1210  2              }
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 21  

 1211  1      }
 1212         
 1213         /***********************************************************************
 1214         *  Name        : Booster_mcuObjTorqueCheck(INT16S torque)
 1215         *  Description : There is a mechanical gap between the pedal and the cylinder, 
 1216         *  Parameter   : None
 1217         *  Returns     : None
 1218         ***********************************************************************/
 1219         static void Booster_mcuObjTorqueCheck(INT16S* torque)
 1220         {
 1221  1          INT16S rb_objtorque = 0;
 1222  1              
 1223  1              rb_objtorque = *torque;
 1224  1              
 1225  1              if(rb_objtorque >= MCU_MOTOR_TORQUE_DEFAULT)
 1226  1              {
 1227  2                 rb_objtorque = MCU_MOTOR_TORQUE_DEFAULT;
 1228  2              }
 1229  1              if(rb_objtorque <= MCU_MOTOR_TORQUE_MAX_LIMIT)
 1230  1              {
 1231  2                 rb_objtorque = MCU_MOTOR_TORQUE_MAX_LIMIT;
 1232  2              }       
 1233  1              
 1234  1          *torque = rb_objtorque;     
 1235  1      }
 1236         
 1237         
 1238         /***********************************************************************
 1239         *  Name        : Booster_CylinderMinLocationCheck
 1240         *  Description : There is a mechanical gap between the pedal and the cylinder, 
 1241         *                                Limit the minimum position of the cylinder to avoid collision 
 1242         *                                with the pedal mandrel.
 1243         *  Parameter   : None
 1244         *  Returns     : None
 1245         ***********************************************************************/
 1246         static INT16U Booster_CylinderMinLocationCheck(void)
 1247         {
 1248  1              INT16U frictionCylinderObjLocation = 0;
 1249  1              const T_ADC_APP *ptr_adc = AdcApp_SampleData(); 
 1250  1              
 1251  1              if(ptr_adc->brakePedalLocation1 <= (MAIN_CYLINER_EMPTY_LOCATION + TOLERATE_COMPRESS_MAX_VALUE))
 1252  1              {
 1253  2                      //MAIN_CYLINER_EMPTY_LOCATION = 400(4mm)
 1254  2                      if(ptr_adc->brakePedalLocation1 < 100)
 1255  2                      {
 1256  3                              frictionCylinderObjLocation = tBooster.mainCylinderObjLocation;
 1257  3                      }
 1258  2                      else
 1259  2                      {
 1260  3                              //frictionCylinderObjLocation = ptr_adc->brakePedalLocation1 * 0.42 - 42;
 1261  3                              frictionCylinderObjLocation = ptr_adc->brakePedalLocation1 * 0.44 - 44;
 1262  3                      }
 1263  2              }
 1264  1              else if(tBooster.mainCylinderObjLocation > (ptr_adc->brakePedalLocation1 - TOLERATE_COMPRESS_MAX_VALUE)) 
             -// do not understand
 1265  1              {
 1266  2                      frictionCylinderObjLocation = ptr_adc->brakePedalLocation1 - TOLERATE_COMPRESS_MAX_VALUE;
 1267  2              }
 1268  1              else
 1269  1              {
 1270  2                      frictionCylinderObjLocation = tBooster.mainCylinderObjLocation;
 1271  2              }
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 22  

 1272  1      
 1273  1              return frictionCylinderObjLocation;
 1274  1      }
 1275         
 1276         
 1277         
 1278         /***********************************************************************
 1279         *  Name        : Booster_CalculateMixBrakeCylinderLocationFromTorque
 1280         *  Description : According to friction brake object torque to calculate
 1281         *                brake main cylinder object location.
 1282         *  Parameter   : None
 1283         *  Returns     : brakeTorque
 1284         ***********************************************************************/
 1285         static INT16U Booster_CalculateMixBrakeCylinderLocationFromTorque(INT16S objTorque)
 1286         {
 1287  1              INT16U cylinderObjLocation = 0;
 1288  1      
 1289  1              if(objTorque >= 0)
 1290  1              {
 1291  2                      cylinderObjLocation = 0;
 1292  2              }
 1293  1              else if(objTorque > -192)
 1294  1              {
 1295  2                      cylinderObjLocation = -1.0417 * objTorque + 200;
 1296  2              }
 1297  1              else if(objTorque > -800)
 1298  1              {
 1299  2                      cylinderObjLocation = -0.3289 * objTorque + 336.84;
 1300  2              }
 1301  1              else if(objTorque > -1650)
 1302  1              {
 1303  2                      cylinderObjLocation = -0.2353 * objTorque + 411.76;
 1304  2              }
 1305  1              else
 1306  1              {
 1307  2                      cylinderObjLocation = -0.16 * objTorque + 536;
 1308  2              }
 1309  1              
 1310  1              return cylinderObjLocation;
 1311  1      }
 1312         
 1313         
 1314         /***********************************************************************
 1315         *  Name        : Booster_CalculateBrakeTorque
 1316         *  Description : According to main cylinder location to calculate brake torque.
 1317         *  Parameter   : None
 1318         *  Returns     : brakeTorque
 1319         ***********************************************************************/
 1320         static INT16S Booster_CalculateBrakeTorque(INT16U objLoc)
 1321         {
 1322  1              INT16S brakeTorque = 0;
 1323  1              
 1324  1              if (objLoc < 100)
 1325  1              {
 1326  2                      brakeTorque = 0;
 1327  2              }
 1328  1              else if(objLoc < 200)
 1329  1              {
 1330  2                      brakeTorque = -objLoc + 100;
*** WARNING C115 IN LINE 1330 OF src\app\alogrithm\booster.c: '-' applied to unsigned type, result still unsigned
 1331  2              }
 1332  1              else if(objLoc < 400)
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 23  

 1333  1              {
 1334  2                      brakeTorque = -2 * objLoc + 300;
 1335  2              }
 1336  1              else if(objLoc < 700)
 1337  1              {
 1338  2                      brakeTorque = -2.3333 * objLoc + 433.33;
 1339  2              }
 1340  1              else if(objLoc < 1000)
 1341  1              {
 1342  2                      brakeTorque = -1.3333 * objLoc - 266.67;
 1343  2              }
 1344  1              else if(objLoc < 1200)
 1345  1              {
 1346  2                      brakeTorque = -1600;
 1347  2              }
 1348  1      /*
 1349  1              else if(objLoc < 1600)
 1350  1              {
 1351  1                      brakeTorque = 0.5 * objLoc - 2200;
 1352  1              }
 1353  1              else if(objLoc < 1800)
 1354  1              {
 1355  1                      brakeTorque = 7 * objLoc - 12600;
 1356  1              }
 1357  1      */      
 1358  1              else
 1359  1              {
 1360  2                      brakeTorque = -1600;
 1361  2              }
 1362  1              
 1363  1              if (brakeTorque > 0)
 1364  1              {
 1365  2                      brakeTorque = 0;
 1366  2              }
 1367  1      
 1368  1              return brakeTorque;
 1369  1      }
 1370         
 1371         
 1372         
 1373         
 1374         /***********************************************************************
 1375         *  Name        : Booster_RegenerationBrakeQuitSpeed
 1376         *  Description : regenerative brake quit speed.
 1377         *  Parameter   : None
 1378         *  Returns     : quitSpeed
 1379         ***********************************************************************/
 1380         static INT16U Booster_RegenerationBrakeQuitSpeed(INT16S torque)
 1381         {
 1382  1              INT16S tempTorque = 0; 
 1383  1              INT16U quitSpeed = 0;
 1384  1      
 1385  1              tempTorque = torque;
 1386  1      
 1387  1              quitSpeed = 1000 - tempTorque * 3 - tempTorque / 8;
 1388  1      
 1389  1              if (quitSpeed > RB_QUIT_SPEED1)
 1390  1              {
 1391  2                      quitSpeed = RB_QUIT_SPEED1;
 1392  2              }
 1393  1              else
 1394  1              {
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 24  

 1395  2                      if (quitSpeed < RB_QUIT_SPEED2)
 1396  2                      {
 1397  3                              quitSpeed = RB_QUIT_SPEED2;
 1398  3                      }
 1399  2              }       
 1400  1              return quitSpeed;
 1401  1      }
 1402         
 1403         /***********************************************************************
 1404         *  Name        : Booster_PedalLocationPredict
 1405         *  Description : 
 1406         *  Parameter   : None
 1407         *  Returns     : None
 1408         ***********************************************************************/
 1409         static void Booster_PedalLocationPredict(void)
 1410         {
 1411  1              const T_ADC *adcPtr = Adc_SampleData();
 1412  1              static INT16S pedalRateFiltered = 0u;
 1413  1              INT16U pedalTravelAdc = 0u;
 1414  1              INT16U tempPedalRate = 0u;
 1415  1      
 1416  1              if(adcPtr->brakePedalTrip_Adc[0] < gRTE_pedalInitValue[0])
 1417  1              {
 1418  2                      pedalTravelAdc = gRTE_pedalInitValue[0];
 1419  2              }
 1420  1              else
 1421  1              {
 1422  2                      pedalTravelAdc = adcPtr->brakePedalTrip_Adc[0] - gRTE_pedalInitValue[0];
 1423  2              }
 1424  1              
 1425  1              if(tBooster.pedalRate < pedalRateFiltered)
 1426  1              {
 1427  2                      tempPedalRate = pedalRateFiltered - tBooster.pedalRate + 8;
 1428  2                      tempPedalRate = tempPedalRate >> 4;
 1429  2                      pedalRateFiltered = pedalRateFiltered - tempPedalRate;
 1430  2              }
 1431  1              else
 1432  1              {
 1433  2                      tempPedalRate = tBooster.pedalRate - pedalRateFiltered + 8;
 1434  2                      tempPedalRate = tempPedalRate >> 4;
 1435  2                      pedalRateFiltered = pedalRateFiltered + tempPedalRate;
 1436  2              }
 1437  1              
 1438  1              if(pedalRateFiltered < 0)
 1439  1              {
 1440  2                      tempPedalRate = -pedalRateFiltered;
 1441  2                      tempPedalRate = tempPedalRate << 3;
 1442  2                      if(pedalTravelAdc < tempPedalRate)
 1443  2                      {
 1444  3                              tBooster.pedalPredictedLocation = 0u;
 1445  3                      }
 1446  2                      else
 1447  2                      {
 1448  3                              tBooster.pedalPredictedLocation = pedalTravelAdc - tempPedalRate;
 1449  3                      }
 1450  2              }
 1451  1              else
 1452  1              {
 1453  2                      tempPedalRate = tempPedalRate << 3;
 1454  2                      tBooster.pedalPredictedLocation = pedalTravelAdc + tempPedalRate;
 1455  2              }
 1456  1      }
C166 COMPILER V7.57.0, BOOSTER                                                             12/25/2020 20:36:02 PAGE 25  

 1457         
 1458         
 1459         
 1460         
 1461         
 1462         /***********************************************************************
 1463         *  Name        : Booster_AlogrithmData
 1464         *  Description : Brake booster control alogrithm data
 1465         *  Parameter   : None
 1466         *  Returns     : Brake booster control alogrithm data structure access address
 1467         ***********************************************************************/
 1468         const T_BOOSTER* Booster_AlogrithmData(void)
 1469         {
 1470  1              return (&tBooster);
 1471  1      }
 1472         
 1473         /* _END_OF_BOOSTER_ */
*** WARNING C174 IN LINE 1285 OF src\app\alogrithm\booster.c: 'Booster_CalculateMixBrakeCylinderLocationFromTorque': unr
             -eferenced 'static' function
*** WARNING C174 IN LINE 313 OF src\app\alogrithm\booster.c: 'Booster_LocationAndCurrentLoop': unreferenced 'static' fun
             -ction
*** WARNING C174 IN LINE 376 OF src\app\alogrithm\booster.c: 'Booster_OnlyLocationLoop': unreferenced 'static' function


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        3958     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          35     --------
  FAR-DATA SIZE    =         224     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =         392     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  8 WARNING(S),  0 ERROR(S)
