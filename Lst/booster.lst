C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 1   


C166 COMPILER V7.57.0, COMPILATION OF MODULE BOOSTER
OBJECT MODULE PLACED IN .\Obj\booster.obj
COMPILER INVOKED BY: C:\Keil_v5\C166\BIN\C166.EXE src\app\alogrithm\booster.c MODV2 LARGE BROWSE INCDIR(.\src;.\src\bsw;
                    -.\src\driver;.\src\interaction;.\src\app\adc;.\src\app\alogrithm;.\src\app\can;.\src\app\ccp;.\src\app\diagnostic;.\src\
                    -app\mode control;.\src\app\task;.\src\app\Fun;.\src\app\rtos;.\src\bsw\can;.\src\bsw\desc;.\src\bsw\nm;.\src\app\time me
                    -asure;.\src\app\rte) MODV2 DEBUG PRINT(.\Lst\booster.lst) OBJECT(.\Obj\booster.obj) 

 stmt lvl     source

    1         /***********************************************************************
    2         *   Copyright (C) JWD Automotive Co., Ltd.                                                  
    3         * 
    4         *               All Rights Reserved.                                                                
    5         *   Department : iCAS SW                                                                                            
    6         *   AUTHOR         :                                                                                                              
    7         ************************************************************************
    8         * Object        : 
    9         * Module        : booster.c
   10         * Instance      : 
   11         * Description   : booster brake algorithm
   12         *-----------------------------------------------------------------------
   13         * Version: v0.1
   14         * Date   : Dec 7,2019 
   15         * Author : Gao zhengzhong
   16         ***********************************************************************/
   17         /*-History--------------------------------------------------------------
   18         * Version    Date           Name            Changes and comments
   19         ------------------------------------------------------------------------
   20         * 0.1          Dec 7,2019     Gao Zhengzhong  Initial version
   21         *=====================================================================*/
   22         
   23         #include <stdlib.h>
   24         #include <string.h>
   25         
   26         #define BOOSTER_GLOBALS
   27         #include "booster.h"
   28         #include "booster_Cfg.h"
   29         
   30         #include "adc_sample.h"
   31         #include "rte.h"
   32         #include "energy_recovery.h"
   33         #include "wire_control.h"
   34         #include "pid.h"
   35         #include "FLTD.h"
   36         #include "pwm.h"
   37         
   38         
   39         
   40         /**** Definition of variables ****/
   41         static T_BOOSTER tBooster = {0};
   42         INT16S pedalRateAccumulate = 0;
   43         static BOOLEAN g_energyRecoverHitFlag = FALSE;
   44         static INT16U timeDetectCount = 0;
   45         
   46         /**** Declaration of functions ****/
   47         static void Booster_systemModeJudge(void);
   48         static void Booster_pressureSensorNormalJudge(void);
   49         static void Booster_OnlyLocationLoop(void);
   50         static void Booster_OnlyCurrentLoop(void);
   51         static void Booster_LocationAndCurrentLoop(void);
   52         
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 2   

   53         static INT16U Booster_calcCylinderObjLocationFromPedal(INT16U pedalLoc);
   54         INT16U Booster_calcForwardPwm(INT16S objCurrent);
   55         static INT16U Booster_calcMotorObjCurrentFromPedal(INT16U pedalLoc);
   56         static void Booster_PedalLocationRateCalculation(void);
   57         static void Booster_CylinderLocationRateCalculation(void);
   58         static INT16U Booster_CurrentCompensation(INT16U calcCurrent);
   59         static void Booster_ClosedLoopControl(void);
   60         
   61         static void Booster_JudgeEnergyRecoveryCondition(void);
   62         static void Booster_BrakeStatusMashine(void);
   63         static void Booster_BrakeForceDistribution(void);
   64         static void Booster_mcuObjTorqueCheck(INT16S* torque);
   65         static INT16U Booster_CylinderMinLocationCheck(void);
   66         
   67         static INT16U Booster_CalculateMixBrakeCylinderLocationFromTorque(INT16S objTorque);
   68         static INT16U Booster_RegenerationBrakeQuitSpeed(INT16S torque);
   69         static INT16S Booster_CalculateBrakeTorque(INT16U objLoc);
   70         static void Booster_PedalLocationPredict(void);
   71         
   72         
   73         
   74         /***********************************************************************
   75         *  Name        : Booster_Init
   76         *  Description : After power on, initiliaze booster alogrithm variable
   77         *  Parameter   : None
   78         *  Returns     : None
   79         ***********************************************************************/
   80         void Booster_Init(void)
   81         {
   82  1              memset(&tBooster, 0, sizeof(tBooster));
   83  1              
   84  1              tBooster.temperatureProtectCoeff = PROTECT_INIT_COEFF;
   85  1              tBooster.currentDampCoeff = PROTECT_INIT_COEFF;
   86  1              tBooster.cylinderDampCoeff = PROTECT_INIT_COEFF;
   87  1              
   88  1              tBooster.pedalToCylinderArrayLength = sizeof(pedal_To_cylinder[0]) / sizeof(INT16U);
   89  1              tBooster.cylinderToCurrentArrayLength = sizeof(cylinder_To_current[0]) / sizeof(INT16U);
   90  1              tBooster.currentToPwmArrayLength = sizeof(current_To_pwm[0]) / sizeof(INT16U);
   91  1              tBooster.pedalToCurrentArrayLength = sizeof(pedal_To_current[0]) / sizeof(INT16U);
   92  1      }
   93         
   94         /***********************************************************************
   95         *  Name        : Booster_DeInit
   96         *  Description : During running, need initilize booster algorithm variable
   97         *  Parameter   : None
   98         *  Returns     : None
   99         ***********************************************************************/
  100         void Booster_DeInit(void)
  101         {
  102  1              return;
  103  1      }
  104         
  105         /***********************************************************************
  106         *  Name        : Booster_Algorithm
  107         *  Description : Booster control algorithm
  108         *  Parameter   : None
  109         *  Returns     : None
  110         ***********************************************************************/
  111         void Booster_Algorithm(void)
  112         {
  113  1              const FLTD_faultActType* FLTDAct_ptr = FLTD_FltActFlgData();
  114  1              const T_ADC_APP *adcApp_ptr = AdcApp_SampleData();      
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 3   

  115  1              
  116  1              tBooster.brakePedalLocation = adcApp_ptr->brakePedalLocation1;
  117  1              tBooster.mainCylinderLocation = adcApp_ptr->mainCylinderLocation1;
  118  1              tBooster.motorCurrent = adcApp_ptr->brakeMotorCurrent;
  119  1              tBooster.cylinderPressure = adcApp_ptr->mainCylinderPressure;
  120  1              tBooster.environmentTemperature = adcApp_ptr->environmentTemperature;
  121  1              
  122  1      #if (ENABLE == FUNC_BRAKE_ENERGY_RECOVERY)
                      tBooster.mcuMotorMaxiumTorque = MCU_MotToqLmt * 0.5 - 4000;
                      tBooster.mcuMotorActualTorque = MCU_MotActuToq * 0.5 - 4000;
              #endif
  126  1              
  127  1              g_wireControlActualPressure = (adcApp_ptr->mainCylinderPressure / 100); // updated 20210109, pressure clo
             -sed loop test
*** WARNING C192 IN LINE 127 OF src\app\alogrithm\booster.c: '=': value truncated
  128  1              
  129  1              Booster_systemModeJudge();
  130  1                      
  131  1              Booster_PedalLocationRateCalculation();
  132  1              Booster_CylinderLocationRateCalculation();
  133  1              Booster_CalculateTemperatureProtectCoeff();
  134  1              Booster_CalcTimeOutProtectCoef();
  135  1              //Booster_PedalLocationPredict();
  136  1              //Booster_BrakeStatusMashine();
  137  1              
  138  1              WireControl_Algorithm();
  139  1              Booster_pressureSensorNormalJudge();
  140  1              
  141  1              if((TRUE == FLTDAct_ptr->fixedDecelerationFlg) || (3 == gRTE_pidTypeSw))
  142  1              {
  143  2      
  144  2                      gRTE_pidTypeSts = 3;
  145  2                      if(BoosterBrakeMode == BrakeSysMode)
  146  2                      {
  147  3                              if(TRUE == g_inBrakeSwValidSts)
  148  3                              {
  149  4                                      Pwm_Control(700);
  150  4                              }
  151  3                              else
  152  3                              {
  153  4                                      Pwm_Control(0);
  154  4                              }
  155  3                      }
  156  2                      else
  157  2                      {
  158  3                              if((TRUE == g_wireControlEnFlag) && (g_wireControlObjPressure > 0)) 
  159  3                              {
  160  4                                      Pwm_Control(600);
  161  4                              }
  162  3                              else
  163  3                              {
  164  4                                      Pwm_Control(0);
  165  4                              }                               
  166  3                      }
  167  2                      
  168  2              }
  169  1      #if 1
  170  1              else
  171  1              {
  172  2                      gRTE_pidTypeSts = 2;
  173  2                      Booster_OnlyCurrentLoop();
  174  2                      WireControl_CurrentToPressure();
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 4   

  175  2              }
  176  1      #else
                      else if((TRUE == FLTDAct_ptr->brakingDependsOnCurrentFlg) || (2 == gRTE_pidTypeSw) || (TRUE == g_cylinder
             -ExhaustEnFlag))
                      {
                              gRTE_pidTypeSts = 2;
                              Booster_OnlyCurrentLoop();
                              WireControl_CurrentToPressure();
                      }
                      else if((TRUE == FLTDAct_ptr->brakingDependsOnCylinderFlg) ||(1 == gRTE_pidTypeSw))
                      {
                              gRTE_pidTypeSts = 1;
                              Booster_OnlyLocationLoop();
                              WireControl_CylinderToPressure();
                      }
                      else if(0 == gRTE_pidTypeSw)
                      {
                              gRTE_pidTypeSts = 0;
                              Booster_LocationAndCurrentLoop();
                              WireControl_CylinderToPressure();
                      }
                      
              #endif
  197  1              
  198  1      }
  199         
  200         /***********************************************************************
  201         *  Name        : Booster_systemModeJudge
  202         *  Description : booster system mode judge. 0: booster mode ; 1: wireControl mode 
  203         *  Parameter   : None
  204         *  Returns     : None
  205         ***********************************************************************/
  206         static void Booster_systemModeJudge(void)
  207         {
  208  1              static INT8U brakeSysModeLast = 0;
  209  1              const FLTD_faultActType* FLTDAct_ptr = FLTD_FltActFlgData();
  210  1              const T_ADC_APP *adcApp_ptr = AdcApp_SampleData();      
  211  1              
  212  1              /*---------------Ì¤°å¸ÉÔ¤µÄÅÐ¶ÏÂß¼­------------------------*/
  213  1      #if (0 != BRAKE_SIGNAL_SOURCE)
                      if((TRUE == g_wireControlEnFlag) || (TRUE == g_cylinderExhaustEnFlag))
                      {
                              if((TRUE == g_inBrakeSwValidSts)
                                      || ((FALSE == FLTDAct_ptr->fixedDecelerationFlg) && (adcApp_ptr->brakePedalLocation1 > BRAKE_PEDAL_LOCA
             -TION_VALID)))
                              {
                                      BrakeSysMode = BoosterBrakeMode;
                                      
                                      if(brakeSysModeLast != BrakeSysMode)
                                      {
                                              g_pedalInterveneFlag = TRUE;
                                      }
                              }
                              else
                              {
                                      BrakeSysMode = WireCtrlBrakeMode;
                              }       
                      }
                      else
                      {
                              BrakeSysMode = BoosterBrakeMode;
                      }
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 5   

                      brakeSysModeLast = BrakeSysMode;
              #else
  237  1              BrakeSysMode = WireCtrlBrakeMode;
  238  1      #endif
  239  1      }
  240         
  241         
  242         /***********************************************************************
  243         *  Name        : Booster_pressureSensorNormalJudge
  244         *  Description : pressure sensor fault judge
  245         *  Parameter   : None
  246         *  Returns     : None
  247         ***********************************************************************/
  248         static void Booster_pressureSensorNormalJudge(void)
  249         {
  250  1              static INT16U normalTimeCnt1 = 0;
  251  1              static INT16U breakParkTimeCnt = 0;
  252  1              
  253  1              static INT16U sensorFaultTimeCnt1 = 0;
  254  1              static INT16U sensorFaultTimeCnt2 = 0;
  255  1              static BOOLEAN pressureLoopEnterFlag = FALSE;
  256  1              const T_ADC_APP* ptr_adcApp = AdcApp_SampleData();
  257  1      
  258  1              if(TRUE == g_ParkStateFlag)
  259  1              {
  260  2                      if(breakParkTimeCnt > 600)
  261  2                      {
  262  3                              g_brakeReleaseFlag = TRUE;
  263  3                      }
  264  2                      else
  265  2                              {
  266  3                              breakParkTimeCnt++;
  267  3                      }
  268  2                              }
  269  1                              else
  270  1                              {
  271  2                      breakParkTimeCnt = 0;
  272  2                      g_brakeReleaseFlag = FALSE;
  273  2                              }
  274  1              
  275  1              /*  */
  276  1              if(0 == g_wireControlObjPressure) //Clear system exception when no brake request is made
  277  1              {
  278  2                      g_topEdgeCnt = 0;
  279  2                      g_bottomEdgeCnt = 0;
  280  2                      g_systemAbnormalFlag = FALSE;
  281  2                      g_residualPressureFlag = FALSE;
  282  2                      
  283  2                      g_pressureErrorLargeTimeCnt = 0;
  284  2                      g_pressureErrorNormalTimeCnt = 0;
  285  2                      g_pressureErrorLargeFlag = FALSE;
  286  2              }
  287  1              if((g_topEdgeCnt >= 4) && (g_bottomEdgeCnt >= 4)) //The shock reaches 4 times to judge the system abnorma
             -lity
  288  1              {
  289  2                      g_systemAbnormalFlag = TRUE;
  290  2              }
  291  1              
  292  1      #if (1 == PRESSURE_SENSOR_TYPE)
  293  1              /* New pressure sensor, 0.5 ~ 4.5V. range 0 ~ 20MPa */
  294  1              
  295  1              if((ptr_adcApp->pressureVoltage < 400) || (ptr_adcApp->pressureVoltage > 4500))
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 6   

  296  1              {
  297  2                      normalTimeCnt1 = 0;
  298  2                      if(sensorFaultTimeCnt1 > 300)
  299  2                      {
  300  3                              g_PressureSensorFaultFlag = TRUE;
  301  3                      }
  302  2                      else
  303  2                      {
  304  3                              sensorFaultTimeCnt1++;
  305  3                      }
  306  2              }
  307  1              else
  308  1              {
  309  2                      sensorFaultTimeCnt1 = 0;
  310  2                      
  311  2                      if(normalTimeCnt1 > 300)
  312  2                      {
  313  3                              normalTimeCnt1 = 0;
  314  3                              g_PressureSensorFaultFlag = FALSE;
  315  3                      }
  316  2                      else
  317  2                      {
  318  3                              normalTimeCnt1++;
  319  3                      }
  320  2              }
  321  1              
  322  1              /* pressure loop condition */
  323  1              if((FALSE == g_ParkStateFlag) //non Parking state
  324  1                      && (FALSE == g_PressureSensorFaultFlag) //pressure sensor no fault
  325  1                      && (FALSE == g_residualPressureFlag) //Logical determination of pipeline residual pressure
  326  1                      && (FALSE == g_pressureErrorLargeFlag)
  327  1                      && (FALSE == g_systemAbnormalFlag)
  328  1              ) //The system has no vibration abnormality
  329  1              {
  330  2                      gRTE_wireControlPressureLoopFlag = TRUE;
  331  2              }
  332  1              else
  333  1              {
  334  2                      gRTE_wireControlPressureLoopFlag = FALSE;
  335  2                      
  336  2                      residualPressureTimeCnt = 0;
  337  2                      residualPressureReleaseTimeCnt = 0;
  338  2                      stabiliseTimeCnt = 0;
  339  2                      
  340  2                      g_pressureErrorLargeTimeCnt = 0;
  341  2                      g_pressureErrorNormalTimeCnt = 0;
  342  2              }
  343  1              
  344  1      #else
                      
                      /* pressure sensor, 0 ~ 5V,  range 0 ~ 25MPa */
                      if(g_wireControlActualPressure >= 200) // >=20MPa
                      {
                              if(sensorFaultTimeCnt1 > 300)
                              {
                                      g_PressureSensorFaultFlag = TRUE;
                              }
                              else
                              {
                                      sensorFaultTimeCnt1++;
                              }
                      }
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 7   

                      
                      if(FALSE == gRTE_wireControlPressureLoopFlag)
                      {
                              if((g_wireControlObjPressure >= g_wireControlActualPressure) && (g_wireControlActualPressure >= 5)) // a
             -dded to avoid motor reversal motion, for the case of brake system pre-pressed
                              {
                                      if(normalTimeCnt1 > 10)
                                      {
                                              pressureLoopEnterFlag = TRUE;
                                      }
                                      else
                                      {
                                              normalTimeCnt1++;
                                      }
                              }
                              else
                              {
                                      normalTimeCnt1 = 0;
                              }
                      }
                      else
                      {
                              normalTimeCnt1 = 0;
                              if(g_wireControlObjPressure < 10)
                              {
                                      pressureLoopEnterFlag = FALSE;
                              }
                      }
                      
                      if((FALSE == g_ParkStateFlag) //non Parking state
                              && (FALSE == g_PressureSensorFaultFlag) //pressure sensor no fault
                              && (TRUE == pressureLoopEnterFlag)
                              && (FALSE == g_residualPressureFlag) //Logical determination of pipeline residual pressure
                              && (FALSE == g_systemAbnormalFlag)) //The system has no vibration abnormality
                      {
                              gRTE_wireControlPressureLoopFlag = TRUE;
                      }
                      else
                      {
                              gRTE_wireControlPressureLoopFlag = FALSE;
                              
                              residualPressureTimeCnt = 0;
                              residualPressureReleaseTimeCnt = 0;
                              stabiliseTimeCnt = 0;
                      }
                      
              #endif
  404  1      
  405  1      }
  406         
  407         
  408         /***********************************************************************
  409         *  Name        : Booster_LocationAndCurrentLoop
  410         *  Description : Booster control algorithm
  411         *  Parameter   : None
  412         *  Returns     : None
  413         ***********************************************************************/
  414         static void Booster_LocationAndCurrentLoop(void)
  415         {
  416  1              INT32U tempCylinderObjLoc = 0;
  417  1              INT32U tempDampCylinderObjLoc = 0;
  418  1              INT32U tempObjPressure = 0;
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 8   

  419  1              INT32U tempDampObjPressure = 0;
  420  1              const T_WIRE_CONTROL* ptr_WireControl = WireControl_AlogrithmData();
  421  1              
  422  1              /* Single - location ring differentiates assisted braking and wire - controlled braking.
  423  1                      The source of the target location is different */
  424  1              if(BoosterBrakeMode == BrakeSysMode)
  425  1              {
  426  2                      tempCylinderObjLoc = Booster_calcCylinderObjLocationFromPedal(tBooster.brakePedalLocation);
  427  2              }
  428  1              else if(WireCtrlBrakeMode == BrakeSysMode)
  429  1              {
  430  2                      if(FALSE == gRTE_wireControlPressureLoopFlag)
  431  2                      {
  432  3                              tempCylinderObjLoc = WireControl_PressureToCylinder(ptr_WireControl->cylinderObjPressure);
  433  3                      }
  434  2                      else
  435  2                      {
  436  3                              /* Pressure ring protection */
  437  3                              tempObjPressure = ptr_WireControl->cylinderObjPressure;
  438  3                              tBooster.protectCoeff = MIN(tBooster.cylinderDampCoeff, tBooster.temperatureProtectCoeff);
  439  3                              
  440  3                              tempDampObjPressure = tempObjPressure * tBooster.protectCoeff / PROTECT_INIT_COEFF;
  441  3                              if((tBooster.protectCoeff < PROTECT_INIT_COEFF) 
  442  3                                      && (tempObjPressure >= gRTE_dampMinPressure)
  443  3                                      && (tempDampObjPressure < gRTE_dampMinPressure))
  444  3                              {
  445  4                                      tempDampObjPressure = gRTE_dampMinPressure;
  446  4                              }
  447  3                              (void)Pid_PressureClosedLoopControl(tempDampObjPressure);
*** WARNING C192 IN LINE 447 OF src\app\alogrithm\booster.c: 'parameter 1': value truncated
  448  3                              return;
  449  3                      }
  450  2              }
  451  1              
  452  1              /*---------- Cylinder Damping Protection ----------------*/
  453  1              tBooster.protectCoeff = MIN(tBooster.cylinderDampCoeff, tBooster.temperatureProtectCoeff);
  454  1              tempDampCylinderObjLoc = tempCylinderObjLoc * tBooster.protectCoeff / PROTECT_INIT_COEFF;
  455  1              
  456  1              if((tBooster.protectCoeff < PROTECT_INIT_COEFF) 
  457  1                      && (tempCylinderObjLoc >= gRTE_dampMinCylinder)
  458  1                      && (tempDampCylinderObjLoc < gRTE_dampMinCylinder))
  459  1              {
  460  2                      tBooster.mainCylinderObjLocation = gRTE_dampMinCylinder;
  461  2              }
  462  1              else
  463  1              {
  464  2                      tBooster.mainCylinderObjLocation = (INT16U)tempDampCylinderObjLoc;
  465  2              }
  466  1              
  467  1              
  468  1              if(BoosterBrakeMode == BrakeSysMode)
  469  1              {
  470  2                      Booster_BrakeForceDistribution();
  471  2              }
  472  1              Booster_ClosedLoopControl();
  473  1      }
  474         
  475         /***********************************************************************
  476         *  Name        : Booster_OnlyLocationLoop
  477         *  Description : Booster control algorithm
  478         *  Parameter   : None
  479         *  Returns     : None
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 9   

  480         ***********************************************************************/
  481         static void Booster_OnlyLocationLoop(void)
  482         {
  483  1              INT32U tempCylinderObjLoc = 0;
  484  1              INT32U tempDampCylinderObjLoc = 0;
  485  1              INT32U tempObjPressure = 0;
  486  1              INT32U tempDampObjPressure = 0;
  487  1              const T_WIRE_CONTROL* ptr_WireControl = WireControl_AlogrithmData();
  488  1              
  489  1              /* Single - location ring differentiates assisted braking and wire - controlled braking.
  490  1                      The source of the target location is different */
  491  1              if(BoosterBrakeMode == BrakeSysMode)
  492  1              {
  493  2                      tempCylinderObjLoc = Booster_calcCylinderObjLocationFromPedal(tBooster.brakePedalLocation);
  494  2              }
  495  1              else if(WireCtrlBrakeMode == BrakeSysMode)
  496  1              {
  497  2                      if(FALSE == gRTE_wireControlPressureLoopFlag)
  498  2                      {
  499  3                              tempCylinderObjLoc = WireControl_PressureToCylinder(ptr_WireControl->cylinderObjPressure);
  500  3                      }
  501  2                      else
  502  2                      {
  503  3                              /* Pressure ring protection */
  504  3                              tempObjPressure = ptr_WireControl->cylinderObjPressure;
  505  3                              tBooster.protectCoeff = MIN(tBooster.cylinderDampCoeff, tBooster.temperatureProtectCoeff);
  506  3                              
  507  3                              tempDampObjPressure = tempObjPressure * tBooster.protectCoeff / PROTECT_INIT_COEFF;
  508  3                              if((tBooster.protectCoeff < PROTECT_INIT_COEFF) 
  509  3                                      && (tempObjPressure >= gRTE_dampMinPressure)
  510  3                                      && (tempDampObjPressure < gRTE_dampMinPressure))
  511  3                              {
  512  4                                      tempDampObjPressure = gRTE_dampMinPressure;
  513  4                              }
  514  3                              (void)Pid_PressureClosedLoopControl(tempDampObjPressure);
*** WARNING C192 IN LINE 514 OF src\app\alogrithm\booster.c: 'parameter 1': value truncated
  515  3                              return;
  516  3                      }
  517  2              }
  518  1              
  519  1              /*---------- Cylinder Damping Protection ----------------*/
  520  1              tBooster.protectCoeff = MIN(tBooster.cylinderDampCoeff, tBooster.temperatureProtectCoeff);
  521  1              tempDampCylinderObjLoc = tempCylinderObjLoc * tBooster.protectCoeff / PROTECT_INIT_COEFF;
  522  1              
  523  1              if((tBooster.protectCoeff < PROTECT_INIT_COEFF) 
  524  1                      && (tempCylinderObjLoc >= gRTE_dampMinCylinder)
  525  1                      && (tempDampCylinderObjLoc < gRTE_dampMinCylinder))
  526  1              {
  527  2                      tBooster.mainCylinderObjLocation = gRTE_dampMinCylinder;
  528  2              }
  529  1              else
  530  1              {
  531  2                      tBooster.mainCylinderObjLocation = (INT16U)tempDampCylinderObjLoc;
  532  2              }
  533  1              
  534  1              (void)Pid_OnlyLocationClosedLoopControl(tBooster.mainCylinderObjLocation);
  535  1      }
  536         
  537         
  538         /***********************************************************************
  539         *  Name        : Booster_OnlyCurrentLoop
  540         *  Description : Booster control algorithm
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 10  

  541         *  Parameter   : None
  542         *  Returns     : None
  543         ***********************************************************************/
  544         static void Booster_OnlyCurrentLoop(void)
  545         {
  546  1              INT16U feedForwardPwm = 0;
  547  1              INT16S feedBackPwm = 0;
  548  1              INT32U tempObjCurrent = 0;      
  549  1              INT32U tempDampObjCurrent = 0;
  550  1              INT32U tempObjPressure = 0;
  551  1              INT32U tempDampObjPressure = 0;
  552  1              const T_WIRE_CONTROL* ptr_WireControl = WireControl_AlogrithmData();
  553  1              
  554  1              /* Single - current ring differentiates assisted braking and wire - controlled braking.
  555  1                      The source of the target current is different */
  556  1              if(BoosterBrakeMode == BrakeSysMode)
  557  1              {
  558  2                      tempObjCurrent = Booster_calcMotorObjCurrentFromPedal(tBooster.brakePedalLocation);
  559  2              }
  560  1              else if(WireCtrlBrakeMode == BrakeSysMode)
  561  1              {
  562  2                      if((FALSE == gRTE_wireControlPressureLoopFlag) || (TRUE == g_cylinderExhaustEnFlag)) //Exhaust mode also
             - uses current PID
  563  2                      {
  564  3                              tempObjCurrent = WireControl_PressureToCurrent(ptr_WireControl->cylinderObjPressure);
  565  3                      }
  566  2                      else
  567  2                      {
  568  3                              /* Pressure ring protection */
  569  3                              tempObjPressure = ptr_WireControl->cylinderObjPressure;
  570  3                              tBooster.protectCoeff = MIN(tBooster.cylinderDampCoeff, tBooster.temperatureProtectCoeff);
  571  3                              
  572  3                              tempDampObjPressure = tempObjPressure * tBooster.protectCoeff / PROTECT_INIT_COEFF;
  573  3                              if((tBooster.protectCoeff < PROTECT_INIT_COEFF) 
  574  3                                      && (tempObjPressure > (gRTE_dampMinPressure - 500))
  575  3                                      && (tempDampObjPressure < gRTE_dampMinPressure))
  576  3                              {
  577  4                                      if(PROTECT_INIT_COEFF != tBooster.temperatureProtectCoeff)
  578  4                              {
  579  5                                              tempDampObjPressure = gRTE_dampMinPressure - 1000;
  580  5                                      }
  581  4                                      else
  582  4                                      {
  583  5                                              tempDampObjPressure = gRTE_dampMinPressure;
  584  5                              }
  585  4                              }
  586  3      
  587  3                              (void)Pid_PressureClosedLoopControl(tempDampObjPressure);
*** WARNING C192 IN LINE 587 OF src\app\alogrithm\booster.c: 'parameter 1': value truncated
  588  3                              return;
  589  3                      }
  590  2              }
  591  1              
  592  1              /*---------- Current Damping Protection ----------------*/
  593  1              tBooster.protectCoeff = MIN(tBooster.currentDampCoeff, tBooster.temperatureProtectCoeff);
  594  1              tempDampObjCurrent = tempObjCurrent * tBooster.protectCoeff / PROTECT_INIT_COEFF;
  595  1              
  596  1              if((tBooster.protectCoeff < PROTECT_INIT_COEFF) 
  597  1                      && (tempObjCurrent >= gRTE_dampMinCurrent)
  598  1                      && (tempDampObjCurrent < gRTE_dampMinCurrent))
  599  1              {
  600  2                      if(PROTECT_INIT_COEFF != tBooster.temperatureProtectCoeff)
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 11  

  601  2                      {
  602  3                              tBooster.brakeMotorObjCurrent = gRTE_dampMinCurrent - 400;
  603  3                      }
  604  2                      else
  605  2              {
  606  3                      tBooster.brakeMotorObjCurrent = gRTE_dampMinCurrent;
  607  3              }
  608  2              }
  609  1              else
  610  1              {
  611  2                      tBooster.brakeMotorObjCurrent = (INT16U)tempDampObjCurrent;
  612  2              }
  613  1      
  614  1              if(tBooster.brakeMotorObjCurrent > gRTE_controlMaxCurrent)
  615  1              {
  616  2                      tBooster.brakeMotorObjCurrent = gRTE_controlMaxCurrent; 
  617  2              }
  618  1              
  619  1              feedForwardPwm = Booster_calcForwardPwm(tBooster.brakeMotorObjCurrent);
  620  1              feedBackPwm = Pid_CurrentClosedLoopControl(tBooster.brakeMotorObjCurrent);
  621  1              tBooster.calcForwardPwm = feedForwardPwm;
  622  1              
  623  1              Pwm_Control(feedForwardPwm + feedBackPwm);
  624  1      }
  625         
  626         /***********************************************************************
  627         *  Name        : Booster_CalculateTemperatureProtectCoeff
  628         *  Description : Detect temperature to calculate setting main cylinder curve
  629         *                temperature protect compensation coeff, decline output PWM
  630         *                to protect brake motor.
  631         *  Parameter   : None
  632         *  Returns     : None
  633         ***********************************************************************/
  634         void Booster_CalculateTemperatureProtectCoeff(void)
  635         {
  636  1              static INT16U tempDetectCount = 0;
  637  1              static INT16U tempProtectCount = 0;
  638  1              static BOOLEAN highTemperatureFlag = FALSE;
  639  1              const T_ADC_APP *ptr_adcApp = AdcApp_SampleData();
  640  1      
  641  1              if (FALSE == highTemperatureFlag)
  642  1              {
  643  2                      /* Judge environment temperature higher than setting protect trigger condition,
  644  2                       * set compensation coeff to decline output to protect brake motor. */
  645  2                      if (ptr_adcApp->environmentTemperature >= TEMPERATURE_PROTECT_TRIGGER)
  646  2                      {
  647  3                              tempDetectCount++;
  648  3                              if (tempDetectCount > TEMPERATURE_PROTECT_DETECT_TIME)
  649  3                              {
  650  4                                      tempDetectCount = 0;
  651  4                                      highTemperatureFlag = TRUE;
  652  4                              }
  653  3                      }
  654  2                      else
  655  2                      {
  656  3                              tempProtectCount++;
  657  3                              if (tempProtectCount > TEMPERATURE_PROTECT_EXCUTE_TIME)
  658  3                              {
  659  4                                      tempProtectCount = 0;   
  660  4                                      if (tBooster.temperatureProtectCoeff < PROTECT_INIT_COEFF)
  661  4                                      {
  662  5                                              tBooster.temperatureProtectCoeff++;
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 12  

  663  5                                      }
  664  4                              }
  665  3                      }
  666  2              }
  667  1              else
  668  1              {
  669  2                      /* Judge environment temperature lower than release protect trigger condition,
  670  2                       * resume initialize coeff to make brake motor normal output. If keeping temperature
  671  2                       * protect more than timeout, further reduce output in cycle. */
  672  2                      if (ptr_adcApp->environmentTemperature <= TEMPERATURE_PROTECT_RELEASE)
  673  2                      {
  674  3                              tempDetectCount++;
  675  3                              if (tempDetectCount > TEMPERATURE_PROTECT_DETECT_TIME)
  676  3                              {
  677  4                                      tempDetectCount = 0;
  678  4                                      highTemperatureFlag = FALSE;
  679  4                              }
  680  3                      }
  681  2                      else
  682  2                      {
  683  3                              tempProtectCount++;
  684  3                              if (tempProtectCount > TEMPERATURE_PROTECT_EXCUTE_TIME)
  685  3                              {
  686  4                                      tempProtectCount = 0;   
  687  4                                      if (tBooster.temperatureProtectCoeff > TEMPERATURE_PROTECT_SET_COEFF)
  688  4                                      {
  689  5                                              tBooster.temperatureProtectCoeff--;
  690  5                                      }
  691  4                              }
  692  3                      }
  693  2              }
  694  1      }
  695         
  696         
  697         /***********************************************************************
  698         *  Name        : Booster_CalcTimeOutProtectCoef
  699         *  Description : The system PWM output time exceeds a certain value, reduces the output, protects the hard
             -ware 
  700         *  Parameter   : None
  701         *  Returns     : None
  702         ***********************************************************************/
  703         void Booster_CalcTimeOutProtectCoef(void)
  704         {
  705  1              static INT16U timeProtectCount = 0;
  706  1              static BOOLEAN timeOutFlag = FALSE;
  707  1              static INT8U dampRecoveryTimeCnt = 0;
  708  1              static INT8U g_wireControlObjPressureLast = 0;
  709  1              static INT8U brakeSwValidStsLast = 0;
  710  1              static INT8U pedalReturnFlag = FALSE;
  711  1              
  712  1              const T_PWM* Pwm_ptr = Pwm_ControlData();
  713  1              const T_ADC_APP *adcApp_ptr = AdcApp_SampleData();      
  714  1              const FLTD_faultActType* FLTDAct_ptr = FLTD_FltActFlgData();
  715  1              
  716  1              //Brake pedal return determination, used to remove protection and reset timer.
  717  1              if((TRUE == brakeSwValidStsLast) && (FALSE == g_inBrakeSwValidSts))
  718  1              {
  719  2                      pedalReturnFlag = TRUE;
  720  2                      dampRecoveryTimeCnt = 0;
  721  2              }
  722  1              else if((FALSE == brakeSwValidStsLast) && (TRUE == g_inBrakeSwValidSts))
  723  1              {
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 13  

  724  2                      pedalReturnFlag = FALSE;
  725  2              }
  726  1              brakeSwValidStsLast = g_inBrakeSwValidSts;
  727  1              
  728  1              //Reset the timer when the pedal return or brake request is released, whether protection is triggered or 
             -not.
  729  1              if(BoosterBrakeMode == BrakeSysMode)
  730  1              {
  731  2                      if((TRUE == pedalReturnFlag)
  732  2                              || ((FALSE == FLTDAct_ptr->fixedDecelerationFlg) && (adcApp_ptr->brakePedalLocation1 < BRAKE_PEDAL_LOCA
             -TION_VALID)))
  733  2                      {
  734  3                              timeDetectCount = 0;
  735  3                      }
  736  2              }
  737  1              else if(WireCtrlBrakeMode == BrakeSysMode)
  738  1              {
  739  2                      if(0 == g_wireControlObjPressure)
  740  2                      {
  741  3                              timeDetectCount = 0;
  742  3                      }
  743  2              }
  744  1              
  745  1              if(FALSE == timeOutFlag)
  746  1              {
  747  2                      dampRecoveryTimeCnt = 0;
  748  2                      if((Pwm_ptr->motorCtrl - PWM_AMPLITUDE_DEFAULT) >= gRTE_pwmProtectThreshold)
  749  2                      {
  750  3                              timeDetectCount++;
  751  3                              if(timeDetectCount > PWM_TIMEOUT_PROTECT_DETECT_TIME)
  752  3                              {
  753  4                                      timeDetectCount = 0;
  754  4                                      timeOutFlag = TRUE;
  755  4                              }
  756  3                      }
  757  2                      else
  758  2                      {
  759  3                              timeProtectCount++;
  760  3                              if(timeProtectCount > PWM_TIMEOUT_PROTECT_EXCUTE_TIME)
  761  3                              {
  762  4                                      timeProtectCount = 0;
  763  4                                      if (tBooster.currentDampCoeff < PROTECT_INIT_COEFF)
  764  4                                      {
  765  5                                              tBooster.currentDampCoeff++;
  766  5                                      }
  767  4                                      if (tBooster.cylinderDampCoeff < PROTECT_INIT_COEFF)
  768  4                                      {
  769  5                                              tBooster.cylinderDampCoeff++;
  770  5                                      }                                                       
  771  4                              }
  772  3                      }
  773  2              }
  774  1              else
  775  1              {
  776  2                      if(BoosterBrakeMode == BrakeSysMode)
  777  2                      {
  778  3                              /*In booster mode, exit protection restrictions if any of the following occurs
  779  3                               * 1) Pedal return.
  780  3                               * 2) The pedal makes a quick return journey.
  781  3                               * 3) After the wire control protection, the pedal actively intervenes
  782  3                               */
  783  3                              if((TRUE == pedalReturnFlag) || (tBooster.pedalRate < -140) || (TRUE == g_pedalInterveneFlag))
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 14  

  784  3                              {
  785  4                                      if(dampRecoveryTimeCnt > 10)
  786  4                                      {
  787  5                                              timeOutFlag = FALSE;
  788  5                                              timeDetectCount = 0;
  789  5                                      
  790  5                                              g_pedalInterveneFlag = FALSE;
  791  5                                              tBooster.currentDampCoeff = PROTECT_INIT_COEFF;
  792  5                                              tBooster.cylinderDampCoeff = PROTECT_INIT_COEFF;
  793  5                                      }
  794  4                                      else
  795  4                                      {
  796  5                                              dampRecoveryTimeCnt++;
  797  5                                      }
  798  4                              }
  799  3                      }
  800  2                      else if(WireCtrlBrakeMode == BrakeSysMode)
  801  2                      {
  802  3                              //if((0 == g_wireControlObjPressure) && (0 != g_wireControlObjPressureLast))
  803  3                              if((PROTECT_INIT_COEFF == tBooster.temperatureProtectCoeff)
  804  3                                      && (g_wireControlObjPressure < (gRTE_dampMinPressure / 100 - 5)))
  805  3                              {
  806  4                                      if(dampRecoveryTimeCnt > 10)
  807  4                              {
  808  5                                      timeOutFlag = FALSE;
  809  5                                      timeDetectCount = 0;
  810  5                                      
  811  5                                      tBooster.currentDampCoeff = PROTECT_INIT_COEFF;
  812  5                                      tBooster.cylinderDampCoeff = PROTECT_INIT_COEFF;
  813  5                              }
  814  4                                      else
  815  4                                      {
  816  5                                              dampRecoveryTimeCnt++;
  817  5                                      }
  818  4                              }
  819  3                              
  820  3                              g_wireControlObjPressureLast = g_wireControlObjPressure;
  821  3                      }
  822  2      
  823  2                      
  824  2                      timeProtectCount++;
  825  2                      if(timeProtectCount > PWM_TIMEOUT_PROTECT_EXCUTE_TIME)
  826  2                      {
  827  3                              timeProtectCount = 0;
  828  3      
  829  3                              if (tBooster.currentDampCoeff > CURRENT_PROTECT_SET_COEFF)
  830  3                              {
  831  4                                      tBooster.currentDampCoeff--;
  832  4                              }
  833  3                              if (tBooster.cylinderDampCoeff > CYLINDER_PROTECT_SET_COEFF)
  834  3                              {
  835  4                                      tBooster.cylinderDampCoeff--;
  836  4                              }
  837  3                      }
  838  2              }                  
  839  1      }
  840         
  841         
  842         /***********************************************************************
  843         *  Name        : Booster_calcCylinderObjLocationFromPedal
  844         *  Description : According to the brake pedal location to calculate the main cylinder object location.
  845         *  Parameter   : pedal Location
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 15  

  846         *  Returns     : None
  847         ***********************************************************************/
  848         static INT16U Booster_calcCylinderObjLocationFromPedal(INT16U pedalLoc)
  849         {
  850  1              INT16U tempMainCylinderObjLoc = 0;
  851  1              
  852  1              tempMainCylinderObjLoc = lookupTable_1D(pedalLoc, pedal_To_cylinder[0], pedal_To_cylinder[1], tBooster.pe
             -dalToCylinderArrayLength - 1);
  853  1              
  854  1              return tempMainCylinderObjLoc;
  855  1      }
  856         
  857         
  858         /***********************************************************************
  859         *  Name        : Booster_calcForwardCurrent
  860         *  Description : The feedforward current is calculated according to the target stroke of the master cylind
             -er and pedal pedal speed
  861         *  Parameter   : None
  862         *  Returns     : feed Forward Current
  863         ***********************************************************************/
  864         INT16U Booster_calcForwardCurrent(INT16U objLoc)
  865         {
  866  1              INT16U feedForwardCurrent = 0;
  867  1      
  868  1              feedForwardCurrent = lookupTable_1D(objLoc, cylinder_To_current[0], cylinder_To_current[1], tBooster.cyli
             -nderToCurrentArrayLength - 1);
  869  1      
  870  1              /* Calculate the compensation current based on the given current and pedal speed */
  871  1              Booster_CurrentCompensation(feedForwardCurrent); // polyspace test by gzz 2020.12.30
  872  1              
  873  1      #if 0
                      /* Pedal travel less than 2mm, the current is fixed at 2.2A, improve the motor response speed*/
                      if(ptr_adc->brakePedalLocation1 < 200)
                      {
                              feedForwardCurrent = 200;
                      }
              #endif
  880  1              
  881  1              return feedForwardCurrent;
  882  1      }
  883         
  884         
  885         /***********************************************************************
  886         *  Name        : Booster_calcForwardPwm
  887         *  Description : According to the PV characteristic, the target current is used to calculate the feed forw
             -ard PWM 
  888         *  Parameter   : void
  889         *  Returns     : feedForwardPwm
  890         ***********************************************************************/
  891         INT16U Booster_calcForwardPwm(INT16S objCurrent)
  892         {
  893  1              INT16U feedForwardPwm = 0;
  894  1              INT16U objCurrentAbsolute = 0;
  895  1              
  896  1              if(objCurrent <= 0)
  897  1              {
  898  2                      return 0;
  899  2              }
  900  1              else
  901  1              {
  902  2                      objCurrentAbsolute = objCurrent;
  903  2              }
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 16  

  904  1              
  905  1              feedForwardPwm = lookupTable_1D(objCurrentAbsolute, current_To_pwm[0], current_To_pwm[1], tBooster.curren
             -tToPwmArrayLength - 1);
  906  1      
  907  1              return feedForwardPwm;
  908  1      }
  909         
  910         
  911         /***********************************************************************
  912         *  Name        : Booster_calcMotorObjCurrentFromPedal
  913         *  Description : According to the brake pedal location to calculate the object current.
  914         *  Parameter   : pedal location
  915         *  Returns     : None
  916         ***********************************************************************/
  917         static INT16U Booster_calcMotorObjCurrentFromPedal(INT16U pedalLoc)
  918         {
  919  1              INT16U tempObjCurrent = 0;      
  920  1              
  921  1              tempObjCurrent = lookupTable_1D(pedalLoc, pedal_To_current[0], pedal_To_current[1], tBooster.pedalToCurre
             -ntArrayLength - 1);
  922  1              
  923  1              return tempObjCurrent;
  924  1      }
  925         
  926         
  927         /***********************************************************************
  928         *  Name        : Booster_PedalLocationRateCalculation
  929         *  Description : 
  930         *  Parameter   : None
  931         *  Returns     : None
  932         ***********************************************************************/
  933         static void Booster_PedalLocationRateCalculation(void)
  934         {
  935  1              static INT16U travel[4] = {0u};
  936  1              const T_ADC_APP *adcApp_ptr = AdcApp_SampleData();
  937  1              tBooster.pedalRate  = 2 * adcApp_ptr->brakePedalLocation1 + travel[3] - travel[1] - 2 * travel[0];
  938  1              
  939  1              /* update travel data buffer */
  940  1              travel[0] = travel[1];
  941  1              travel[1] = travel[2];
  942  1              travel[2] = travel[3];          
  943  1              travel[3] = adcApp_ptr->brakePedalLocation1;
  944  1      }
  945         
  946         /***********************************************************************
  947         *  Name        : Pid_CylinderLocationRateCalculation
  948         *  Description : 
  949         *  Parameter   : None
  950         *  Returns     : None
  951         ***********************************************************************/
  952         static void Booster_CylinderLocationRateCalculation(void)
  953         {
  954  1              static INT16U travel[4] = {0u};
  955  1              const T_ADC_APP *adcApp_ptr = AdcApp_SampleData();
  956  1      
  957  1              tBooster.cylinderRate = 2 * adcApp_ptr->mainCylinderLocation1 + travel[3] - travel[1] - 2 * travel[0];
  958  1      
  959  1              /* update travel data buffer */
  960  1              travel[0] = travel[1];
  961  1              travel[1] = travel[2];
  962  1              travel[2] = travel[3];  
  963  1              travel[3] = adcApp_ptr->mainCylinderLocation1;  
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 17  

  964  1      }
  965         
  966         
  967         
  968         /***********************************************************************
  969         *  Name        : Booster_CurrentCompensation
  970         *  Description : Calculate the compensation current based on the given current and pedal speed
  971         *  Parameter   : current value according to cylinder travel
  972         *  Returns     : compensation current
  973         ***********************************************************************/
  974         static INT16U Booster_CurrentCompensation(INT16U calcCurrent)
  975         {
  976  1              INT16U compensationCurrent = 0;
  977  1              INT16S pedalRate = 0;
  978  1              INT16S pedalRateTemp = 0;
  979  1              
  980  1              INT16U u=0; // temp var
  981  1      
  982  1              /* Calculate the pedal movement speed */
  983  1              pedalRate = tBooster.pedalRate * 5;
  984  1              if(pedalRate < -250)
  985  1              {
  986  2                      pedalRateTemp = -250;
  987  2              }
  988  1              else if(pedalRate > 250)
  989  1              {
  990  2                      pedalRateTemp = 250;
  991  2              }
  992  1              else
  993  1              {
  994  2                      pedalRateTemp = pedalRate;
  995  2              }
  996  1              pedalRateAccumulate = pedalRateAccumulate - pedalRateAccumulate / 64;
  997  1              pedalRateAccumulate = pedalRateAccumulate + pedalRateTemp;
  998  1              
  999  1              /* If the feedforward current is greater than 4.5A and the brake pedal in the return or very slow to go *
             -/
 1000  1              if((calcCurrent > 450) && (pedalRateAccumulate < 160))
 1001  1              {
 1002  2      //              pedalRateTemp = 160 - pedalRateAccumulate;
 1003  2      //              pedalRateTemp = pedalRateTemp / 80;
 1004  2      //              if(pedalRateTemp > 10)
 1005  2      //              {
 1006  2      //                      pedalRateTemp = 10;
 1007  2      //              }
 1008  2      //              compensationCurrent = - (pedalRateTemp * 100);
 1009  2                      
 1010  2                      /* modified by temp var u 20200330 */
 1011  2                      u = 160 - pedalRateAccumulate;
 1012  2                      u = u / 80;
 1013  2                      if(u > 10)
 1014  2                      {
 1015  3                              u = 10;
 1016  3                      }
 1017  2                      
 1018  2                      compensationCurrent =  (u * 100);
 1019  2                      /* modified by temp var u 20200330 end */               
 1020  2                      
 1021  2                      if(ABS(compensationCurrent) < 200)
*** WARNING C115 IN LINE 1021 OF src\app\alogrithm\booster.c: '-' applied to unsigned type, result still unsigned
 1022  2                      {
 1023  3                              compensationCurrent = 200;
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 18  

 1024  3                      }
 1025  2              }
 1026  1              else
 1027  1              {
 1028  2                      compensationCurrent = 0;
 1029  2              }
 1030  1              
 1031  1              return compensationCurrent;
 1032  1      }
 1033         
 1034         
 1035         /***********************************************************************
 1036         *  Name        : Booster_ClosedLoopControl
 1037         *  Description : Brake booster control alogrithm
 1038         *  Parameter   : None
 1039         *  Returns     : None
 1040         ***********************************************************************/
 1041         static void Booster_ClosedLoopControl(void)
 1042         {
 1043  1              INT16U feedForwardCurrent = 0; 
 1044  1              INT16S feedBackCurrent = 0;
 1045  1              
 1046  1              INT16U feedForwardPwm = 0; 
 1047  1              INT16S feedBackPwm = 0;
 1048  1              
 1049  1              feedForwardCurrent = Booster_calcForwardCurrent(tBooster.mainCylinderObjLocation);
 1050  1              feedBackCurrent = Pid_LocationClosedLoopControl(tBooster.mainCylinderObjLocation);
 1051  1              tBooster.calcForwardCurrent = feedForwardCurrent;
 1052  1              
 1053  1              tBooster.brakeMotorObjCurrent = feedForwardCurrent + feedBackCurrent;
 1054  1      
 1055  1              
 1056  1              /* The target current is not negative */        
 1057  1              if(tBooster.brakeMotorObjCurrent < 0)
 1058  1              {
 1059  2                      tBooster.brakeMotorObjCurrent = 0;
 1060  2              }
 1061  1              else if(tBooster.brakeMotorObjCurrent > gRTE_controlMaxCurrent)
 1062  1              {
 1063  2                      tBooster.brakeMotorObjCurrent = gRTE_controlMaxCurrent; 
 1064  2              }       
 1065  1              
 1066  1              feedForwardPwm = Booster_calcForwardPwm(tBooster.brakeMotorObjCurrent);
 1067  1              feedBackPwm = Pid_CurrentClosedLoopControl(tBooster.brakeMotorObjCurrent);
 1068  1              tBooster.calcForwardPwm = feedForwardPwm;
 1069  1              
 1070  1              Pwm_Control(feedForwardPwm + feedBackPwm);
 1071  1      }
 1072         
 1073         
 1074         
 1075         /***********************************************************************
 1076         *  Name        : Booster_JudgeEnergyRecoveryCondition
 1077         *  Description : Judge brake energy recovery condition
 1078         *  Parameter   : None
 1079         *  Returns     : None
 1080         ***********************************************************************/
 1081         static void Booster_JudgeEnergyRecoveryCondition(void)
 1082         {
 1083  1              const T_ADC_APP *ptr_adc = AdcApp_SampleData(); 
 1084  1      
 1085  1              /* Brake energy recovery condition include:
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 19  

 1086  1               * 1) MCU motor actual speed more than default value
 1087  1               * 2) brake pedal location less than 13mm(not emergency brake)
 1088  1               * 3) VCU allow brake energy recovery(CAN signal)
 1089  1               * 4) TODO:brake pedal location change speed meet condition 
 1090  1               */     
 1091  1              if ((VCU_VehicleSpeed > RB_END_OF_QUIT_SPEED)
 1092  1                      //&& (ptr_adc->brakePedalLocation1 < PEDAL_ENERGY_RECOVERY_RANG) 
 1093  1                      && (TRUE == MCU_AllowFeedbackFlag)
 1094  1                  && (tBooster.pedalRate < 250)
 1095  1                      && (FALSE == g_energyRecoverHitFlag)
 1096  1      //              && 0    // disable      // 20200921 am
 1097  1                      )
 1098  1              {
 1099  2                      tBooster.meetEnergyRecoveryCondition = TRUE;
 1100  2              }
 1101  1              else
 1102  1              {
 1103  2                      tBooster.meetEnergyRecoveryCondition = FALSE;
 1104  2              }
 1105  1              
 1106  1      }
 1107         
 1108         
 1109         /***********************************************************************
 1110         *  Name        : Booster_BrakeStatusMashine
 1111         *  Description : None
 1112         *  Parameter   : None
 1113         *  Returns     : None
 1114         ***********************************************************************/
 1115         static void Booster_BrakeStatusMashine(void)
 1116         {
 1117  1              FP32 u = 0.0;
 1118  1              static INT16U brakeStatusCount = 0u;
 1119  1              static INT16U hybridBrakeReleaseCount = 0u;
 1120  1              const T_ADC_APP *ptr_adc = AdcApp_SampleData();
 1121  1              static E_STATUS_BRAKE brakeStatusLast = STATUS_INIT_BRAKE;
 1122  1              
 1123  1              if(tBooster.brakeStatus != brakeStatusLast)
 1124  1              {
 1125  2                      brakeStatusCount = 0u;
 1126  2                      hybridBrakeReleaseCount = 0u;
 1127  2              }
 1128  1              brakeStatusLast = tBooster.brakeStatus;
 1129  1              
 1130  1              switch (tBooster.brakeStatus)
 1131  1              {
 1132  2                      case STATUS_INIT_BRAKE:
 1133  2                              g_energyRecoverHitFlag = FALSE;
 1134  2                              if (ptr_adc->brakePedalLocation1 > BRAKE_PEDAL_LOCATION_VALID)
 1135  2                              {
 1136  3                                      tBooster.brakeStatus = STATUS_FRICTION_BRAKE;
 1137  3                              }
 1138  2                              break;
 1139  2                              
 1140  2                      case STATUS_FRICTION_BRAKE:
 1141  2                              /* Not have brake switch signal and brake pedal resume init location, enter STATUS_TRANSIENT
 1142  2                               * get ready to return STATUS_INIT_BRAKE. */
 1143  2                              if (ptr_adc->brakePedalLocation1 <= BRAKE_PEDAL_LOCATION_VALID)
 1144  2                              {                               
 1145  3                                      tBooster.brakeStatus = STATUS_TRANSIENT;
 1146  3                              }
 1147  2      #if (ENABLE == FUNC_BRAKE_ENERGY_RECOVERY)
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 20  

                                      else
                                      {
                                              if(((VCU_VehicleSpeed < 2500))
                                                      || (VCU_VehicleSpeed > 7500)) // >75km/h
                                              {
                                                      g_energyRecoverHitFlag = TRUE;
                                              }
                                              
                                              Booster_JudgeEnergyRecoveryCondition();
                                              /* Meet brake energy recovery condition keeping 80*3ms enter STATUS_HYBRID_BRAKE. */
                                              if (TRUE == tBooster.meetEnergyRecoveryCondition)
                                              {               
                                                      tBooster.brakeStatus = STATUS_HYBRID_BRAKE;
                                              }
                                      }               
              #endif
 1164  2                              break;
 1165  2                              
 1166  2                      case STATUS_TRANSIENT:
 1167  2                              g_energyRecoverHitFlag = FALSE;
 1168  2                      
 1169  2                              if (ptr_adc->brakePedalLocation1 > BRAKE_PEDAL_LOCATION_VALID)
 1170  2                              {
 1171  3                                      tBooster.brakeStatus = STATUS_FRICTION_BRAKE;
 1172  3                              }
 1173  2                              else
 1174  2                              {
 1175  3                                      if(brakeStatusCount >= 80u)
 1176  3                                      {
 1177  4                                              tBooster.brakeStatus = STATUS_INIT_BRAKE;
 1178  4                                      }
 1179  3                                      else
 1180  3                                      {
 1181  4                                              brakeStatusCount++;
 1182  4                                      }
 1183  3                              }
 1184  2                              break;
 1185  2                              
 1186  2                      case STATUS_HYBRID_BRAKE:
 1187  2      
 1188  2                              Booster_JudgeEnergyRecoveryCondition();
 1189  2                      
 1190  2                              /* Not have brake switch signal and brake pedal resume init location, enter STATUS_TRANSIENT
 1191  2                               * get ready to return STATUS_INIT_BRAKE. */
 1192  2                              if (ptr_adc->brakePedalLocation1 <= BRAKE_PEDAL_LOCATION_VALID)
 1193  2                              {
 1194  3                                      tBooster.brakeStatus = STATUS_TRANSIENT;
 1195  3                              }
 1196  2                              else if((FALSE == tBooster.meetEnergyRecoveryCondition))                        
 1197  2                              {
 1198  3                                      /* If not meet brake energy recovery condition, enter STATUS_FRICTION_BRAKE at once*/
 1199  3                                      tBooster.brakeStatus = STATUS_FRICTION_BRAKE;
 1200  3                              }
 1201  2                              else if((VCU_VehicleSpeed < tBooster.rbQuitSpeed))
 1202  2                              {
 1203  3                                      tBooster.State4coef = 1;
 1204  3                                      tBooster.brakeStatus = STATUS_RELASE_HYBRID_BRAKE;
 1205  3                              }
 1206  2      
 1207  2                              break;
 1208  2      
 1209  2                      case STATUS_RELASE_HYBRID_BRAKE:
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 21  

 1210  2                              
 1211  2                              Booster_JudgeEnergyRecoveryCondition();
 1212  2                      
 1213  2                              /* Not have brake switch signal and brake pedal resume init location, enter STATUS_TRANSIENT
 1214  2                               * get ready to return STATUS_INIT_BRAKE. */
 1215  2                              if ((ptr_adc->brakePedalLocation1 <= BRAKE_PEDAL_LOCATION_VALID))
 1216  2                              {
 1217  3                                      tBooster.brakeStatus = STATUS_TRANSIENT;
 1218  3                              }       
 1219  2                              else if((FALSE == tBooster.meetEnergyRecoveryCondition))
 1220  2                              {
 1221  3                                      tBooster.brakeStatus = STATUS_FRICTION_BRAKE;                   
 1222  3                              }
 1223  2                              else 
 1224  2                              {
 1225  3                                  if( VCU_VehicleSpeed < RB_END_OF_QUIT_SPEED )
 1226  3                                      {
 1227  4                                              tBooster.brakeStatus = STATUS_FRICTION_BRAKE; 
 1228  4                                      }
 1229  3                                      else if(VCU_VehicleSpeed > tBooster.rbQuitSpeed)
 1230  3                                      {
 1231  4                                              if(hybridBrakeReleaseCount > 80)
 1232  4                                              {
 1233  5                                                      tBooster.brakeStatus = STATUS_HYBRID_BRAKE;
 1234  5                                              }
 1235  4                                              else
 1236  4                                              {
 1237  5                                                      hybridBrakeReleaseCount++;
 1238  5                                              }
 1239  4                                      }
 1240  3                                      else
 1241  3                                      {
 1242  4                                              u = VCU_VehicleSpeed - RB_END_OF_QUIT_SPEED;
 1243  4                                              tBooster.State4coef = u / (FP32)(tBooster.rbQuitSpeed - RB_END_OF_QUIT_SPEED);
 1244  4                                      }
 1245  3                              }
 1246  2      
 1247  2                              break;
 1248  2      
 1249  2                      default:
 1250  2                              brakeStatusCount = 0u;
 1251  2                              hybridBrakeReleaseCount = 0u;
 1252  2                              tBooster.brakeStatus = STATUS_INIT_BRAKE;
 1253  2                              break;
 1254  2              }
 1255  1      }
 1256                 
 1257         /***********************************************************************
 1258         *  Name        : Booster_BrakeForceDistribution
 1259         *  Description : Booster brake force distribution, include VCU motor torque and
 1260         *                brake motor friction torque.
 1261         *  Parameter   : None
 1262         *  Returns     : None
 1263         ***********************************************************************/
 1264         static void Booster_BrakeForceDistribution(void)
 1265         {
 1266  1              INT16U frictionObjLocation = 0;
 1267  1              static INT16U cylinderObjLocationDiff = 0;
 1268  1              static INT16S mcuMotorObjTorqueHybridBrakeLast = 0;
 1269  1              static INT16S mcuMotorObjTorqueReleaseHybridBrakeLast = 0;
 1270  1              
 1271  1              const T_ADC_APP *ptr_adc = AdcApp_SampleData();
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 22  

 1272  1              
 1273  1              frictionObjLocation = Booster_CylinderMinLocationCheck();
 1274  1              
 1275  1              tBooster.totalObjLocation = tBooster.mainCylinderObjLocation;
 1276  1              tBooster.frictionObjLocation = frictionObjLocation;
 1277  1              
 1278  1              switch (tBooster.brakeStatus)
 1279  1              {
 1280  2                      case STATUS_INIT_BRAKE:
 1281  2                              tBooster.totalTorqueRequest = 0;
 1282  2                              tBooster.frictionBrakeObjTorque = 0;
 1283  2                              tBooster.mcuMotorObjTorque = 0;
 1284  2                  iCAS_Brake_MotToqReq_Flag = 1;              
 1285  2                              break;
 1286  2      
 1287  2      
 1288  2                      case STATUS_FRICTION_BRAKE:
 1289  2                              tBooster.mcuMotorObjTorque = 0;
 1290  2                          iCAS_Brake_MotToqReq_Flag = 1;
 1291  2                              break;
 1292  2                      
 1293  2                      case STATUS_TRANSIENT:
 1294  2                              if(tBooster.mcuMotorObjTorque < -20)
 1295  2                              {
 1296  3                                      tBooster.mcuMotorObjTorque += 10;
 1297  3                                      iCAS_Brake_MotToqReq_Flag = 0;
 1298  3                              }
 1299  2                              else
 1300  2                              {
 1301  3                                      tBooster.mcuMotorObjTorque = 0;
 1302  3                                      iCAS_Brake_MotToqReq_Flag = 1;
 1303  3                              }
 1304  2                              break;
 1305  2      
 1306  2                      case STATUS_HYBRID_BRAKE:       
 1307  2      
 1308  2                              /* Use main cylinder location to calculate total brake torque request. */
 1309  2                              tBooster.totalTorqueRequest = Booster_CalculateBrakeTorque(tBooster.mainCylinderObjLocation);
 1310  2                      
 1311  2                              if(frictionObjLocation > MAIN_CYLINER_EMPTY_LOCATION)
 1312  2                              {
 1313  3                                      tBooster.frictionBrakeObjTorque = Booster_CalculateBrakeTorque(frictionObjLocation);    // sth strange he
             -re
 1314  3                              }
 1315  2                              else
 1316  2                              {
 1317  3                                      tBooster.frictionBrakeObjTorque = 0;
 1318  3                              }
 1319  2                              
 1320  2                              //tBooster.mcuMotorObjTorque = tBooster.totalTorqueRequest - tBooster.frictionBrakeObjTorque;
 1321  2                              tBooster.mcuMotorObjTorque = tBooster.totalTorqueRequest;
 1322  2                              
 1323  2                              /* The quit speed of regenerative braking is calculated according to the total braking force. */
 1324  2                              tBooster.rbQuitSpeed = Booster_RegenerationBrakeQuitSpeed(tBooster.totalTorqueRequest);
 1325  2                              
 1326  2                          if(tBooster.mcuMotorObjTorque < tBooster.mcuMotorMaxiumTorque)
 1327  2                              {
 1328  3                                      tBooster.mcuMotorObjTorque = tBooster.mcuMotorMaxiumTorque;
 1329  3                              }
 1330  2                              Booster_mcuObjTorqueCheck(&(tBooster.mcuMotorObjTorque));
 1331  2                              iCAS_Brake_MotToqReq_Flag = 0;
 1332  2                              
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 23  

 1333  2                              mcuMotorObjTorqueHybridBrakeLast = tBooster.mcuMotorObjTorque;
 1334  2                              mcuMotorObjTorqueReleaseHybridBrakeLast = mcuMotorObjTorqueHybridBrakeLast;
 1335  2                              cylinderObjLocationDiff = tBooster.mainCylinderObjLocation - frictionObjLocation;
 1336  2                              
 1337  2                              tBooster.mainCylinderObjLocation = frictionObjLocation;
 1338  2      
 1339  2                              break;
 1340  2      
 1341  2                      case STATUS_RELASE_HYBRID_BRAKE:
 1342  2      
 1343  2                              /* Use main cylinder location to calculate total brake torque request. */
 1344  2                              tBooster.totalTorqueRequest = Booster_CalculateBrakeTorque(tBooster.mainCylinderObjLocation);               
 1345  2                          tBooster.mcuMotorObjTorque = EnergyRecovery_BrakeTorqueReduction(mcuMotorObjTorqueHybridBrakeLast, t
             -Booster.State4coef);
 1346  2                              if(tBooster.mcuMotorObjTorque < mcuMotorObjTorqueReleaseHybridBrakeLast)
 1347  2                              {
 1348  3                                      tBooster.mcuMotorObjTorque = mcuMotorObjTorqueReleaseHybridBrakeLast;
 1349  3                              }
 1350  2                              
 1351  2                              if(tBooster.mcuMotorObjTorque < tBooster.mcuMotorMaxiumTorque)
 1352  2                              {
 1353  3                                      tBooster.mcuMotorObjTorque = tBooster.mcuMotorMaxiumTorque;
 1354  3                              }
 1355  2                              
 1356  2                              Booster_mcuObjTorqueCheck(&(tBooster.mcuMotorObjTorque));
 1357  2                              mcuMotorObjTorqueReleaseHybridBrakeLast = tBooster.mcuMotorObjTorque;
 1358  2                              
 1359  2                              
 1360  2                              tBooster.mainCylinderObjLocation = frictionObjLocation + EnergyRecovery_ObjLocationIncrement(cylinderOb
             -jLocationDiff, tBooster.State4coef);
 1361  2                      
 1362  2                              break;
 1363  2      
 1364  2                      default:
 1365  2                              tBooster.totalTorqueRequest = 0;
 1366  2                              tBooster.frictionBrakeObjTorque = 0;
 1367  2                              break;
 1368  2              }
 1369  1      }
 1370         
 1371         /***********************************************************************
 1372         *  Name        : Booster_mcuObjTorqueCheck(INT16S torque)
 1373         *  Description : There is a mechanical gap between the pedal and the cylinder, 
 1374         *  Parameter   : None
 1375         *  Returns     : None
 1376         ***********************************************************************/
 1377         static void Booster_mcuObjTorqueCheck(INT16S* torque)
 1378         {
 1379  1          INT16S rb_objtorque = 0;
 1380  1              
 1381  1              rb_objtorque = *torque;
 1382  1              
 1383  1              if(rb_objtorque >= MCU_MOTOR_TORQUE_DEFAULT)
 1384  1              {
 1385  2                 rb_objtorque = MCU_MOTOR_TORQUE_DEFAULT;
 1386  2              }
 1387  1              if(rb_objtorque <= MCU_MOTOR_TORQUE_MAX_LIMIT)
 1388  1              {
 1389  2                 rb_objtorque = MCU_MOTOR_TORQUE_MAX_LIMIT;
 1390  2              }       
 1391  1              
 1392  1          *torque = rb_objtorque;     
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 24  

 1393  1      }
 1394         
 1395         
 1396         /***********************************************************************
 1397         *  Name        : Booster_CylinderMinLocationCheck
 1398         *  Description : There is a mechanical gap between the pedal and the cylinder, 
 1399         *                                Limit the minimum position of the cylinder to avoid collision 
 1400         *                                with the pedal mandrel.
 1401         *  Parameter   : None
 1402         *  Returns     : None
 1403         ***********************************************************************/
 1404         static INT16U Booster_CylinderMinLocationCheck(void)
 1405         {
 1406  1              INT16U frictionCylinderObjLocation = 0;
 1407  1              const T_ADC_APP *ptr_adc = AdcApp_SampleData(); 
 1408  1              
 1409  1              if(ptr_adc->brakePedalLocation1 <= (MAIN_CYLINER_EMPTY_LOCATION + TOLERATE_COMPRESS_MAX_VALUE))
 1410  1              {
 1411  2                      //MAIN_CYLINER_EMPTY_LOCATION = 400(4mm)
 1412  2                      if(ptr_adc->brakePedalLocation1 < 100)
 1413  2                      {
 1414  3                              frictionCylinderObjLocation = tBooster.mainCylinderObjLocation;
 1415  3                      }
 1416  2                      else
 1417  2                      {
 1418  3                              //frictionCylinderObjLocation = ptr_adc->brakePedalLocation1 * 0.42 - 42;
 1419  3                              frictionCylinderObjLocation = ptr_adc->brakePedalLocation1 * 0.44 - 44;
 1420  3                      }
 1421  2              }
 1422  1              else if(tBooster.mainCylinderObjLocation > (ptr_adc->brakePedalLocation1 - TOLERATE_COMPRESS_MAX_VALUE)) 
             -// do not understand
 1423  1              {
 1424  2                      frictionCylinderObjLocation = ptr_adc->brakePedalLocation1 - TOLERATE_COMPRESS_MAX_VALUE;
 1425  2              }
 1426  1              else
 1427  1              {
 1428  2                      frictionCylinderObjLocation = tBooster.mainCylinderObjLocation;
 1429  2              }
 1430  1      
 1431  1              return frictionCylinderObjLocation;
 1432  1      }
 1433         
 1434         
 1435         
 1436         /***********************************************************************
 1437         *  Name        : Booster_CalculateMixBrakeCylinderLocationFromTorque
 1438         *  Description : According to friction brake object torque to calculate
 1439         *                brake main cylinder object location.
 1440         *  Parameter   : None
 1441         *  Returns     : brakeTorque
 1442         ***********************************************************************/
 1443         static INT16U Booster_CalculateMixBrakeCylinderLocationFromTorque(INT16S objTorque)
 1444         {
 1445  1              INT16U cylinderObjLocation = 0;
 1446  1      
 1447  1              if(objTorque >= 0)
 1448  1              {
 1449  2                      cylinderObjLocation = 0;
 1450  2              }
 1451  1              else if(objTorque > -192)
 1452  1              {
 1453  2                      cylinderObjLocation = -1.0417 * objTorque + 200;
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 25  

 1454  2              }
 1455  1              else if(objTorque > -800)
 1456  1              {
 1457  2                      cylinderObjLocation = -0.3289 * objTorque + 336.84;
 1458  2              }
 1459  1              else if(objTorque > -1650)
 1460  1              {
 1461  2                      cylinderObjLocation = -0.2353 * objTorque + 411.76;
 1462  2              }
 1463  1              else
 1464  1              {
 1465  2                      cylinderObjLocation = -0.16 * objTorque + 536;
 1466  2              }
 1467  1              
 1468  1              return cylinderObjLocation;
 1469  1      }
 1470         
 1471         
 1472         /***********************************************************************
 1473         *  Name        : Booster_CalculateBrakeTorque
 1474         *  Description : According to main cylinder location to calculate brake torque.
 1475         *  Parameter   : None
 1476         *  Returns     : brakeTorque
 1477         ***********************************************************************/
 1478         static INT16S Booster_CalculateBrakeTorque(INT16U objLoc)
 1479         {
 1480  1              INT16S brakeTorque = 0;
 1481  1              
 1482  1              if (objLoc < 100)
 1483  1              {
 1484  2                      brakeTorque = 0;
 1485  2              }
 1486  1              else if(objLoc < 200)
 1487  1              {
 1488  2                      brakeTorque = -1 * objLoc + 100; // polyspace test by gzz 2020.12.30
 1489  2              }
 1490  1              else if(objLoc < 400)
 1491  1              {
 1492  2                      brakeTorque = -2 * objLoc + 300;
 1493  2              }
 1494  1              else if(objLoc < 700)
 1495  1              {
 1496  2                      brakeTorque = -2.3333 * objLoc + 433.33;
 1497  2              }
 1498  1              else if(objLoc < 1000)
 1499  1              {
 1500  2                      brakeTorque = -1.3333 * objLoc - 266.67;
 1501  2              }
 1502  1              else if(objLoc < 1200)
 1503  1              {
 1504  2                      brakeTorque = -1600;
 1505  2              }
 1506  1      /*
 1507  1              else if(objLoc < 1600)
 1508  1              {
 1509  1                      brakeTorque = 0.5 * objLoc - 2200;
 1510  1              }
 1511  1              else if(objLoc < 1800)
 1512  1              {
 1513  1                      brakeTorque = 7 * objLoc - 12600;
 1514  1              }
 1515  1      */      
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 26  

 1516  1              else
 1517  1              {
 1518  2                      brakeTorque = -1600;
 1519  2              }
 1520  1              
 1521  1              if (brakeTorque > 0)
 1522  1              {
 1523  2                      brakeTorque = 0;
 1524  2              }
 1525  1      
 1526  1              return brakeTorque;
 1527  1      }
 1528         
 1529         
 1530         
 1531         
 1532         /***********************************************************************
 1533         *  Name        : Booster_RegenerationBrakeQuitSpeed
 1534         *  Description : regenerative brake quit speed.
 1535         *  Parameter   : None
 1536         *  Returns     : quitSpeed
 1537         ***********************************************************************/
 1538         static INT16U Booster_RegenerationBrakeQuitSpeed(INT16S torque)
 1539         {
 1540  1              INT16S tempTorque = 0; 
 1541  1              INT16U quitSpeed = 0;
 1542  1      
 1543  1              tempTorque = torque;
 1544  1      
 1545  1              quitSpeed = 1000 - tempTorque * 3 - tempTorque / 8;
 1546  1      
 1547  1              if (quitSpeed > RB_QUIT_SPEED1)
 1548  1              {
 1549  2                      quitSpeed = RB_QUIT_SPEED1;
 1550  2              }
 1551  1              else
 1552  1              {
 1553  2                      if (quitSpeed < RB_QUIT_SPEED2)
 1554  2                      {
 1555  3                              quitSpeed = RB_QUIT_SPEED2;
 1556  3                      }
 1557  2              }       
 1558  1              return quitSpeed;
 1559  1      }
 1560         
 1561         /***********************************************************************
 1562         *  Name        : Booster_PedalLocationPredict
 1563         *  Description : 
 1564         *  Parameter   : None
 1565         *  Returns     : None
 1566         ***********************************************************************/
 1567         static void Booster_PedalLocationPredict(void)
 1568         {
 1569  1              const T_ADC *adcPtr = Adc_SampleData();
 1570  1              static INT16S pedalRateFiltered = 0u;
 1571  1              INT16U pedalTravelAdc = 0u;
 1572  1              INT16U tempPedalRate = 0u;
 1573  1      
 1574  1              if(adcPtr->brakePedalTrip_Adc[0] < gRTE_pedalInitValue[0])
 1575  1              {
 1576  2                      pedalTravelAdc = gRTE_pedalInitValue[0];
 1577  2              }
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 27  

 1578  1              else
 1579  1              {
 1580  2                      pedalTravelAdc = adcPtr->brakePedalTrip_Adc[0] - gRTE_pedalInitValue[0];
 1581  2              }
 1582  1              
 1583  1              if(tBooster.pedalRate < pedalRateFiltered)
 1584  1              {
 1585  2                      tempPedalRate = pedalRateFiltered - tBooster.pedalRate + 8;
 1586  2                      tempPedalRate = tempPedalRate >> 4;
 1587  2                      pedalRateFiltered = pedalRateFiltered - tempPedalRate;
 1588  2              }
 1589  1              else
 1590  1              {
 1591  2                      tempPedalRate = tBooster.pedalRate - pedalRateFiltered + 8;
 1592  2                      tempPedalRate = tempPedalRate >> 4;
 1593  2                      pedalRateFiltered = pedalRateFiltered + tempPedalRate;
 1594  2              }
 1595  1              
 1596  1              if(pedalRateFiltered < 0)
 1597  1              {
 1598  2                      tempPedalRate = -pedalRateFiltered;
 1599  2                      tempPedalRate = tempPedalRate << 3;
 1600  2                      if(pedalTravelAdc < tempPedalRate)
 1601  2                      {
 1602  3                              tBooster.pedalPredictedLocation = 0u;
 1603  3                      }
 1604  2                      else
 1605  2                      {
 1606  3                              tBooster.pedalPredictedLocation = pedalTravelAdc - tempPedalRate;
 1607  3                      }
 1608  2              }
 1609  1              else
 1610  1              {
 1611  2                      tempPedalRate = tempPedalRate << 3;
 1612  2                      tBooster.pedalPredictedLocation = pedalTravelAdc + tempPedalRate;
 1613  2              }
 1614  1      }
 1615         
 1616         
 1617         
 1618         
 1619         
 1620         /***********************************************************************
 1621         *  Name        : Booster_AlogrithmData
 1622         *  Description : Brake booster control alogrithm data
 1623         *  Parameter   : None
 1624         *  Returns     : Brake booster control alogrithm data structure access address
 1625         ***********************************************************************/
 1626         const T_BOOSTER* Booster_AlogrithmData(void)
 1627         {
 1628  1              return (&tBooster);
 1629  1      }
 1630         
 1631         /* _END_OF_BOOSTER_ */
*** WARNING C174 IN LINE 1115 OF src\app\alogrithm\booster.c: 'Booster_BrakeStatusMashine': unreferenced 'static' functi
             -on
*** WARNING C174 IN LINE 1443 OF src\app\alogrithm\booster.c: 'Booster_CalculateMixBrakeCylinderLocationFromTorque': unr
             -eferenced 'static' function
*** WARNING C174 IN LINE 414 OF src\app\alogrithm\booster.c: 'Booster_LocationAndCurrentLoop': unreferenced 'static' fun
             -ction
*** WARNING C174 IN LINE 1567 OF src\app\alogrithm\booster.c: 'Booster_PedalLocationPredict': unreferenced 'static' func
             -tion
C166 COMPILER V7.57.0, BOOSTER                                                             01/20/2021 09:50:43 PAGE 28  

*** WARNING C174 IN LINE 481 OF src\app\alogrithm\booster.c: 'Booster_OnlyLocationLoop': unreferenced 'static' function


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        3472     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          41     --------
  FAR-DATA SIZE    =         224     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =         416     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  10 WARNING(S),  0 ERROR(S)
