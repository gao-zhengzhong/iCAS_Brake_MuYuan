C166 COMPILER V7.57.0, TASK3                                                               12/25/2020 20:36:12 PAGE 1   


C166 COMPILER V7.57.0, COMPILATION OF MODULE TASK3
OBJECT MODULE PLACED IN .\Obj\Task3.obj
COMPILER INVOKED BY: C:\Keil_v5\C166\BIN\C166.EXE src\app\task\Task3.c MODV2 LARGE BROWSE INCDIR(.\src;.\src\bsw;.\src\d
                    -river;.\src\interaction;.\src\app\adc;.\src\app\alogrithm;.\src\app\can;.\src\app\ccp;.\src\app\diagnostic;.\src\app\mod
                    -e control;.\src\app\task;.\src\app\Fun;.\src\app\rtos;.\src\bsw\can;.\src\bsw\desc;.\src\bsw\nm;.\src\app\time measure;.
                    -\src\app\rte) MODV2 DEBUG PRINT(.\Lst\Task3.lst) OBJECT(.\Obj\Task3.obj) 

 stmt lvl     source

    1         
    2         #include "MAIN.h"
    3         #include "can_diag.h"
    4         #include "rte.h"
    5         #include "FLTD.h"
    6         #include "adc_if.h"
    7         #include "pwm.h"
    8         #include "time_measure.h"
    9         #include "eepRom.h"
   10         #include "desc_ser.h"
   11         #include "adc_sample.h"
   12         #include "pid.h"
   13         #include "booster.h"
   14         
   15         #define MAIN_RELAY_OFF_DELAYTIME        8
   16         
   17         /*********************************************************************************************************
   18         *                                               VARIABLES
   19         *********************************************************************************************************/
   20         static EcmControlStates PowerUpTestState;
   21         static EcmControlStates PowerDownTestState;
   22         
   23         
   24         
   25         /*
   26         *********************************************************************************************************
   27         *                                          FUNCTION PROTOTYPES
   28         *********************************************************************************************************
   29         */
   30         void task3(void);
   31         void task3Normal_v_s(void);
   32         void task3PowerUpTest_v_s(void);
   33         void task3PowerDownTest_v_s(void);
   34         void task3PowerDown_v_s(void);
   35         void task3Fault_v_s(void);
   36         
   37         /*
   38         *********************************************************************************************************
   39         *                                             C ENTRY POINT
   40         *********************************************************************************************************
   41         */
   42         
   43         /*!************************************************************************************
   44         *       @fn             void task3(void)
   45         *       @brief            任务3函数
   46         *       @author     Matt Zhang
   47         *       @param[in]      void
   48         *       @return     void
   49         *       @note       在GPT1.c中GPT1_viTmr3()函数中调用
   50         *       @Data       2019-3-12
   51         ****************************************************************************************/
   52         
C166 COMPILER V7.57.0, TASK3                                                               12/25/2020 20:36:12 PAGE 2   

   53         void task3(void)
   54         {
   55  1              switch(SystemMode_u8_Sig)
   56  1              {
   57  2                      case PowerUpTestMode:
   58  2                              task3PowerUpTest_v_s();
   59  2                      break;
   60  2      
   61  2                      case NormalMode:
   62  2                              task3Normal_v_s();
   63  2                      break;
   64  2      
   65  2                      case FaultMode:
   66  2                              task3Fault_v_s();
   67  2                      break;
   68  2      
   69  2                      case PowerDownTestMode:
   70  2                              task3PowerDownTest_v_s();
   71  2                      break;
   72  2      
   73  2                      case PowerDownMode:
   74  2                              task3PowerDown_v_s();
   75  2                      break;
   76  2      
   77  2                      default:
   78  2      
   79  2                      break;
   80  2              }
   81  1      }
   82         /*!************************************************************************************
   83         *       @fn             void task3PowerUpTest_v_s(void)
   84         *       @brief            任务3上电测试函数
   85         *       @author     Matt Zhang
   86         *       @param[in]      void
   87         *       @return     void
   88         *       @note       此函 数是上电自检函数，每检测信号通过继续往下检测直至检测全部通过;在Task3.c的task3()函数中
   89         *       @Data       2019-3-12
   90         ****************************************************************************************/
   91         void task3PowerUpTest_v_s(void)
   92         {
   93  1              static INT8U initValueBuffer[5] = {0};
   94  1              const T_ADC_IF* ptr_AdcIf = AdcIf_InterfaceData();
   95  1              switch (PowerUpTestState) 
   96  1              {
   97  2                      case EcmStart:
   98  2      
   99  2                              IO_vSetPin(IO_P1_7); /* open main power */
  100  2                              IO_vSetPin(IO_P7_0); /* open pressure sensor power */
  101  2                              IO_vSetPin(IO_P7_1); /* open main cylinser sensor power */
  102  2                              IO_vSetPin(IO_P7_4); /* open pedal sensor power */
  103  2                              IO_vResetPin(IO_P6_2); /* close brake lamp */
  104  2      
  105  2                              PowerUpTestState = EcmWait1;
  106  2                      break;
  107  2      
  108  2                      case EcmWait1:
  109  2                              
  110  2                              //ICAS System pedal/cylinder init AD value parameters
  111  2                              ReadString_v_g(initValueBuffer, PEDAL_INIT_LOCATION_VALUE_ADDRESS, 5);
  112  2                              if(10 == initValueBuffer[4])
  113  2                              {
  114  3                                      g_calibrationParaChangeMask |= (0x00000001 << 5);
C166 COMPILER V7.57.0, TASK3                                                               12/25/2020 20:36:12 PAGE 3   

  115  3                                      
  116  3                                      gEEP_pedalLocationInit[0] = initValueBuffer[0];
  117  3                                      gEEP_pedalLocationInit[1] = initValueBuffer[1];
  118  3                                      gRTE_pedalInitValue[0] = gEEP_pedalLocationInit[0];
  119  3                                      gRTE_pedalInitValue[1] = gEEP_pedalLocationInit[1];
  120  3                                      
  121  3                                      gEEP_cylinderLocationInit[0] = initValueBuffer[2];
  122  3                                      gEEP_cylinderLocationInit[1] = initValueBuffer[3];
  123  3                                      gRTE_cylinderInitValue[0] = gEEP_cylinderLocationInit[0];
  124  3                                      gRTE_cylinderInitValue[1] = gEEP_cylinderLocationInit[1];
  125  3                              }
  126  2                              else
  127  2                              {
  128  3                                      gRTE_pedalInitValue[0] = BRAKE_PEDAL_INIT_LOCATION;
  129  3                                      gRTE_pedalInitValue[1] = BRAKE_PEDAL_INIT_LOCATION / 2;
  130  3                                      gRTE_cylinderInitValue[0] = MAIN_CYLINDER_INIT_LOCATION;
  131  3                                      gRTE_cylinderInitValue[1] = MAIN_CYLINDER_INIT_LOCATION / 2;
  132  3                              }
  133  2      #if 0
                                      if(TRUE == Rte_ReadEepromData(gEEP_pedalLocationInit, PEDAL_INIT_LOCATION_VALUE_ADDRESS, PEDAL_INIT_LOC
             -ATION_VALUE_LENGTH))
                                      {
                                              Std_DataCopy(gEEP_pedalLocationInit, gRTE_pedalInitValue, PEDAL_INIT_LOCATION_VALUE_LENGTH - 1);
                                              g_calibrationParaChangeMask |= (0x00000001 << 5);
                                      }
                                      else
                                      {
                                              gRTE_pedalInitValue[0] = BRAKE_PEDAL_INIT_LOCATION;
                                              gRTE_pedalInitValue[1] = BRAKE_PEDAL_INIT_LOCATION / 2;
                                              Std_DataCopy(gRTE_pedalInitValue, gEEP_pedalLocationInit, PEDAL_INIT_LOCATION_VALUE_LENGTH - 1);
                                      }
                                      
                                      if(TRUE == Rte_ReadEepromData(gEEP_cylinderLocationInit, CYLINDER_INIT_LOCATION_VALUE_ADDRESS, CYLINDER
             -_INIT_LOCATION_VALUE_LENGTH))
                                      {
                                              Std_DataCopy(gEEP_cylinderLocationInit, gRTE_cylinderInitValue, CYLINDER_INIT_LOCATION_VALUE_LENGTH - 
             -1);
                                              g_calibrationParaChangeMask |= (0x00000001 << 6);
                                      }
                                      else
                                      {
                                              gRTE_cylinderInitValue[0] = MAIN_CYLINDER_INIT_LOCATION;
                                              gRTE_cylinderInitValue[1] = MAIN_CYLINDER_INIT_LOCATION / 2;
                                              Std_DataCopy(gRTE_cylinderInitValue, gEEP_cylinderLocationInit, CYLINDER_INIT_LOCATION_VALUE_LENGTH - 
             -1);
                                      }
              #endif
  158  2                      
  159  2                              //Controlled attenuation protection
  160  2                              if(TRUE == Rte_ReadEepromData(gEEP_pwmProtectThreshold, PWM_PROTECT_FAULT_VALUE_ADDRESS, PWM_PROTECT_FA
             -ULT_VALUE_LENGTH))
  161  2                              {
  162  3                                      Std_DataCopy(gEEP_pwmProtectThreshold, &gRTE_pwmProtectThreshold, PWM_PROTECT_FAULT_VALUE_LENGTH - 1);
  163  3                                      g_calibrationParaChangeMask |= (0x00000001);
  164  3                              }
  165  2                              else
  166  2                              {
  167  3                                      gRTE_pwmProtectThreshold = PWM_TIMEOUT_PROTECT_TRIGGER;
  168  3                                      Std_DataCopy(&gRTE_pwmProtectThreshold, gEEP_pwmProtectThreshold, PWM_PROTECT_FAULT_VALUE_LENGTH - 1);
  169  3                              }
  170  2                              if(TRUE == Rte_ReadEepromData(gEEP_controlMaxCurrent, MAX_OBJ_CURRENT_VALUE_ADDRESS, MAX_OBJ_CURRENT_VA
             -LUE_LENGTH))
C166 COMPILER V7.57.0, TASK3                                                               12/25/2020 20:36:12 PAGE 4   

  171  2                              {
  172  3                                      Std_DataCopy(gEEP_controlMaxCurrent, &gRTE_controlMaxCurrent, MAX_OBJ_CURRENT_VALUE_LENGTH - 1);
  173  3                                      g_calibrationParaChangeMask |= (0x00000001 << 1);
  174  3                              }
  175  2                              else
  176  2                              {
  177  3                                      gRTE_controlMaxCurrent = MAX_OBJECT_CURRENT;
  178  3                                      Std_DataCopy(&gRTE_controlMaxCurrent, gEEP_controlMaxCurrent, MAX_OBJ_CURRENT_VALUE_LENGTH - 1);
  179  3                              }
  180  2                              if(TRUE == Rte_ReadEepromData(gEEP_dampMinCylinder, DAMP_MIN_CYLINDER_VALUE_ADDRESS, DAMP_MIN_CYLINDER_
             -VALUE_LENGTH))
  181  2                              {
  182  3                                      Std_DataCopy(gEEP_dampMinCylinder, &gRTE_dampMinCylinder, DAMP_MIN_CYLINDER_VALUE_LENGTH - 1);
  183  3                                      g_calibrationParaChangeMask |= (0x00000001 << 2);
  184  3                              }
  185  2                              else
  186  2                              {
  187  3                                      gRTE_dampMinCylinder = DAMPING_MIN_CYLINDER;
  188  3                                      Std_DataCopy(&gRTE_dampMinCylinder, gEEP_dampMinCylinder, DAMP_MIN_CYLINDER_VALUE_LENGTH - 1);
  189  3                              }
  190  2                              if(TRUE == Rte_ReadEepromData(gEEP_dampMinCurrent, DAMP_MIN_CURRENT_VALUE_ADDRESS, DAMP_MIN_CURRENT_VAL
             -UE_LENGTH))
  191  2                              {
  192  3                                      Std_DataCopy(gEEP_dampMinCurrent, &gRTE_dampMinCurrent, DAMP_MIN_CURRENT_VALUE_LENGTH - 1);
  193  3                                      g_calibrationParaChangeMask |= (0x00000001 << 3);
  194  3                              }
  195  2                              else
  196  2                              {
  197  3                                      gRTE_dampMinCurrent = DAMPING_MIN_CURRENT;
  198  3                                      Std_DataCopy(&gRTE_dampMinCurrent, gEEP_dampMinCurrent, DAMP_MIN_CURRENT_VALUE_LENGTH - 1);
  199  3                              }
  200  2                              if(TRUE == Rte_ReadEepromData(gEEP_dampMinPressure, DAMP_MIN_PRESSURE_VALUE_ADDRESS, DAMP_MIN_PRESSURE_
             -VALUE_LENGTH))
  201  2                              {
  202  3                                      Std_DataCopy(gEEP_dampMinPressure, &gRTE_dampMinPressure, DAMP_MIN_PRESSURE_VALUE_LENGTH - 1);
  203  3                                      g_calibrationParaChangeMask |= (0x00000001 << 4);
  204  3                              }
  205  2                              else
  206  2                              {
  207  3                                      gRTE_dampMinPressure = DAMPING_MIN_PRESSURE;
  208  3                                      Std_DataCopy(&gRTE_dampMinPressure, gEEP_dampMinPressure, DAMP_MIN_PRESSURE_VALUE_LENGTH - 1);
  209  3                              }
  210  2      
  211  2                              PowerUpTestState = EcmWait2;
  212  2                      break;
  213  2      
  214  2                      case EcmWait2:
  215  2                              
  216  2                              //Position loop PID, KP, KI, KD term parameters
  217  2                              if(TRUE == Rte_ReadEepromData(gEEP_locationKp, LOCATION_LOOP_KP_ADDRESS, PID_PARA_LENGTH))
  218  2                              {
  219  3                                      Std_DataCopy(gEEP_locationKp, &gRTE_locationKp, PID_PARA_LENGTH - 1);
  220  3                                      g_calibrationParaChangeMask |= (0x00000001 << 7);
  221  3                              }
  222  2                              else
  223  2                              {
  224  3                                      gRTE_locationKp = PID_PARA_LOCATION_Kp;
  225  3                                      Std_DataCopy(&gRTE_locationKp, gEEP_locationKp, PID_PARA_LENGTH - 1);
  226  3                              }
  227  2                              
  228  2                              if(TRUE == Rte_ReadEepromData(gEEP_locationKi, LOCATION_LOOP_KI_ADDRESS, PID_PARA_LENGTH))
  229  2                              {
C166 COMPILER V7.57.0, TASK3                                                               12/25/2020 20:36:12 PAGE 5   

  230  3                                      Std_DataCopy(gEEP_locationKi, &gRTE_locationKi, PID_PARA_LENGTH - 1);
  231  3                                      g_calibrationParaChangeMask |= (0x00000001 << 8);
  232  3                              }
  233  2                              else
  234  2                              {
  235  3                                      gRTE_locationKi = PID_PARA_LOCATION_Ki;
  236  3                                      Std_DataCopy(&gRTE_locationKi, gEEP_locationKi, PID_PARA_LENGTH - 1);
  237  3                              }
  238  2                              if(TRUE == Rte_ReadEepromData(gEEP_locationKd, LOCATION_LOOP_KD_ADDRESS, PID_PARA_LENGTH))
  239  2                              {
  240  3                                      Std_DataCopy(gEEP_locationKd, &gRTE_locationKd, PID_PARA_LENGTH - 1);
  241  3                                      g_calibrationParaChangeMask |= (0x00000001 << 9);
  242  3                              }
  243  2                              else
  244  2                              {
  245  3                                      gRTE_locationKd = PID_PARA_LOCATION_Kd;
  246  3                                      Std_DataCopy(&gRTE_locationKd, gEEP_locationKd, PID_PARA_LENGTH - 1);
  247  3                              }
  248  2                              
  249  2      
  250  2                              //Current loop PID, KP, KI, KD term parameters
  251  2                              if(TRUE == Rte_ReadEepromData(gEEP_currentKp, CURRENT_LOOP_KP_ADDRESS, PID_PARA_LENGTH))
  252  2                              {
  253  3                                      Std_DataCopy(gEEP_currentKp, &gRTE_currentKp, PID_PARA_LENGTH - 1);
  254  3                                      g_calibrationParaChangeMask |= (0x00000001 << 10);
  255  3                              }
  256  2                              else
  257  2                              {
  258  3                                      gRTE_currentKp = PID_PARA_CURRENT_Kp;
  259  3                                      Std_DataCopy(&gRTE_currentKp, gEEP_currentKp, PID_PARA_LENGTH - 1);
  260  3                              }
  261  2                              if(TRUE == Rte_ReadEepromData(gEEP_currentKi, CURRENT_LOOP_KI_ADDRESS, PID_PARA_LENGTH))
  262  2                              {
  263  3                                      Std_DataCopy(gEEP_currentKi, &gRTE_currentKi, PID_PARA_LENGTH - 1);
  264  3                                      g_calibrationParaChangeMask |= (0x00000001 << 11);
  265  3                              }
  266  2                              else
  267  2                              {
  268  3                                      gRTE_currentKi = PID_PARA_CURRENT_Ki;
  269  3                                      Std_DataCopy(&gRTE_currentKi, gEEP_currentKi, PID_PARA_LENGTH - 1);
  270  3                              }
  271  2                              if(TRUE == Rte_ReadEepromData(gEEP_currentKd, CURRENT_LOOP_KD_ADDRESS, PID_PARA_LENGTH))
  272  2                              {
  273  3                                      Std_DataCopy(gEEP_currentKd, &gRTE_currentKd, PID_PARA_LENGTH - 1);
  274  3                                      g_calibrationParaChangeMask |= (0x00000001 << 12);
  275  3                              }
  276  2                              else
  277  2                              {
  278  3                                      gRTE_currentKd = PID_PARA_CURRENT_Kd;
  279  3                                      Std_DataCopy(&gRTE_currentKd, gEEP_currentKd, PID_PARA_LENGTH - 1);
  280  3                              }
  281  2      
  282  2                              //only position loop PID, KP, KI, KD term parameters
  283  2                              if(TRUE == Rte_ReadEepromData(gEEP_onlyPositionKp, ONLYLOCATION_LOOP_KP_ADDRESS, PID_PARA_LENGTH))
  284  2                              {
  285  3                                      Std_DataCopy(gEEP_onlyPositionKp, &gRTE_onlyPositionKp, PID_PARA_LENGTH - 1);
  286  3                                      g_calibrationParaChangeMask |= (0x00000001 << 13);
  287  3                              }
  288  2                              else
  289  2                              {
  290  3                                      gRTE_onlyPositionKp = PID_PARA_ONLYLOCATION_Kp;
  291  3                                      Std_DataCopy(&gRTE_onlyPositionKp, gEEP_onlyPositionKp, PID_PARA_LENGTH - 1);
C166 COMPILER V7.57.0, TASK3                                                               12/25/2020 20:36:12 PAGE 6   

  292  3                              }
  293  2                              if(TRUE == Rte_ReadEepromData(gEEP_onlyPositionKi, ONLYLOCATION_LOOP_KI_ADDRESS, PID_PARA_LENGTH))
  294  2                              {
  295  3                                      Std_DataCopy(gEEP_onlyPositionKi, &gRTE_onlyPositionKi, PID_PARA_LENGTH - 1);
  296  3                                      g_calibrationParaChangeMask |= (0x00000001 << 14);
  297  3                              }
  298  2                              else
  299  2                              {
  300  3                                      gRTE_onlyPositionKi = PID_PARA_ONLYLOCATION_Ki;
  301  3                                      Std_DataCopy(&gRTE_onlyPositionKi, gEEP_onlyPositionKi, PID_PARA_LENGTH - 1);
  302  3                              }
  303  2                              if(TRUE == Rte_ReadEepromData(gEEP_onlyPositionKd, ONLYLOCATION_LOOP_KD_ADDRESS, PID_PARA_LENGTH))
  304  2                              {
  305  3                                      Std_DataCopy(gEEP_onlyPositionKd, &gRTE_onlyPositionKd, PID_PARA_LENGTH - 1);
  306  3                                      g_calibrationParaChangeMask |= (0x00000001 << 15);
  307  3                              }
  308  2                              else
  309  2                              {
  310  3                                      gRTE_onlyPositionKd = PID_PARA_ONLYLOCATION_Kd;
  311  3                                      Std_DataCopy(&gRTE_onlyPositionKd, gEEP_onlyPositionKd, PID_PARA_LENGTH - 1);
  312  3                              }
  313  2                              
  314  2                              //pressure loop PID, KP, KI, KD term parameters
  315  2                              if(TRUE == Rte_ReadEepromData(gEEP_pressureKp, PRESSURE_LOOP_KP_ADDRESS, PID_PARA_LENGTH))
  316  2                              {
  317  3                                      Std_DataCopy(gEEP_pressureKp, &gRTE_pressureKp, PID_PARA_LENGTH - 1);
  318  3                                      g_calibrationParaChangeMask |= ((INT32U)0x00000001 << 16);
  319  3                              }
  320  2                              else
  321  2                              {
  322  3                                      gRTE_pressureKp = PID_PARA_PRESSURE_Kp;
  323  3                                      Std_DataCopy(&gRTE_pressureKp, gEEP_pressureKp, PID_PARA_LENGTH - 1);
  324  3                              }
  325  2                              if(TRUE == Rte_ReadEepromData(gEEP_pressureKi, PRESSURE_LOOP_KI_ADDRESS, PID_PARA_LENGTH))
  326  2                              {
  327  3                                      Std_DataCopy(gEEP_pressureKi, &gRTE_pressureKi, PID_PARA_LENGTH - 1);
  328  3                                      g_calibrationParaChangeMask |= ((INT32U)0x00000001 << 17);
  329  3                              }
  330  2                              else
  331  2                              {
  332  3                                      gRTE_pressureKi = PID_PARA_PRESSURE_Ki;
  333  3                                      Std_DataCopy(&gRTE_pressureKi, gEEP_pressureKi, PID_PARA_LENGTH - 1);
  334  3                              }
  335  2                              if(TRUE == Rte_ReadEepromData(gEEP_pressureKd, PRESSURE_LOOP_KD_ADDRESS, PID_PARA_LENGTH))
  336  2                              {
  337  3                                      Std_DataCopy(gEEP_pressureKd, &gRTE_pressureKd, PID_PARA_LENGTH - 1);
  338  3                                      g_calibrationParaChangeMask |= ((INT32U)0x00000001 << 18);
  339  3                              }
  340  2                              else
  341  2                              {
  342  3                                      gRTE_pressureKd = PID_PARA_PRESSURE_Kd;
  343  3                                      Std_DataCopy(&gRTE_pressureKd, gEEP_pressureKd, PID_PARA_LENGTH - 1);
  344  3                              }
  345  2                              
  346  2                              PowerUpTestState = EcmWait3;
  347  2                      break;
  348  2      
  349  2                      case EcmWait3:
  350  2                              ReadString_v_g(&g_longTimeBrakeCnt, LONG_TIME_BRAKE_ADDRESS, LONG_TIME_BRAKE_LENGTH);
*** WARNING C98 IN LINE 350 OF src\app\task\Task3.c: parameter 1: pointer to different objects
  351  2                      
  352  2                              //read booster parameter
C166 COMPILER V7.57.0, TASK3                                                               12/25/2020 20:36:12 PAGE 7   

  353  2                              if(TRUE == Rte_ReadEepromData(gEEP_pedal_To_cylinder, PEDAL_TO_CYLINDER_ADDRESS, PEDAL_TO_CYLINDER_LENG
             -TH))
  354  2                              {
  355  3                                      Std_DataCopy(gEEP_pedal_To_cylinder, pedal_To_cylinder, PEDAL_TO_CYLINDER_LENGTH - 1);
  356  3                                      g_calibrationParaChangeMask |= ((INT32U)0x00000001 << 19);
  357  3                              }
  358  2                              else
  359  2                              {
  360  3                                      Std_DataCopy(pedal_To_cylinder, gEEP_pedal_To_cylinder, PEDAL_TO_CYLINDER_LENGTH - 1);
  361  3                              }
  362  2                              if(TRUE == Rte_ReadEepromData(gEEP_cylinder_To_current, CYLINDER_TO_CURRENT_ADDRESS, CYLINDER_TO_CURREN
             -T_LENGTH))
  363  2                              {
  364  3                                      Std_DataCopy(gEEP_cylinder_To_current, cylinder_To_current, CYLINDER_TO_CURRENT_LENGTH - 1);
  365  3                                      g_calibrationParaChangeMask |= ((INT32U)0x00000001 << 20);
  366  3                              }
  367  2                              else
  368  2                              {
  369  3                                      Std_DataCopy(cylinder_To_current, gEEP_cylinder_To_current, CYLINDER_TO_CURRENT_LENGTH - 1);
  370  3                              }
  371  2                              if(TRUE == Rte_ReadEepromData(gEEP_current_To_pwm, CURRENT_TO_PWM_ADDRESS, CURRENT_TO_PWM_LENGTH))
  372  2                              {
  373  3                                      Std_DataCopy(gEEP_current_To_pwm, current_To_pwm, CURRENT_TO_PWM_LENGTH - 1);
  374  3                                      g_calibrationParaChangeMask |= ((INT32U)0x00000001 << 21);
  375  3                              }
  376  2                              else
  377  2                              {
  378  3                                      Std_DataCopy(current_To_pwm, gEEP_current_To_pwm, CURRENT_TO_PWM_LENGTH - 1);
  379  3                              }
  380  2                              if(TRUE == Rte_ReadEepromData(gEEP_pedal_To_current, PEDAL_TO_CURRENT_ADDRESS, PEDAL_TO_CURRENT_LENGTH)
             -)
  381  2                              {
  382  3                                      Std_DataCopy(gEEP_pedal_To_current, pedal_To_current, PEDAL_TO_CURRENT_LENGTH - 1);
  383  3                                      g_calibrationParaChangeMask |= ((INT32U)0x00000001 << 22);
  384  3                              }
  385  2                              else
  386  2                              {
  387  3                                      Std_DataCopy(pedal_To_current, gEEP_pedal_To_current, PEDAL_TO_CURRENT_LENGTH - 1);
  388  3                              }
  389  2                      
  390  2                              //read wireControl parameter
  391  2                              if(TRUE == Rte_ReadEepromData(gEEP_pressure_To_cylinder, PRESSURE_TO_CYLINDER_ADDRESS, PRESSURE_TO_CYLI
             -NDER_LENGTH))
  392  2                              {
  393  3                                      Std_DataCopy(gEEP_pressure_To_cylinder, pressure_To_cylinder, PRESSURE_TO_CYLINDER_LENGTH - 1);
  394  3                                      g_calibrationParaChangeMask |= ((INT32U)0x00000001 << 23);
  395  3                              }
  396  2                              else
  397  2                              {
  398  3                                      Std_DataCopy(pressure_To_cylinder, gEEP_pressure_To_cylinder, PRESSURE_TO_CYLINDER_LENGTH - 1);
  399  3                              }
  400  2                              if(TRUE == Rte_ReadEepromData(gEEP_cylinder_To_pressure, CYLINDER_TO_PRESSURE_ADDRESS, CYLINDER_TO_PRES
             -SURE_LENGTH))
  401  2                              {
  402  3                                      Std_DataCopy(gEEP_cylinder_To_pressure, cylinder_To_pressure, CYLINDER_TO_PRESSURE_LENGTH - 1);
  403  3                                      g_calibrationParaChangeMask |= ((INT32U)0x00000001 << 24);
  404  3                              }
  405  2                              else
  406  2                              {
  407  3                                      Std_DataCopy(cylinder_To_pressure, gEEP_cylinder_To_pressure, CYLINDER_TO_PRESSURE_LENGTH - 1);
  408  3                              }
  409  2                              if(TRUE == Rte_ReadEepromData(gEEP_current_To_pressure, CURRENT_TO_PRESSURE_ADDRESS, CURRENT_TO_PRESSUR
C166 COMPILER V7.57.0, TASK3                                                               12/25/2020 20:36:12 PAGE 8   

             -E_LENGTH))
  410  2                              {
  411  3                                      Std_DataCopy(gEEP_current_To_pressure, current_To_pressure, CURRENT_TO_PRESSURE_LENGTH - 1);
  412  3                                      g_calibrationParaChangeMask |= ((INT32U)0x00000001 << 25);
  413  3                              }
  414  2                              else
  415  2                              {
  416  3                                      Std_DataCopy(current_To_pressure, gEEP_current_To_pressure, CURRENT_TO_PRESSURE_LENGTH - 1);
  417  3                              }
  418  2                              if(TRUE == Rte_ReadEepromData(gEEP_pressure_To_current, PRESSURE_TO_CURRENT_ADDRESS, PRESSURE_TO_CURREN
             -T_LENGTH))
  419  2                              {
  420  3                                      Std_DataCopy(gEEP_pressure_To_current, pressure_To_current, PRESSURE_TO_CURRENT_LENGTH - 1);
  421  3                                      g_calibrationParaChangeMask |= ((INT32U)0x00000001 << 26);
  422  3                              }
  423  2                              else
  424  2                              {
  425  3                                      Std_DataCopy(pressure_To_current, gEEP_pressure_To_current, PRESSURE_TO_CURRENT_LENGTH - 1);
  426  3                              }
  427  2                              
  428  2                              PowerUpTestState = EcmWait4;
  429  2                      break;
  430  2      
  431  2                      case EcmWait4:
  432  2                              AdcIf_Func();
  433  2                              PowerUpTestState = EcmWait5;
  434  2                      break;
  435  2      
  436  2                      case EcmWait5:
  437  2                              uCanVoltageValue = ptr_AdcIf->vehiclePowerVoltage_Adc;
  438  2                              PowerUpTestState = EcmWait6;
  439  2                      break;
  440  2      
  441  2                      case EcmWait6:
  442  2                              
  443  2                              IO_vSetPin(IO_P10_4); /* open main relay */
  444  2      
  445  2                              PowerUpTestState = EcmWait7;
  446  2                      break;
  447  2      
  448  2                      case EcmWait7:
  449  2                              if(Rte_PreDriverOpenDelay() == 1)       //预驱动打开
  450  2                              {
  451  3                                      PowerUpTestState = EcmWait8;
  452  3                              }
  453  2                      break;
  454  2      
  455  2                      case EcmWait8:
  456  2                              PowerUpTestState = EcmEnd;
  457  2                      break;
  458  2      
  459  2                      case EcmEnd:
  460  2                              
  461  2                              PUTFinish_u8_Sig = 1;                   //上电测试模式结束
  462  2                              PowerUpTestState = EcmStart;    //重新转换到初始状态
  463  2      #if(1 == GPT2_TIME_MEASURE_EN)
                                      TimeMeasure_StartTimer(); /* start GPT2 Timer5 used for task time measure */
              #endif
  466  2                      break;
  467  2      
  468  2                      default:
  469  2                      break;
C166 COMPILER V7.57.0, TASK3                                                               12/25/2020 20:36:12 PAGE 9   

  470  2              }
  471  1      }
  472         
  473         /*!************************************************************************************
  474         *       @fn             void task3Normal_v_s(void)
  475         *       @brief            任务3正常模式函数
  476         *       @author     Matt Zhang
  477         *       @param[in]      void
  478         *       @return     void
  479         *       @note       电源信号的采样及诊断，诊断方面可后续增加;在Task3.c的task3()函数中
  480         *       @Data       2019-3-12
  481         ****************************************************************************************/
  482         void task3Normal_v_s(void)
  483         {
  484  1              const FLTD_faultActType* FLTDAct_ptr = FLTD_FltActFlgData();
  485  1              
  486  1              Rte_Runable();
  487  1              
  488  1              if(FALSE == g_pvTestFlag)
  489  1              {
  490  2                      FLTD_Runnable();
  491  2              }
  492  1              
  493  1              if(TRUE == FLTDAct_ptr->closeMainRelayFlg)
  494  1              {
  495  2                      IO_vResetPin(IO_P10_4); /* close main relay */
  496  2              }
  497  1              else
  498  1              {
  499  2                      IO_vSetPin(IO_P10_4); /* open main relay */
  500  2              }
  501  1              
  502  1              if(TRUE == FLTDAct_ptr->closePedalPowerFlg)
  503  1              {
  504  2                      //IO_vResetPin(IO_P7_4); /* close pedal sensor power */
  505  2              }
  506  1              else
  507  1              {
  508  2                      IO_vSetPin(IO_P7_4); /* open pedal sensor power */
  509  2              }
  510  1              
  511  1              if(TRUE == FLTDAct_ptr->closeCylinderPowerFlg)
  512  1              {
  513  2                      //IO_vResetPin(IO_P7_1); /* close main cylinser sensor power */
  514  2              }
  515  1              else
  516  1              {
  517  2                      IO_vSetPin(IO_P7_1); /* open main cylinser sensor power */
  518  2              }
  519  1      
  520  1              if(TRUE == FLTDAct_ptr->closePredriverFlg)
  521  1              {
  522  2                      IO_vResetPin(IO_P0_7); /* close pre driver */
  523  2              }
  524  1              else
  525  1              {
  526  2                      IO_vSetPin(IO_P0_7); /* open pre driver */
  527  2              }
  528  1      
  529  1      
  530  1          /* --- 等待100ms的驱动 ramp down 结束后置位正常模式结束 --- */
  531  1              Rte_WaitDriverRampDown();
C166 COMPILER V7.57.0, TASK3                                                               12/25/2020 20:36:12 PAGE 10  

  532  1      
  533  1      }
  534         /*!************************************************************************************
  535         *       @fn             void task3PowerDownTest_v_s(void)
  536         *       @brief            任务3下电测试函数
  537         *       @author     Matt Zhang
  538         *       @param[in]      void
  539         *       @return     void
  540         *       @note       下电测试主要是PWM占空比50%设定、关闭预驱、关闭主继电器;在Task3.c的task3()函数中
  541         *       @Data       2019-3-12
  542         ****************************************************************************************/
  543         void task3PowerDownTest_v_s(void)
  544         {
  545  1              static INT8U Delay = 0;
  546  1              
  547  1              switch (PowerDownTestState) 
  548  1              {
  549  2                      case EcmStart:
  550  2      
  551  2                              Pwm_Control(0);
  552  2                              PowerDownTestState = EcmWait1;
  553  2      
  554  2                      break;
  555  2      
  556  2                      case EcmWait1:
  557  2                              
  558  2                              IO_vResetPin(IO_P0_7); /* close pre driver */
  559  2                              PowerDownTestState = EcmWait2;
  560  2                      break;
  561  2      
  562  2                      case EcmWait2:
  563  2                              
  564  2                              IO_vResetPin(IO_P10_4); /* close main relay */
  565  2                      
  566  2                              Delay++;
  567  2                              if(Delay >= MAIN_RELAY_OFF_DELAYTIME)//主继电器关闭延时30ms
  568  2                              {
  569  3                                      Delay = 0;
  570  3                                      PowerDownTestState = EcmEnd;
  571  3                              }
  572  2                      break;
  573  2      
  574  2                      case EcmEnd:
  575  2                              /* --- 下电测试模式结束 --- */
  576  2      
  577  2                              PDTFinish_u8_Sig = 1;
  578  2                               /* --- 重新转换到初始状态 --- */
  579  2                              PowerDownTestState = EcmStart;
  580  2      
  581  2                      break;
  582  2      
  583  2                      default:
  584  2                      break;
  585  2              }
  586  1      }
  587         /*!************************************************************************************
  588         *       @fn             void task3PowerDown_v_s(void)
  589         *       @brief            任务3下电函数
  590         *       @author     Matt Zhang
  591         *       @param[in]      void
  592         *       @return     void
  593         *       @note       在Task3的task3()函数中
C166 COMPILER V7.57.0, TASK3                                                               12/25/2020 20:36:12 PAGE 11  

  594         *       @Data       2019-3-12
  595         ****************************************************************************************/
  596         void task3PowerDown_v_s(void)
  597         {
  598  1              PDFinish_u8_Sig = 1;
  599  1              
  600  1              IO_vResetPin(IO_P1_7); /* close main power */
  601  1      }
  602         /*!************************************************************************************
  603         *       @fn             void task3Fault_v_s(void)
  604         *       @brief            任务3故障模式函数
  605         *       @author     Matt Zhang
  606         *       @param[in]      void
  607         *       @return     void
  608         *       @note       在Task3.c的task3()函数中
  609         *       @Data       2019-3-12
  610         ****************************************************************************************/
  611         void task3Fault_v_s(void)
  612         {
  613  1      
  614  1      }
  615         
  616         
  617         
  618         
  619         
  620         
  621         
  622         
  623         


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        2902     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          10     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =          16     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
