C166 COMPILER V7.57.0, RTE                                                                 01/20/2021 09:50:48 PAGE 1   


C166 COMPILER V7.57.0, COMPILATION OF MODULE RTE
OBJECT MODULE PLACED IN .\Obj\rte.obj
COMPILER INVOKED BY: C:\Keil_v5\C166\BIN\C166.EXE src\app\rte\rte.c MODV2 LARGE BROWSE INCDIR(.\src;.\src\bsw;.\src\driv
                    -er;.\src\interaction;.\src\app\adc;.\src\app\alogrithm;.\src\app\can;.\src\app\ccp;.\src\app\diagnostic;.\src\app\mode c
                    -ontrol;.\src\app\task;.\src\app\Fun;.\src\app\rtos;.\src\bsw\can;.\src\bsw\desc;.\src\bsw\nm;.\src\app\time measure;.\sr
                    -c\app\rte) MODV2 DEBUG PRINT(.\Lst\rte.lst) OBJECT(.\Obj\rte.obj) 

 stmt lvl     source

    1         /***********************************************************************
    2         *   Copyright (C) JWD Automotive Co., Ltd.                                             * 
    3         *               All Rights Reserved.                                                           *
    4         *   Department : iCAS SW                                                                               *
    5         *   AUTHOR         :                                                                                               *
    6         ************************************************************************
    7         * Object        : 
    8         * Module        : rte.c
    9         * Instance      : 
   10         * Description   : A time measurement function that measures execution time 
   11         *                                 and scheduling cycles
   12         *-----------------------------------------------------------------------
   13         * Version: v0.1
   14         * Date   : 2020.3.19 
   15         * Author : Zhu jinfeng
   16         ***********************************************************************/
   17         /*-History--------------------------------------------------------------
   18         * Version    Date           Name            Changes and comments
   19         ------------------------------------------------------------------------
   20         * 0.1       2020.3.19     Zhu jinfeng                   Initial version
   21         *=====================================================================*/
   22         
   23         #define RTE_GLOBALS
   24         
   25         #include "MAIN.h"
   26         #include "can_if.h"
   27         #include "rte.h"
   28         #include "eepRom.h"
   29         #include "EEPROM_Cfg.h"
   30         #include "pid.h"
   31         #include "pwm.h"
   32         #include "booster.h"
   33         #include "adc_sample.h"
   34         #include "FLTD.h"
   35         
   36         /**** Definition of variables ****/
   37         
   38         FP32 temperatureAdTabble[50] =
   39         {
   40                 1002.5793, 987.5587, 964.3300, 930.5421, 884.4136, 856.3534, 824.9348, 790.2895, 752.7188, 712.6531,
   41                 670.7021, 627.5324, 583.8639, 540.4084, 497.8097, 456.6134, 417.2502, 380.0265, 345.1465, 312.7312,
   42                 282.8052, 255.3540, 230.3063, 207.5516, 186.9913, 183.1306, 179.3513, 175.6530, 172.0337, 168.4915,
   43                 165.0270, 161.6379, 158.3247, 155.0832, 151.9153, 148.8197, 145.7935, 142.8366, 139.9474, 137.1258,
   44                 134.3701, 131.6782, 129.0516, 126.4864, 123.9822, 121.5402, 119.1564, 116.8317, 114.5638, 112.3519 
   45         };
   46         
   47         INT8U temperatureValueTable[50] =
   48         {
   49                 -40,-30,-20,-10,0,      5,      10,     15,     20,     25,
   50                 30,     35,     40,     45,     50,     55,     60,     65,     70,     75,
   51                 80,     85,     90,     95,     100,101,102,103,104,105,
   52                 106,107,108,109,110,111,112,113,114,115,
C166 COMPILER V7.57.0, RTE                                                                 01/20/2021 09:50:48 PAGE 2   

   53                 116,117,118,119,120,121,122,123,124,125
   54         };
   55         
   56         /**** Declaration of functions ****/
   57         
   58         
   59         
   60         /***********************************************************************
   61         *  Name        : Rte_Init
   62         *  Description : initialization of variable and Enable CAN.
   63         *  Parameter   : None
   64         *  Returns     : None
   65         ***********************************************************************/
   66         void Rte_Init(void)
   67         {
   68  1              SystemMode_u8_Sig = 0;        /* 系统模式 */
   69  1              PDTFinish_u8_Sig = 0;         /* PowerDown模式结束标志位 */
   70  1              PUTFinish_u8_Sig = 0;         /* PowerUpTest模式结束标志位 */
   71  1              PDFinish_u8_Sig = 0;          /* PowerDownTest模式结束标志位*/
   72  1              NormalFinish_u8_Sig = 0;      /* Normal模式结束标志位 */
   73  1              PDTtoPUTflag_u8_Sig = 0;      /* PowerDown到PowerUpTest模式标志位*/
   74  1              MaintenStatus_u8_Sig = 0;     /* 维护模式标志位  */
   75  1              IGNStatus_u8_Sig = 0;         /* 点火信号状态*/
   76  1              MaintenLevel_u8_Sig = 0;      /* 维护信号状态*/
   77  1              FaultLevel_u8_Sig = 0;        /* 目前所发生故障的等级*/
   78  1              VehicleStatus_u8_Sig = 0;     /* 车辆状态 是否为停止状态 */
   79  1              VehSpeedFault_u8_Sig = 0;     /* 车速故障标识位*/
   80  1              
   81  1              MCTimer = 0;
   82  1              gRTE_pidTypeSw = 0;
   83  1              g_pedalInterveneFlag = FALSE;
   84  1              gRTE_wireControlPressureLoopFlag = FALSE;
   85  1              g_calibrationParaChangeMask = 0;
   86  1              g_wireControlEnFlag = FALSE;
   87  1              g_cylinderExhaustEnFlag = FALSE;
   88  1              g_cylinderExhaustInformFlag = FALSE;
   89  1              g_ecuResetFlag = FALSE;
   90  1              g_pvTestFlag = FALSE;
   91  1              g_topEdgeCnt = 0;
   92  1              g_bottomEdgeCnt = 0;
   93  1              g_systemAbnormalFlag = FALSE;
   94  1              g_brakeReleaseFlag = FALSE;
   95  1              g_PressureSensorFaultFlag = FALSE;
   96  1              g_residualPressureFlag = FALSE;
   97  1              
   98  1              residualPressureTimeCnt = 0;
   99  1              residualPressureReleaseTimeCnt = 0;
  100  1              stabiliseTimeCnt = 0;
  101  1      
  102  1              
  103  1              CanEnbale_v_g();            /*CAN0、CAN1 transfer使能*/
  104  1      }
  105         
  106         /***********************************************************************
  107         *  Name        : Rte_ReadSignalSts
  108         *  Description : Get IO state.
  109         *  Parameter   : None
  110         *  Returns     : None
  111         ***********************************************************************/
  112         void Rte_ReadSignalSts(void)
  113         {
  114  1              if(FALSE == g_adcSimulateDataFlag)
C166 COMPILER V7.57.0, RTE                                                                 01/20/2021 09:50:48 PAGE 3   

  115  1              {
  116  2                      g_inHwBrakeSwSts = IO_ubReadPin(IO_P4_0); /* read brake switch signal */
  117  2              }
  118  1      #if 0 // polyspace test by gzz 2020.12.30       
                      else
                      {
                              if(14 == g_adcSimulateDataIndex)
                              {
                                      if(0 == g_adcSimulateData)
                                      {
                                              g_inBrakeSwValidSts = FALSE;
                                      }
                                      else
                                      {
                                              g_inBrakeSwValidSts = TRUE;
                                      }
                              }
                      }
              #endif  
  134  1              g_inIGNSts = IO_ubReadPin(IO_P7_3); /* read IGN signal */
  135  1              g_inPreDriverErrorSts = IO_ubReadPin(IO_P6_0); /* read pre driver error status */
  136  1              g_inWatchDogSts = IO_ubReadPin(IO_P4_3); /* read watch dog status */
  137  1              
  138  1              g_PedalPowerSts = IO_ubReadPin(IO_P7_4); /* read pedal power status */
  139  1              g_CylinderPowerSts = IO_ubReadPin(IO_P7_1); /* read cylinder power status */
  140  1              g_MainRelaySts = IO_ubReadPin(IO_P10_4); /* read main relay status */
  141  1              g_PredriverEnableSts = IO_ubReadPin(IO_P0_7); /* read pre driver enable status */
  142  1              
  143  1      #if(2 == BRAKE_SIGNAL_SOURCE)
                      g_inBrakeSwValidSts = (g_inHwBrakeSwSts == 0 ? TRUE : FALSE); /* The brake switch signal comes from the h
             -ardware */
              #elif(3 == BRAKE_SIGNAL_SOURCE)
                      g_inBrakeSwValidSts = VCU_BrakePedalSts; /* The brake switch signal comes from CAN network */
              #else
  148  1              g_inBrakeSwValidSts = FALSE;
  149  1      #endif
  150  1      }
  151         
  152         
  153         /***********************************************************************
  154         *  Name        : Rte_Runable
  155         *  Description : Determines whether the application data has changed and writes the changes synchronously 
             -to EEPROM.
  156         *  Parameter   : None
  157         *  Returns     : None
  158         ***********************************************************************/
  159         void Rte_Runable(void)
  160         {
  161  1              static INT8U u8_periodCnt = 0;
  162  1              static INT8U initValueTemp[5] = {0};
  163  1              
  164  1              switch(u8_periodCnt)
  165  1              {
  166  2                      case 0:
  167  2                      {
  168  3                              //Control damping protection
  169  3                              if(FALSE == Std_DataCompare(&gRTE_pwmProtectThreshold, gEEP_pwmProtectThreshold, PWM_PROTECT_FAULT_VALU
             -E_LENGTH - 1))
  170  3                              {
  171  4                                      Std_DataCopy(&gRTE_pwmProtectThreshold, gEEP_pwmProtectThreshold, PWM_PROTECT_FAULT_VALUE_LENGTH - 1);
  172  4                                      Rte_WriteEepromData(gEEP_pwmProtectThreshold, PWM_PROTECT_FAULT_VALUE_ADDRESS, PWM_PROTECT_FAULT_VALUE
             -_LENGTH);
C166 COMPILER V7.57.0, RTE                                                                 01/20/2021 09:50:48 PAGE 4   

  173  4                              }
  174  3                              if(FALSE == Std_DataCompare(&gRTE_controlMaxCurrent, gEEP_controlMaxCurrent, MAX_OBJ_CURRENT_VALUE_LENG
             -TH - 1))
  175  3                              {
  176  4                                      Std_DataCopy(&gRTE_controlMaxCurrent, gEEP_controlMaxCurrent, MAX_OBJ_CURRENT_VALUE_LENGTH - 1);
  177  4                                      Rte_WriteEepromData(gEEP_controlMaxCurrent, MAX_OBJ_CURRENT_VALUE_ADDRESS, MAX_OBJ_CURRENT_VALUE_LENGT
             -H);
  178  4                              }
  179  3                              if(FALSE == Std_DataCompare(&gRTE_dampMinCylinder, gEEP_dampMinCylinder, DAMP_MIN_CYLINDER_VALUE_LENGTH
             - - 1))
  180  3                              {
  181  4                                      Std_DataCopy(&gRTE_dampMinCylinder, gEEP_dampMinCylinder, DAMP_MIN_CYLINDER_VALUE_LENGTH - 1);
  182  4                                      Rte_WriteEepromData(gEEP_dampMinCylinder, DAMP_MIN_CYLINDER_VALUE_ADDRESS, DAMP_MIN_CYLINDER_VALUE_LEN
             -GTH);
  183  4                              }
  184  3                              if(FALSE == Std_DataCompare(&gRTE_dampMinCurrent, gEEP_dampMinCurrent, DAMP_MIN_CURRENT_VALUE_LENGTH - 
             -1))
  185  3                              {
  186  4                                      Std_DataCopy(&gRTE_dampMinCurrent, gEEP_dampMinCurrent, DAMP_MIN_CURRENT_VALUE_LENGTH - 1);
  187  4                                      Rte_WriteEepromData(gEEP_dampMinCurrent, DAMP_MIN_CURRENT_VALUE_ADDRESS, DAMP_MIN_CURRENT_VALUE_LENGTH
             -);
  188  4                              }
  189  3                              if(FALSE == Std_DataCompare(&gRTE_dampMinPressure, gEEP_dampMinPressure, DAMP_MIN_PRESSURE_VALUE_LENGTH
             - - 1))
  190  3                              {
  191  4                                      Std_DataCopy(&gRTE_dampMinPressure, gEEP_dampMinPressure, DAMP_MIN_PRESSURE_VALUE_LENGTH - 1);
  192  4                                      Rte_WriteEepromData(gEEP_dampMinPressure, DAMP_MIN_PRESSURE_VALUE_ADDRESS, DAMP_MIN_PRESSURE_VALUE_LEN
             -GTH);
  193  4                              }
  194  3              
  195  3                              u8_periodCnt = 1;
  196  3                              break;
  197  3                      }
  198  2                      
  199  2                      case 1:
  200  2                      {
  201  3                              if(((INT8U)gRTE_pedalInitValue[0] != gEEP_pedalLocationInit[0])
  202  3                                      || ((INT8U)gRTE_pedalInitValue[1] != gEEP_pedalLocationInit[1])
  203  3                                      || ((INT8U)gRTE_cylinderInitValue[0] != gEEP_cylinderLocationInit[0])
  204  3                                      || ((INT8U)gRTE_cylinderInitValue[1] != gEEP_cylinderLocationInit[1]))
  205  3                              {
  206  4                                      initValueTemp[0] = (INT8U)gRTE_pedalInitValue[0];
  207  4                                      initValueTemp[1] = (INT8U)gRTE_pedalInitValue[1];
  208  4                                      initValueTemp[2] = (INT8U)gRTE_cylinderInitValue[0];
  209  4                                      initValueTemp[3] = (INT8U)gRTE_cylinderInitValue[1];
  210  4                                      initValueTemp[4] = 10;
  211  4                                      
  212  4                                      CopyString_v_g(initValueTemp, PEDAL_INIT_LOCATION_VALUE_ADDRESS, 5, 1);
  213  4                              }
  214  3                              
  215  3      #if 0
                                      //ICAS System pedal/cylinder init AD value parameters   
                                      if(FALSE == Std_DataCompare(gRTE_pedalInitValue, gEEP_pedalLocationInit, PEDAL_INIT_LOCATION_VALUE_LENG
             -TH - 1))
                                      {
                                              Std_DataCopy(gRTE_pedalInitValue, gEEP_pedalLocationInit, PEDAL_INIT_LOCATION_VALUE_LENGTH - 1);
                                              Rte_WriteEepromData(gEEP_pedalLocationInit, PEDAL_INIT_LOCATION_VALUE_ADDRESS, PEDAL_INIT_LOCATION_VAL
             -UE_LENGTH);
                                      }
                                      if(FALSE == Std_DataCompare(gRTE_cylinderInitValue, gEEP_cylinderLocationInit, CYLINDER_INIT_LOCATION_V
             -ALUE_LENGTH - 1))
                                      {
C166 COMPILER V7.57.0, RTE                                                                 01/20/2021 09:50:48 PAGE 5   

                                              Std_DataCopy(gRTE_cylinderInitValue, gEEP_cylinderLocationInit, CYLINDER_INIT_LOCATION_VALUE_LENGTH - 
             -1);
                                              Rte_WriteEepromData(gEEP_cylinderLocationInit, CYLINDER_INIT_LOCATION_VALUE_ADDRESS, CYLINDER_INIT_LOC
             -ATION_VALUE_LENGTH);
                                      }
              #endif
  228  3                              u8_periodCnt = 2;
  229  3                              break;
  230  3                      }
  231  2                      
  232  2                      case 2:
  233  2                      {
  234  3                              //Position loop PID, KP, KI, KD term parameters
  235  3                              if(FALSE == Std_DataCompare(&gRTE_locationKp, gEEP_locationKp, PID_PARA_LENGTH - 1))
  236  3                              {
  237  4                                      Std_DataCopy(&gRTE_locationKp, gEEP_locationKp, PID_PARA_LENGTH - 1);
  238  4                                      Rte_WriteEepromData(gEEP_locationKp, LOCATION_LOOP_KP_ADDRESS, PID_PARA_LENGTH);
  239  4                              }
  240  3                              if(FALSE == Std_DataCompare(&gRTE_locationKi, gEEP_locationKi, PID_PARA_LENGTH - 1))
  241  3                              {
  242  4                                      Std_DataCopy(&gRTE_locationKi, gEEP_locationKi, PID_PARA_LENGTH - 1);
  243  4                                      Rte_WriteEepromData(gEEP_locationKi, LOCATION_LOOP_KI_ADDRESS, PID_PARA_LENGTH);
  244  4                              }
  245  3                              if(FALSE == Std_DataCompare(&gRTE_locationKd, gEEP_locationKd, PID_PARA_LENGTH - 1))
  246  3                              {
  247  4                                      Std_DataCopy(&gRTE_locationKd, gEEP_locationKd, PID_PARA_LENGTH - 1);
  248  4                                      Rte_WriteEepromData(gEEP_locationKd, LOCATION_LOOP_KD_ADDRESS, PID_PARA_LENGTH);
  249  4                              }
  250  3      
  251  3                              //Current loop PID, KP, KI, KD term parameters
  252  3                              if(FALSE == Std_DataCompare(&gRTE_currentKp, gEEP_currentKp, PID_PARA_LENGTH - 1))
  253  3                              {
  254  4                                      Std_DataCopy(&gRTE_currentKp, gEEP_currentKp, PID_PARA_LENGTH - 1);
  255  4                                      Rte_WriteEepromData(gEEP_currentKp, CURRENT_LOOP_KP_ADDRESS, PID_PARA_LENGTH);
  256  4                              }
  257  3                              if(FALSE == Std_DataCompare(&gRTE_currentKi, gEEP_currentKi, PID_PARA_LENGTH - 1))
  258  3                              {
  259  4                                      Std_DataCopy(&gRTE_currentKi, gEEP_currentKi, PID_PARA_LENGTH - 1);
  260  4                                      Rte_WriteEepromData(gEEP_currentKi, CURRENT_LOOP_KI_ADDRESS, PID_PARA_LENGTH);
  261  4                              }
  262  3                              if(FALSE == Std_DataCompare(&gRTE_currentKd, gEEP_currentKd, PID_PARA_LENGTH - 1))
  263  3                              {
  264  4                                      Std_DataCopy(&gRTE_currentKd, gEEP_currentKd, PID_PARA_LENGTH - 1);
  265  4                                      Rte_WriteEepromData(gEEP_currentKd, CURRENT_LOOP_KD_ADDRESS, PID_PARA_LENGTH);
  266  4                              }
  267  3              
  268  3                              u8_periodCnt = 3;
  269  3                              break;
  270  3                      }
  271  2                      
  272  2                      case 3:
  273  2                      {
  274  3                              //only position loop PID, KP, KI, KD term parameters
  275  3                              if(FALSE == Std_DataCompare(&gRTE_onlyPositionKp, gEEP_onlyPositionKp, PID_PARA_LENGTH - 1))
  276  3                              {
  277  4                                      Std_DataCopy(&gRTE_onlyPositionKp, gEEP_onlyPositionKp, PID_PARA_LENGTH - 1);
  278  4                                      Rte_WriteEepromData(gEEP_onlyPositionKp, ONLYLOCATION_LOOP_KP_ADDRESS, PID_PARA_LENGTH);
  279  4                              }
  280  3                              if(FALSE == Std_DataCompare(&gRTE_onlyPositionKi, gEEP_onlyPositionKi, PID_PARA_LENGTH - 1))
  281  3                              {
  282  4                                      Std_DataCopy(&gRTE_onlyPositionKi, gEEP_onlyPositionKi, PID_PARA_LENGTH - 1);
  283  4                                      Rte_WriteEepromData(gEEP_onlyPositionKi, ONLYLOCATION_LOOP_KI_ADDRESS, PID_PARA_LENGTH);
C166 COMPILER V7.57.0, RTE                                                                 01/20/2021 09:50:48 PAGE 6   

  284  4                              }
  285  3                              if(FALSE == Std_DataCompare(&gRTE_onlyPositionKd, gEEP_onlyPositionKd, PID_PARA_LENGTH - 1))
  286  3                              {
  287  4                                      Std_DataCopy(&gRTE_onlyPositionKd, gEEP_onlyPositionKd, PID_PARA_LENGTH - 1);
  288  4                                      Rte_WriteEepromData(gEEP_onlyPositionKd, ONLYLOCATION_LOOP_KD_ADDRESS, PID_PARA_LENGTH);
  289  4                              }               
  290  3                              
  291  3                              //pressure loop PID, KP, KI, KD term parameters
  292  3                              if(FALSE == Std_DataCompare(&gRTE_pressureKp, gEEP_pressureKp, PID_PARA_LENGTH - 1))
  293  3                              {
  294  4                                      Std_DataCopy(&gRTE_pressureKp, gEEP_pressureKp, PID_PARA_LENGTH - 1);
  295  4                                      Rte_WriteEepromData(gEEP_pressureKp, PRESSURE_LOOP_KP_ADDRESS, PID_PARA_LENGTH);
  296  4                              }
  297  3                              if(FALSE == Std_DataCompare(&gRTE_pressureKi, gEEP_pressureKi, PID_PARA_LENGTH - 1))
  298  3                              {
  299  4                                      Std_DataCopy(&gRTE_pressureKi, gEEP_pressureKi, PID_PARA_LENGTH - 1);
  300  4                                      Rte_WriteEepromData(gEEP_pressureKi, PRESSURE_LOOP_KI_ADDRESS, PID_PARA_LENGTH);
  301  4                              }
  302  3                              if(FALSE == Std_DataCompare(&gRTE_pressureKd, gEEP_pressureKd, PID_PARA_LENGTH - 1))
  303  3                              {
  304  4                                      Std_DataCopy(&gRTE_pressureKd, gEEP_pressureKd, PID_PARA_LENGTH - 1);
  305  4                                      Rte_WriteEepromData(gEEP_pressureKd, PRESSURE_LOOP_KD_ADDRESS, PID_PARA_LENGTH);
  306  4                              }       
  307  3              
  308  3                              u8_periodCnt = 4;
  309  3                              break;
  310  3                      }
  311  2                      
  312  2                      case 4:
  313  2                      {
  314  3                              //booster
  315  3                              if(FALSE == Std_DataCompare(pedal_To_cylinder, gEEP_pedal_To_cylinder, PEDAL_TO_CYLINDER_LENGTH - 1))
  316  3                              {
  317  4                                      Std_DataCopy(pedal_To_cylinder, gEEP_pedal_To_cylinder, PEDAL_TO_CYLINDER_LENGTH - 1);
  318  4                                      Rte_WriteEepromData(gEEP_pedal_To_cylinder, PEDAL_TO_CYLINDER_ADDRESS, PEDAL_TO_CYLINDER_LENGTH);
  319  4                              }
  320  3                              if(FALSE == Std_DataCompare(cylinder_To_current, gEEP_cylinder_To_current, CYLINDER_TO_CURRENT_LENGTH -
             - 1))
  321  3                              {
  322  4                                      Std_DataCopy(cylinder_To_current, gEEP_cylinder_To_current, CYLINDER_TO_CURRENT_LENGTH - 1);
  323  4                                      Rte_WriteEepromData(gEEP_cylinder_To_current, CYLINDER_TO_CURRENT_ADDRESS, CYLINDER_TO_CURRENT_LENGTH)
             -;
  324  4                              }
  325  3                              if(FALSE == Std_DataCompare(current_To_pwm, gEEP_current_To_pwm, CURRENT_TO_PWM_LENGTH - 1))
  326  3                              {
  327  4                                      Std_DataCopy(current_To_pwm, gEEP_current_To_pwm, CURRENT_TO_PWM_LENGTH - 1);
  328  4                                      Rte_WriteEepromData(gEEP_current_To_pwm, CURRENT_TO_PWM_ADDRESS, CURRENT_TO_PWM_LENGTH);
  329  4                              }
  330  3                              if(FALSE == Std_DataCompare(pedal_To_current, gEEP_pedal_To_current, PEDAL_TO_CURRENT_LENGTH - 1))
  331  3                              {
  332  4                                      Std_DataCopy(pedal_To_current, gEEP_pedal_To_current, PEDAL_TO_CURRENT_LENGTH - 1);
  333  4                                      Rte_WriteEepromData(gEEP_pedal_To_current, PEDAL_TO_CURRENT_ADDRESS, PEDAL_TO_CURRENT_LENGTH);
  334  4                              }
  335  3                              
  336  3                              u8_periodCnt = 5;
  337  3                              break;
  338  3                      }
  339  2                      
  340  2                      case 5:
  341  2                      {
  342  3                              //wireControl
  343  3                              if(FALSE == Std_DataCompare(pressure_To_cylinder, gEEP_pressure_To_cylinder, PRESSURE_TO_CYLINDER_LENGT
C166 COMPILER V7.57.0, RTE                                                                 01/20/2021 09:50:48 PAGE 7   

             -H - 1))
  344  3                              {
  345  4                                      Std_DataCopy(pressure_To_cylinder, gEEP_pressure_To_cylinder, PRESSURE_TO_CYLINDER_LENGTH - 1);
  346  4                                      Rte_WriteEepromData(gEEP_pressure_To_cylinder, PRESSURE_TO_CYLINDER_ADDRESS, PRESSURE_TO_CYLINDER_LENG
             -TH);
  347  4                              }
  348  3                              if(FALSE == Std_DataCompare(cylinder_To_pressure, gEEP_cylinder_To_pressure, CYLINDER_TO_PRESSURE_LENGT
             -H - 1))
  349  3                              {
  350  4                                      Std_DataCopy(cylinder_To_pressure, gEEP_cylinder_To_pressure, CYLINDER_TO_PRESSURE_LENGTH - 1);
  351  4                                      Rte_WriteEepromData(gEEP_cylinder_To_pressure, CYLINDER_TO_PRESSURE_ADDRESS, CYLINDER_TO_PRESSURE_LENG
             -TH);
  352  4                              }
  353  3                              if(FALSE == Std_DataCompare(current_To_pressure, gEEP_current_To_pressure, CURRENT_TO_PRESSURE_LENGTH -
             - 1))
  354  3                              {
  355  4                                      Std_DataCopy(current_To_pressure, gEEP_current_To_pressure, CURRENT_TO_PRESSURE_LENGTH - 1);
  356  4                                      Rte_WriteEepromData(gEEP_current_To_pressure, CURRENT_TO_PRESSURE_ADDRESS, CURRENT_TO_PRESSURE_LENGTH)
             -;
  357  4                              }
  358  3                              if(FALSE == Std_DataCompare(pressure_To_current, gEEP_pressure_To_current, PRESSURE_TO_CURRENT_LENGTH -
             - 1))
  359  3                              {
  360  4                                      Std_DataCopy(pressure_To_current, gEEP_pressure_To_current, PRESSURE_TO_CURRENT_LENGTH - 1);
  361  4                                      Rte_WriteEepromData(gEEP_pressure_To_current, PRESSURE_TO_CURRENT_ADDRESS, PRESSURE_TO_CURRENT_LENGTH)
             -;
  362  4                              }
  363  3                              u8_periodCnt = 0;
  364  3                              break;
  365  3                      }
  366  2              }
  367  1      }
  368         
  369         
  370         /***********************************************************************
  371         *  Name        : Rte_sensorInitValueUpdate
  372         *  Description : Dynamically determine whether the initial value of the sensor needs to be updated.
  373         *  Parameter   : None
  374         *  Returns     : None
  375         ***********************************************************************/
  376         void Rte_selfCalibrationInitValue(void)
  377         {
  378  1              static INT16U pedalSensorTimeCnt = 0;
  379  1              static INT16U cylinderSensorTimeCnt = 0;
  380  1              static INT16U pedalAdcMinValue[2] = {0xFFFF, 0xFFFF};
  381  1              static INT16U cylinderAdcMinValue[2] = {0xFFFF, 0xFFFF};
  382  1              
  383  1              const T_PWM* ptr_Pwm = Pwm_ControlData();
  384  1              const T_BOOSTER* ptr_Booster = Booster_AlogrithmData();
  385  1              const T_ADC* ptr_Adc = Adc_SampleData();
  386  1                      
  387  1              /* When the brake switch is invalid and the motor has no control output.
  388  1                      Determine if the sensor initial value needs to be updated */
  389  1              if((FALSE == g_inBrakeSwValidSts)
  390  1                      && (PWM_AMPLITUDE_DEFAULT == ptr_Pwm->motorCtrl))
  391  1              {
  392  2                      /* pedal sensor Self-calibration */
  393  2                      if((ABS(ptr_Booster->pedalRate) <= 20)
  394  2                              && (FLTD_VOL_NORMAL == FLTD_GetAdcRangeType(FLTD_ADC_PEDAL_SENSOR_SIG1)))
  395  2                      {                       
  396  3                              /* Pedal signal stabilization time */
  397  3                              if(pedalSensorTimeCnt < 500)
C166 COMPILER V7.57.0, RTE                                                                 01/20/2021 09:50:48 PAGE 8   

  398  3                              {
  399  4                                      pedalSensorTimeCnt++;
  400  4                                      
  401  4                                      if(ptr_Adc->brakePedalTrip_Adc[0] < pedalAdcMinValue[0])
  402  4                                      {
  403  5                                              pedalAdcMinValue[0] = ptr_Adc->brakePedalTrip_Adc[0];
  404  5                                      }
  405  4                                      if(ptr_Adc->brakePedalTrip_Adc[1] < pedalAdcMinValue[1])
  406  4                                      {
  407  5                                              pedalAdcMinValue[1] = ptr_Adc->brakePedalTrip_Adc[1];
  408  5                                      }
  409  4                              }
  410  3                              else
  411  3                              {
  412  4                                      if(ABSOLUTE(pedalAdcMinValue[0], gRTE_pedalInitValue[0]) > 20)
  413  4                                      {
  414  5                                              gRTE_pedalInitValue[0] = pedalAdcMinValue[0] + 10;
  415  5                                      }
  416  4                                      if(ABSOLUTE(pedalAdcMinValue[1], gRTE_pedalInitValue[1]) > 15)
  417  4                                      {
  418  5                                              gRTE_pedalInitValue[1] = pedalAdcMinValue[1] + 7;
  419  5                                      }
  420  4                              }
  421  3                      }
  422  2                      else
  423  2                      {
  424  3                              pedalSensorTimeCnt = 0;
  425  3                              pedalAdcMinValue[0] = 0xFFFF;
  426  3                              pedalAdcMinValue[1] = 0xFFFF;
  427  3                      }
  428  2                      
  429  2                      /* cylinder sensor Self-calibration */
  430  2                      if((ABS(ptr_Booster->cylinderRate) <= 20)
  431  2                              && (FLTD_VOL_NORMAL == FLTD_GetAdcRangeType(FLTD_ADC_MAIN_CYLINDER_SIG1)))
  432  2                      {
  433  3                              /* Cylinder signal stabilization time */
  434  3                              if(cylinderSensorTimeCnt < 500)
  435  3                              {
  436  4                                      cylinderSensorTimeCnt++;
  437  4                                      
  438  4                                      if(ptr_Adc->mainCylinderTrip_Adc[0] < cylinderAdcMinValue[0])
  439  4                                      {
  440  5                                              cylinderAdcMinValue[0] = ptr_Adc->mainCylinderTrip_Adc[0];
  441  5                                      }
  442  4                                      if(ptr_Adc->mainCylinderTrip_Adc[1] < cylinderAdcMinValue[1])
  443  4                                      {
  444  5                                              cylinderAdcMinValue[1] = ptr_Adc->mainCylinderTrip_Adc[1];
  445  5                                      }
  446  4                              }
  447  3                              else
  448  3                              {
  449  4                                      if(ABSOLUTE(cylinderAdcMinValue[0], gRTE_cylinderInitValue[0]) > 20)
  450  4                                      {
  451  5                                              gRTE_cylinderInitValue[0] = cylinderAdcMinValue[0] + 10;
  452  5                                      }
  453  4                                      if(ABSOLUTE(cylinderAdcMinValue[1], gRTE_cylinderInitValue[1]) > 15)
  454  4                                      {
  455  5                                              gRTE_cylinderInitValue[1] = cylinderAdcMinValue[1] + 7;
  456  5                                      }
  457  4                              }
  458  3                      }
  459  2                      else
C166 COMPILER V7.57.0, RTE                                                                 01/20/2021 09:50:48 PAGE 9   

  460  2                      {
  461  3                              cylinderSensorTimeCnt = 0;
  462  3                              cylinderAdcMinValue[0] = 0xFFFF;
  463  3                              cylinderAdcMinValue[1] = 0xFFFF;
  464  3                      }
  465  2              }
  466  1              else
  467  1              {
  468  2                      pedalSensorTimeCnt = 0;
  469  2                      cylinderSensorTimeCnt = 0;
  470  2                      pedalAdcMinValue[0] = 0xFFFF;
  471  2                      pedalAdcMinValue[1] = 0xFFFF;
  472  2                      cylinderAdcMinValue[0] = 0xFFFF;
  473  2                      cylinderAdcMinValue[1] = 0xFFFF;
  474  2              }
  475  1      }
  476         
  477         
  478         /***********************************************************************
  479         *  Name        : Rte_ReadEepromData
  480         *  Description : Read EEPROM data.The temporary Buffer is read first, 
  481                 and the CRC is calculated and updated to the application data after passing.
  482         *  Parameter   : None
  483         *  Returns     : None
  484         ***********************************************************************/
  485         BOOLEAN Rte_ReadEepromData(INT8U *DestAdr, INT32U SourceAdr, INT16U Len)
  486         {
  487  1              INT8U tempBuffer[128] = {0};
  488  1              INT8U tempCrc = 0, i = 0;
  489  1              BOOLEAN rtn_val = FALSE;
  490  1              
  491  1              if(Len > sizeof(tempBuffer))
  492  1              {
  493  2                      return rtn_val;
  494  2              }
  495  1              
  496  1              /* There is data and CRC in EEPROM, which is read into the cache for verification */
  497  1              ReadString_v_g(tempBuffer, SourceAdr, Len); //
  498  1              
  499  1              tempCrc = Rte_CRC8(tempBuffer, Len - 1);
  500  1              
  501  1              /* Check value is consistent, indicate data is valid, update data */
  502  1              if(tempCrc == tempBuffer[Len - 1])
  503  1              {
  504  2                      for(i = 0; i < Len; i++)
  505  2                      {
  506  3                              DestAdr[i] = tempBuffer[i];
  507  3                      }
  508  2                      
  509  2                      rtn_val = TRUE;
  510  2              }
  511  1              else
  512  1              {
  513  2                      rtn_val = FALSE;
  514  2              }
  515  1              
  516  1              return rtn_val;
  517  1      }
  518         
  519         /***********************************************************************
  520         *  Name        : Rte_WriteEepromData
  521         *  Description : CRC is calculated by applying the data and written to EEPROM.
C166 COMPILER V7.57.0, RTE                                                                 01/20/2021 09:50:48 PAGE 10  

  522         *  Parameter   : None
  523         *  Returns     : None
  524         ***********************************************************************/
  525         void Rte_WriteEepromData(void *SourceAdr, INT32U DestAdr, INT16U Len)
  526         {
  527  1              INT8U tempBuffer[128] = {0};
  528  1              INT8U tempCrc = 0, i = 0;
  529  1              INT8U *writeBuffer;
  530  1              
  531  1              if(Len > sizeof(tempBuffer))
  532  1              {
  533  2                      return;
  534  2              }
  535  1              
  536  1              writeBuffer = SourceAdr;
  537  1              
  538  1              for(i = 0; i < Len - 1; i++)
  539  1              {
  540  2                      tempBuffer[i] = writeBuffer[i];
  541  2              }
  542  1              tempCrc = Rte_CRC8(tempBuffer, Len - 1);
  543  1              tempBuffer[Len - 1] = tempCrc;
  544  1              
  545  1              CopyString_v_g(tempBuffer, DestAdr, Len, 1);
  546  1      }
  547         
  548         static INT8U Rte_CRC8(INT8U *num_buf, INT8U len)
  549         {
  550  1              INT8U i = 0, j = 0;
  551  1              INT8U CRC = 0x4B;
  552  1              INT8U genPoly = 0xC4;
  553  1              
  554  1          for (i = 0; i < len; i++)
  555  1          {
  556  2              CRC ^= *(num_buf + i);
  557  2          
  558  2              for(j = 0; j < 8; j++)
  559  2              {
  560  3                  if(CRC & 0x80 )
  561  3                      CRC = (CRC << 1) ^ genPoly;
  562  3                  else
  563  3                      CRC <<= 1;
  564  3              }
  565  2          }
  566  1          return (INT8U)(CRC & 0xff);
  567  1      }
  568         
  569         
  570         
  571         /***********************************************************************
  572         *  Name        : Rte_binarySearch
  573         *  Description : Binary search algorithm to find the value position in a descending table.
  574         *  Parameter   : None
  575         *  Returns     : None
  576         ***********************************************************************/
  577         static INT8U Rte_binarySearch(FP32 *array, INT8U tabLength, INT16U data)//表中数据从大到小
  578         {
  579  1              INT8U start, end, middle = 0;
  580  1              INT8U i;
  581  1      
  582  1          start = 0;
  583  1          end = tabLength - 1;
C166 COMPILER V7.57.0, RTE                                                                 01/20/2021 09:50:48 PAGE 11  

  584  1          i = 0;
  585  1      
  586  1          if (data >= array[start]) return start;
  587  1          else if (data <= array[end]) return end;
  588  1      
  589  1          while (start < end)
  590  1          {
  591  2              middle = (start + end) / 2;
*** WARNING C192 IN LINE 591 OF src\app\rte\rte.c: '=': value truncated
  592  2      
  593  2              if (data == array[middle]) 
  594  2                              break;
  595  2              if (data < array[middle] && data > array[middle + 1]) 
  596  2                              break;
  597  2      
  598  2              if (data > array[middle]) 
  599  2                              end = middle;
  600  2              else 
  601  2                              start = middle;
  602  2      
  603  2              if (i++ > tabLength) 
  604  2                              break;
  605  2          }
  606  1      
  607  1          if (start > end) 
  608  1                      return 0;
  609  1      
  610  1          return middle;
  611  1      }
  612         
  613         
  614         /***********************************************************************
  615         *  Name        : Rte_calcTemperature
  616         *  Description : According to the adc value, look up the table to get the temperature value.
  617         *  Parameter   : None
  618         *  Returns     : None
  619         ***********************************************************************/
  620         INT8S Rte_calcTemperature(INT16U data)
  621         {
  622  1              FP32 temp = 0;
  623  1              INT8U temploc = 0;
  624  1      
  625  1          temploc = Rte_binarySearch(temperatureAdTabble, 50, data);
  626  1      
  627  1              if (temploc <= 48U) // polyspace test by gzz 2020.12.30
  628  1              {
  629  2                  temp = (temperatureAdTabble[temploc] - data) / \
  630  2                              (temperatureAdTabble[temploc] - temperatureAdTabble[temploc + 1]) * \
  631  2                              (temperatureValueTable[temploc + 1] - temperatureValueTable[temploc]) + \
  632  2                              temperatureValueTable[temploc];         
  633  2              }
  634  1      
  635  1          return (INT8S)temp;
  636  1      }
  637         
  638         
  639         INT8U Rte_PreDriverOpenDelay(void)
  640         {
  641  1              static INT8U u8PreDriverOpenCnt = 0;
  642  1              
  643  1              if(u8PreDriverOpenCnt >= 40)
  644  1              {
C166 COMPILER V7.57.0, RTE                                                                 01/20/2021 09:50:48 PAGE 12  

  645  2                      IO_vSetPin(IO_P0_7); /* open pre driver */
  646  2              
  647  2                      return 1;
  648  2              }
  649  1              else
  650  1              {
  651  2                      u8PreDriverOpenCnt++;
  652  2                      
  653  2                      IO_vResetPin(IO_P0_7); /* close pre driver */
  654  2                      return 0;
  655  2              }
  656  1      }
  657         
  658         void Rte_WaitDriverRampDown(void)
  659         {
  660  1              static INT16U u16PreDriverRampDownCnt = 0;
  661  1              
  662  1          if(0 == IGNStatus_u8_Sig)
  663  1          {
  664  2              if(u16PreDriverRampDownCnt >= 40)
  665  2              {
  666  3                  NormalFinish_u8_Sig = 1;
  667  3              } 
  668  2                      else
  669  2                      {
  670  3                              u16PreDriverRampDownCnt++;
  671  3              }
  672  2          } 
  673  1              else
  674  1              {
  675  2              u16PreDriverRampDownCnt = 0;
  676  2          }
  677  1      }
  678         
  679         
  680         INT8U Rte_IGNStatusHandle(void)
  681         {
  682  1              static INT8U u8IgOffTimeCnt = 0;
  683  1              static INT8U u8IgOnTimeCnt = 0;
  684  1      
  685  1              if(0 == g_inIGNSts)
  686  1              {
  687  2                      u8IgOnTimeCnt = 0;
  688  2                      u8IgOffTimeCnt++;
  689  2                      if(u8IgOffTimeCnt >= IG_OFF_DURATION)
  690  2                      {
  691  3                              u8IgOffTimeCnt = IG_OFF_DURATION;
  692  3                              return IG_OFF;
  693  3                      }
  694  2              }
  695  1              else
  696  1              {
  697  2                      u8IgOffTimeCnt = 0;
  698  2                      u8IgOnTimeCnt++;
  699  2                      if(u8IgOnTimeCnt >= IG_ON_DURATION)
  700  2                      {
  701  3                              u8IgOnTimeCnt = IG_ON_DURATION;
  702  3                              return IG_ON;
  703  3                      }
  704  2              }
  705  1      
  706  1              return IG_ON;
C166 COMPILER V7.57.0, RTE                                                                 01/20/2021 09:50:48 PAGE 13  

  707  1      }
  708         
  709         
  710         INT16U lookupTable_1D(INT16U lookupIn, const INT16U bp0[], const INT16U table[], INT16U maxIndex)
  711         {
  712  1          INT16U lookupOutput = 0;
  713  1          INT32U frac = 0;
  714  1          INT16U yR_0d0 = 0;
  715  1          INT16U iRght = 0;
  716  1          INT16U iLeft = 0;
  717  1      
  718  1          if (lookupIn <= bp0[0UL])
  719  1          {
  720  2              iLeft = 0UL;
  721  2              frac = 0UL;
  722  2          }
  723  1          else if (lookupIn < bp0[maxIndex])
  724  1          {
  725  2              /* Binary Search */
  726  2              frac = maxIndex >> 1UL;
  727  2              iLeft = 0UL;
  728  2              iRght = maxIndex;
  729  2              while (iRght - iLeft > 1UL)
  730  2              {
  731  3                  if (lookupIn < bp0[frac])
  732  3                  {
  733  4                      iRght = frac;
*** WARNING C192 IN LINE 733 OF src\app\rte\rte.c: '=': value truncated
  734  4                  }
  735  3                  else
  736  3                  {
  737  4                      iLeft = frac;
*** WARNING C192 IN LINE 737 OF src\app\rte\rte.c: '=': value truncated
  738  4                  }
  739  3      
  740  3                  frac = (iRght + iLeft) >> 1UL;
  741  3              }
  742  2      
  743  2              frac = ((INT32U)(lookupIn - bp0[iLeft]) << 16) / (bp0[iLeft + 1UL] - bp0[iLeft]);
  744  2          }
  745  1          else
  746  1          {
  747  2              iLeft = maxIndex - 1UL;
*** WARNING C192 IN LINE 747 OF src\app\rte\rte.c: '=': value truncated
  748  2              frac = 65536UL;
  749  2          }
  750  1      
  751  1          if (table[iLeft + 1UL] >= table[iLeft])
  752  1          {
  753  2              lookupOutput = (INT16U)(((table[iLeft + 1UL] - table[iLeft]) * frac) >> 16) + table[iLeft];
  754  2          }
  755  1          else
  756  1          {
  757  2              lookupOutput = table[iLeft] - (INT16U)(((table[iLeft] - table[iLeft + 1UL]) * frac) >> 16);
  758  2          }
  759  1      
  760  1          return lookupOutput;
  761  1      }
  762         
  763         
  764         void Std_DataCopy(const void* src, void* tgt, INT16U dataLen)
  765         {
C166 COMPILER V7.57.0, RTE                                                                 01/20/2021 09:50:48 PAGE 14  

  766  1          INT16U index = 0;
  767  1              INT8U *ptr_src;
  768  1              INT8U *ptr_tgt;
  769  1              
  770  1              ptr_src = src;
  771  1              ptr_tgt = tgt;
  772  1              
  773  1          for (index = 0; index < dataLen; index++)
  774  1          {
  775  2              ptr_tgt[index] = ptr_src[index];
  776  2          }
  777  1      }
  778         
  779         
  780         BOOLEAN Std_DataCompare(const void* src, const void* tgt, INT16U dataLen)
  781         {
  782  1          INT16U index = 0;
  783  1              INT8U *ptr_src;
  784  1              INT8U *ptr_tgt;
  785  1              INT8U rtn_val = TRUE;
  786  1              
  787  1              ptr_src = src;
  788  1              ptr_tgt = tgt;
  789  1          
  790  1          for (index = 0; index < dataLen; index++)
  791  1          {
  792  2              if (ptr_src[index] != ptr_tgt[index])
  793  2              {
  794  3                  rtn_val = FALSE;
  795  3                              break;
  796  3              }
  797  2          }
  798  1              
  799  1          return rtn_val;
  800  1      }
  801         


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        4420     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =         256     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =         175     --------
  FAR-DATA SIZE    =         250     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =         330     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
