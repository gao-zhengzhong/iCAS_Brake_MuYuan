C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 1   


C166 COMPILER V7.57.0, COMPILATION OF MODULE CAN
OBJECT MODULE PLACED IN .\Obj\CAN.obj
COMPILER INVOKED BY: C:\Keil_v5\C166\BIN\C166.EXE src\driver\CAN.c MODV2 LARGE BROWSE INCDIR(.\src;.\src\bsw;.\src\drive
                    -r;.\src\interaction;.\src\app\adc;.\src\app\alogrithm;.\src\app\can;.\src\app\ccp;.\src\app\diagnostic;.\src\app\mode co
                    -ntrol;.\src\app\task;.\src\app\Fun;.\src\app\rtos;.\src\bsw\can;.\src\bsw\desc;.\src\bsw\nm;.\src\app\time measure;.\src
                    -\app\rte) MODV2 DEBUG PRINT(.\Lst\CAN.lst) OBJECT(.\Obj\CAN.obj) 

 stmt lvl     source

    1         //****************************************************************************
    2         // @Module        MultiCAN Module (CAN)
    3         // @Filename      CAN.c
    4         // @Project       P300.dav
    5         //----------------------------------------------------------------------------
    6         // @Controller    Infineon XC2365B-40F80
    7         //
    8         // @Compiler      Keil
    9         //
   10         // @Codegenerator 2.0
   11         //
   12         // @Description   This file contains functions that use the CAN module.
   13         //
   14         //----------------------------------------------------------------------------
   15         // @Date          2020/5/11 17:54:11
   16         //
   17         //****************************************************************************
   18         
   19         
   20         
   21         // USER CODE BEGIN (CAN_General,1)
   22         
   23         // USER CODE END
   24         
   25         
   26         
   27         //****************************************************************************
   28         // @Project Includes
   29         //****************************************************************************
   30         
   31         #include "MAIN.h"
   32         
   33         // USER CODE BEGIN (CAN_General,2)
   34         
   35         #include "can.h"
   36         #include "can_if.h"
   37         #include "can_com.h"
   38         // USER CODE END
   39         
   40         
   41         //****************************************************************************
   42         // @Macros
   43         //****************************************************************************
   44         
   45         // USER CODE BEGIN (CAN_General,3)
   46         
   47         // USER CODE END
   48         
   49         
   50         //****************************************************************************
   51         // @Defines
   52         //****************************************************************************
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 2   

   53         
   54         // USER CODE BEGIN (CAN_General,4)
   55         
   56         // USER CODE END
   57         
   58         
   59         //****************************************************************************
   60         // @Typedefs
   61         //****************************************************************************
   62         
   63         // USER CODE BEGIN (CAN_General,5)
   64         
   65         // USER CODE END
   66         
   67         
   68         //****************************************************************************
   69         // @Imported Global Variables
   70         //****************************************************************************
   71         
   72         // USER CODE BEGIN (CAN_General,6)
   73         
   74         // USER CODE END
   75         
   76         
   77         //****************************************************************************
   78         // @Global Variables
   79         //****************************************************************************
   80         
   81         static ubyte DataPointer_0[8];
   82         static ulong MessageId_0;
   83         static ubyte DataPointer_32[8];
   84         static ulong MessageId_32;
   85         
   86         
   87         // USER CODE BEGIN (CAN_General,7)
   88         
   89         // USER CODE END
   90         
   91         
   92         //****************************************************************************
   93         // @External Prototypes
   94         //****************************************************************************
   95         
   96         // USER CODE BEGIN (CAN_General,8)
   97         
   98         // USER CODE END
   99         
  100         
  101         //****************************************************************************
  102         // @Prototypes Of Local Functions
  103         //****************************************************************************
  104         
  105         // USER CODE BEGIN (CAN_General,9)
  106         
  107         // USER CODE END
  108         
  109         
  110         //****************************************************************************
  111         // @Function      void CAN_vInit(void) 
  112         //
  113         //----------------------------------------------------------------------------
  114         // @Description   This is the initialization function of the CAN function 
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 3   

  115         //                library. It is assumed that the SFRs used by this library 
  116         //                are in reset state. 
  117         //
  118         //----------------------------------------------------------------------------
  119         // @Returnvalue   None
  120         //
  121         //----------------------------------------------------------------------------
  122         // @Parameters    None
  123         //
  124         //----------------------------------------------------------------------------
  125         // @Date          2020/5/11
  126         //
  127         //****************************************************************************
  128         
  129         // USER CODE BEGIN (Init,1)
  130         
  131         // USER CODE END
  132         
  133         void CAN_vInit(void)
  134         {
  135  1              volatile unsigned int uwTemp;
  136  1      
  137  1              INT8U i = 0;
  138  1              INT16U objectIndex = 0;
  139  1              
  140  1              INT8U can0SvcObjectNumber = 0;
  141  1              INT8U can0SendObjectNumber = 0;
  142  1              INT8U can1SvcObjectNumber = 0;
  143  1              INT8U can1SendObjectNumber = 0;
  144  1              
  145  1              const CanSvcInst *ptr_can0SvcInst = CanCom_ApplCan0SvcInstAccess();
  146  1              const CanSendInst *ptr_can0SendInst = CanCom_ApplCan0SendInstAccess();
  147  1              const CanSvcInst *ptr_can1SvcInst = CanCom_ApplCan1SvcInstAccess();
  148  1              const CanSendInst *ptr_can1SendInst = CanCom_ApplCan1SendInstAccess();
  149  1              
  150  1              can0SvcObjectNumber = kCan0SvcInstNumItems > 16 ? 16 : kCan0SvcInstNumItems;
  151  1              can0SendObjectNumber = kCan0SendInstNumItems > 16 ? 16 : kCan0SendInstNumItems;
  152  1              can1SvcObjectNumber = kCan1SvcInstNumItems > 16 ? 16 : kCan1SvcInstNumItems;
  153  1              can1SendObjectNumber = kCan1SendInstNumItems > 16 ? 16 : kCan1SendInstNumItems;
  154  1              
  155  1        // USER CODE BEGIN (Init,2)
  156  1      
  157  1        // USER CODE END
  158  1      
  159  1        ///  -----------------------------------------------------------------------
  160  1        ///  Configuration of Kernel State Configuration Register:
  161  1        ///  -----------------------------------------------------------------------
  162  1        ///  - Enable the CAN module(MODEN)
  163  1        ///  - Enable Bit Protection for MODEN
  164  1      
  165  1          MCAN_KSCCFG  =  0x0003;      // load Kernel State Configuration Register
  166  1      
  167  1          uwTemp       =  MCAN_KSCCFG; // dummy read to avoid pipeline effects
  168  1      
  169  1        ///  -----------------------------------------------------------------------
  170  1        ///  Configuration of the Module Clock:
  171  1        ///  -----------------------------------------------------------------------
  172  1        ///  - the CAN module clock = 40.00 MHz
  173  1        ///  - Normal divider mode selected
  174  1      
  175  1          CAN_FDRL     =  0x43FE;      // load Fractional Divider Register
  176  1      
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 4   

  177  1          uwTemp       =  CAN_FDRL;    // dummy read to avoid pipeline effects
  178  1      
  179  1        ///  -----------------------------------------------------------------------
  180  1        ///  Panel Control
  181  1        ///  -----------------------------------------------------------------------
  182  1        ///  - wait until Panel has finished the initialisation
  183  1      
  184  1          while(CAN_PANCTRL & CAN_PANCTR_BUSY){ // wait until Panel has finished 
  185  2                                                // the initialisation
  186  2            }                         
  187  1      
  188  1        ///  -----------------------------------------------------------------------
  189  1        ///  Configuration of CAN Node 0:
  190  1        ///  -----------------------------------------------------------------------
  191  1      
  192  1        ///  General Configuration of the Node 0:
  193  1        ///  - set INIT and CCE
  194  1        ///  - enable interrupt generation upon a change of BOFF or EWARN or upon a 
  195  1        ///    set of LLE, LOE or INIT
  196  1        ///  - alert interrupt node pointer: MultiCAN SRN 2
  197  1      
  198  1          CAN_NCR0     =  0x0049;      // load NODE 0 control register[15-0]
  199  1      
  200  1        ///  - load NODE 0 interrupt pointer register
  201  1      
  202  1          CAN_NIPR0    =  0x0002;      // load NIPR0_LECINP, ALINP, CFCINP and TRINP
  203  1      
  204  1        ///  Configuration of the used CAN Port Pins:
  205  1        ///  - Loop-back mode is disabled
  206  1        ///  - P2.0 is used for CAN0 Receive input(RXDC0C)
  207  1        ///  - P2.1 is used for CAN0 Transmit output(TXDC0C)
  208  1      
  209  1        P2_IOCR01 = 0x0090;    //set direction register
  210  1          CAN_NPCR0    =  0x0002;      // load node0 port control register
  211  1      
  212  1      
  213  1        ///  Configuration of the Node 0 Baud Rate:
  214  1        ///  - required baud rate = 500.000 kbaud
  215  1        ///  - real baud rate     = 500.000 kbaud
  216  1        ///  - sample point       = 60.00 %
  217  1        ///  - there are 5 time quanta before sample point
  218  1        ///  - there are 4 time quanta after sample point
  219  1        ///  - the (re)synchronization jump width is 2 time quanta
  220  1      
  221  1          CAN_NBTR0L   =  0x3447;      // load NBTR0_DIV8, TSEG2, TSEG1, SJW and BRP
  222  1      
  223  1        ///  Configuration of the Node 0 Error Counter:
  224  1        ///  - the error warning threshold value (warning level) is 96
  225  1      
  226  1          CAN_NECNT0H = 0x0060;        // load NECNT0_EWRNLVL register
  227  1          CAN_NECNT0L = 0x0000;       
  228  1      
  229  1        ///  Configuration of the Frame Counter:
  230  1        ///  - Frame Counter Mode: the counter is incremented upon the reception 
  231  1        ///    and transmission of frames
  232  1        ///  - frame counter: 0x0000
  233  1      
  234  1          CAN_NFCR0H = 0x0000;         // load NFCR0_CFCOV, CFCIE, CFMOD, CFSEL
  235  1          CAN_NFCR0L = 0x0000;         // load NFCR0_CFC
  236  1      
  237  1        ///  -----------------------------------------------------------------------
  238  1        ///  Configuration of CAN Node 1:
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 5   

  239  1        ///  -----------------------------------------------------------------------
  240  1      
  241  1        ///  General Configuration of the Node 1:
  242  1        ///  - set INIT and CCE
  243  1        ///  - enable interrupt generation upon a change of BOFF or EWARN or upon a 
  244  1        ///    set of LLE, LOE or INIT
  245  1        ///  - alert interrupt node pointer: MultiCAN SRN 3
  246  1      
  247  1          CAN_NCR1     =  0x0049;      // load NODE 1 control register[15-0]
  248  1      
  249  1        ///  - load NODE 1 interrupt pointer register
  250  1      
  251  1          CAN_NIPR1    =  0x0003;      // load NIPR1_LECINP, ALINP, CFCINP and TRINP
  252  1      
  253  1        ///  Configuration of the used CAN Port Pins:
  254  1        ///  - Loop-back mode is disabled
  255  1        ///  - P2.4 is used for CAN1 Receive input(RXDC1A)
  256  1        ///  - P2.2 is used for CAN1 Transmit output(TXDC1B)
  257  1      
  258  1        P2_IOCR02 = 0x0090;    //set direction register
  259  1          CAN_NPCR1    =  0x0000;      // load node1 port control register
  260  1      
  261  1      
  262  1        ///  Configuration of the Node 1 Baud Rate:
  263  1        ///  - required baud rate = 500.000 kbaud
  264  1        ///  - real baud rate     = 500.000 kbaud
  265  1        ///  - sample point       = 60.00 %
  266  1        ///  - there are 5 time quanta before sample point
  267  1        ///  - there are 4 time quanta after sample point
  268  1        ///  - the (re)synchronization jump width is 2 time quanta
  269  1      
  270  1          CAN_NBTR1L   =  0x3440 | (4000 / Can1BaudRate - 1);      // load NBTR1_DIV8, TSEG2, TSEG1, SJW and BRP
  271  1      
  272  1        ///  Configuration of the Node 1 Error Counter:
  273  1        ///  - the error warning threshold value (warning level) is 96
  274  1      
  275  1          CAN_NECNT1H = 0x0060;        // load NECNT1_EWRNLVL register
  276  1          CAN_NECNT1L = 0x0000;       
  277  1      
  278  1        ///  Configuration of the Frame Counter:
  279  1        ///  - Frame Counter Mode: the counter is incremented upon the reception 
  280  1        ///    and transmission of frames
  281  1        ///  - frame counter: 0x0000
  282  1      
  283  1          CAN_NFCR1H = 0x0000;         // load NFCR1_CFCOV, CFCIE, CFMOD, CFSEL
  284  1          CAN_NFCR1L = 0x0000;         // load NFCR1_CFC
  285  1      
  286  1        ///  -----------------------------------------------------------------------
  287  1        ///  Configuration of CAN Node 2:
  288  1        ///  -----------------------------------------------------------------------
  289  1      
  290  1        ///  General Configuration of the Node 2:
  291  1        ///  - set INIT and CCE
  292  1      
  293  1          CAN_NCR2     =  0x0041;      // load NODE 2 control register[15-0]
  294  1      
  295  1        ///  -----------------------------------------------------------------------
  296  1        ///  Configuration of the CAN Message Object List Structure:
  297  1        ///  -----------------------------------------------------------------------
  298  1      
  299  1        ///  Allocate MOs for list 1:
  300  1      
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 6   

  301  1          SetListCommand(0x0100,0x0002);  // MO0 for list 1 (Node 0)
  302  1      
  303  1          SetListCommand(0x0101,0x0002);  // MO1 for list 1 (Node 0)
  304  1      
  305  1          SetListCommand(0x0102,0x0002);  // MO2 for list 1 (Node 0)
  306  1      
  307  1          SetListCommand(0x0103,0x0002);  // MO3 for list 1 (Node 0)
  308  1      
  309  1          SetListCommand(0x0104,0x0002);  // MO4 for list 1 (Node 0)
  310  1      
  311  1          SetListCommand(0x0105,0x0002);  // MO5 for list 1 (Node 0)
  312  1      
  313  1          SetListCommand(0x0106,0x0002);  // MO6 for list 1 (Node 0)
  314  1      
  315  1          SetListCommand(0x0107,0x0002);  // MO7 for list 1 (Node 0)
  316  1      
  317  1          SetListCommand(0x0108,0x0002);  // MO8 for list 1 (Node 0)
  318  1      
  319  1          SetListCommand(0x0109,0x0002);  // MO9 for list 1 (Node 0)
  320  1      
  321  1          SetListCommand(0x010A,0x0002);  // MO10 for list 1 (Node 0)
  322  1      
  323  1          SetListCommand(0x010B,0x0002);  // MO11 for list 1 (Node 0)
  324  1      
  325  1          SetListCommand(0x010C,0x0002);  // MO12 for list 1 (Node 0)
  326  1      
  327  1          SetListCommand(0x010D,0x0002);  // MO13 for list 1 (Node 0)
  328  1      
  329  1          SetListCommand(0x010E,0x0002);  // MO14 for list 1 (Node 0)
  330  1      
  331  1          SetListCommand(0x010F,0x0002);  // MO15 for list 1 (Node 0)
  332  1      
  333  1          SetListCommand(0x0110,0x0002);  // MO16 for list 1 (Node 0)
  334  1      
  335  1          SetListCommand(0x0111,0x0002);  // MO17 for list 1 (Node 0)
  336  1      
  337  1          SetListCommand(0x0112,0x0002);  // MO18 for list 1 (Node 0)
  338  1      
  339  1          SetListCommand(0x0113,0x0002);  // MO19 for list 1 (Node 0)
  340  1      
  341  1          SetListCommand(0x0114,0x0002);  // MO20 for list 1 (Node 0)
  342  1      
  343  1          SetListCommand(0x0115,0x0002);  // MO21 for list 1 (Node 0)
  344  1      
  345  1          SetListCommand(0x0116,0x0002);  // MO22 for list 1 (Node 0)
  346  1      
  347  1          SetListCommand(0x0117,0x0002);  // MO23 for list 1 (Node 0)
  348  1      
  349  1          SetListCommand(0x0118,0x0002);  // MO24 for list 1 (Node 0)
  350  1      
  351  1          SetListCommand(0x0119,0x0002);  // MO25 for list 1 (Node 0)
  352  1      
  353  1          SetListCommand(0x011A,0x0002);  // MO26 for list 1 (Node 0)
  354  1      
  355  1          SetListCommand(0x011B,0x0002);  // MO27 for list 1 (Node 0)
  356  1      
  357  1          SetListCommand(0x011C,0x0002);  // MO28 for list 1 (Node 0)
  358  1      
  359  1          SetListCommand(0x011D,0x0002);  // MO29 for list 1 (Node 0)
  360  1      
  361  1          SetListCommand(0x011E,0x0002);  // MO30 for list 1 (Node 0)
  362  1      
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 7   

  363  1          SetListCommand(0x011F,0x0002);  // MO31 for list 1 (Node 0)
  364  1      
  365  1        ///  Allocate MOs for list 2:
  366  1      
  367  1          SetListCommand(0x0220,0x0002);  // MO32 for list 2 (Node 1)
  368  1      
  369  1          SetListCommand(0x0221,0x0002);  // MO33 for list 2 (Node 1)
  370  1      
  371  1          SetListCommand(0x0222,0x0002);  // MO34 for list 2 (Node 1)
  372  1      
  373  1          SetListCommand(0x0223,0x0002);  // MO35 for list 2 (Node 1)
  374  1      
  375  1          SetListCommand(0x0224,0x0002);  // MO36 for list 2 (Node 1)
  376  1      
  377  1          SetListCommand(0x0225,0x0002);  // MO37 for list 2 (Node 1)
  378  1      
  379  1          SetListCommand(0x0226,0x0002);  // MO38 for list 2 (Node 1)
  380  1      
  381  1          SetListCommand(0x0227,0x0002);  // MO39 for list 2 (Node 1)
  382  1      
  383  1          SetListCommand(0x0228,0x0002);  // MO40 for list 2 (Node 1)
  384  1      
  385  1          SetListCommand(0x0229,0x0002);  // MO41 for list 2 (Node 1)
  386  1      
  387  1          SetListCommand(0x022A,0x0002);  // MO42 for list 2 (Node 1)
  388  1      
  389  1          SetListCommand(0x022B,0x0002);  // MO43 for list 2 (Node 1)
  390  1      
  391  1          SetListCommand(0x022C,0x0002);  // MO44 for list 2 (Node 1)
  392  1      
  393  1          SetListCommand(0x022D,0x0002);  // MO45 for list 2 (Node 1)
  394  1      
  395  1          SetListCommand(0x022E,0x0002);  // MO46 for list 2 (Node 1)
  396  1      
  397  1          SetListCommand(0x022F,0x0002);  // MO47 for list 2 (Node 1)
  398  1      
  399  1          SetListCommand(0x0230,0x0002);  // MO48 for list 2 (Node 1)
  400  1      
  401  1          SetListCommand(0x0231,0x0002);  // MO49 for list 2 (Node 1)
  402  1      
  403  1          SetListCommand(0x0232,0x0002);  // MO50 for list 2 (Node 1)
  404  1      
  405  1          SetListCommand(0x0233,0x0002);  // MO51 for list 2 (Node 1)
  406  1      
  407  1          SetListCommand(0x0234,0x0002);  // MO52 for list 2 (Node 1)
  408  1      
  409  1          SetListCommand(0x0235,0x0002);  // MO53 for list 2 (Node 1)
  410  1      
  411  1          SetListCommand(0x0236,0x0002);  // MO54 for list 2 (Node 1)
  412  1      
  413  1          SetListCommand(0x0237,0x0002);  // MO55 for list 2 (Node 1)
  414  1      
  415  1          SetListCommand(0x0238,0x0002);  // MO56 for list 2 (Node 1)
  416  1      
  417  1          SetListCommand(0x0239,0x0002);  // MO57 for list 2 (Node 1)
  418  1      
  419  1          SetListCommand(0x023A,0x0002);  // MO58 for list 2 (Node 1)
  420  1      
  421  1          SetListCommand(0x023B,0x0002);  // MO59 for list 2 (Node 1)
  422  1      
  423  1          SetListCommand(0x023C,0x0002);  // MO60 for list 2 (Node 1)
  424  1      
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 8   

  425  1          SetListCommand(0x023D,0x0002);  // MO61 for list 2 (Node 1)
  426  1      
  427  1          SetListCommand(0x023E,0x0002);  // MO62 for list 2 (Node 1)
  428  1      
  429  1          SetListCommand(0x023F,0x0002);  // MO63 for list 2 (Node 1)
  430  1      
  431  1        ///  -----------------------------------------------------------------------
  432  1        ///  Configuration of the CAN Message Objects 0 - 63:
  433  1        ///  -----------------------------------------------------------------------
  434  1              
  435  1              /* object 2 is used in the bootloader for sending. Write 1 to clear the register first */
  436  1              CAN_MOCTR2H = 0xffff;        // load MO0 control register high
  437  1              CAN_MOCTR2L = 0xffff;        // load MO0 control register low
  438  1                      
  439  1      //------------------------------------------------------------------------------------------------------
  440  1      //              @Function : CAN0 receive 
  441  1      //------------------------------------------------------------------------------------------------------        
  442  1              for(i = 0; i < can0SvcObjectNumber; i++)
  443  1              {
  444  2                      objectIndex = ptr_can0SvcInst[i].canObjIndex;
  445  2                      
  446  2                      if((INT32U)0 != (ptr_can0SvcInst[i].canId))
  447  2                      {
  448  3                              ///  General Configuration of the Message Object 0 :
  449  3                              ///  - message object 0 is valid
  450  3                              ///  - message object is used as receive object
  451  3                              ///  - this message object is assigned to list 1 (node 0)
  452  3                      /*
  453  3                              CAN_MOCTR0H = 0x00A0;        // load MO0 control register high
  454  3                              CAN_MOCTR0L = 0x0000;        // load MO0 control register low
  455  3                      */
  456  3                              (*((uword volatile far *) (0x20101E | (objectIndex * 0x20)))) = 0x00A0;        // load MO0 control regi
             -ster high
  457  3                              (*((uword volatile far *) (0x20101C | (objectIndex * 0x20)))) = 0x0000;        // load MO0 control regi
             -ster low
  458  3      
  459  3                              ///  Configuration of Message Object 0 Arbitration:
  460  3                              ///  - priority class 2; transmit acceptance filtering is based on the CAN 
  461  3                              ///    identifier
  462  3                              ///  - standard 11-bit identifier
  463  3                              ///  - identifier 11-bit:      0x000
  464  3                      /*
  465  3                              CAN_MOAR0H = 0x8000;             // load MO0 arbitration register high
  466  3                              CAN_MOAR0L = 0x0000;         // load MO0 arbitration register low
  467  3                      */
  468  3                              if(STANDARD_ID == ptr_can0SvcInst[i].canIdType)
  469  3                              {
  470  4                                      (*((uword volatile far *) (0x20101A | (objectIndex * 0x20)))) = 0x8000 | (((INT16U)ptr_can0SvcInst[i].
             -canId & 0x7FF) << 2); // load MO0 arbitration register high
  471  4                                      (*((uword volatile far *) (0x201018 | (objectIndex * 0x20)))) = 0x0000;         // load MO0 arbitratio
             -n register low
  472  4                              }
  473  3                              else
  474  3                              {
  475  4                                      (*((uword volatile far *) (0x20101A | (objectIndex * 0x20)))) = 0xA000 | (INT16U)((ptr_can0SvcInst[i].
             -canId >> 16) & 0x1FFF); // load MO0 arbitration register high
  476  4                                      (*((uword volatile far *) (0x201018 | (objectIndex * 0x20)))) = (INT16U)(ptr_can0SvcInst[i].canId);   
             -      // load MO0 arbitration register low
  477  4                              }
  478  3      
  479  3      
  480  3                              ///  Configuration of Message Object 0 acceptance mask:
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 9   

  481  3                              ///  - only accept receive frames with matching IDE bit
  482  3                              ///  - acceptance mask 11-bit: 0x7FF
  483  3                      /*
  484  3                              CAN_MOAMR0H = 0x3FFF;        // load MO0 acceptance mask register high
  485  3                              CAN_MOAMR0L = 0xFFFF;        // load MO0 acceptance mask register low
  486  3                      */
  487  3                              if(15 != objectIndex)
  488  3                              {
  489  4                                      (*((uword volatile far *) (0x20100E | (objectIndex * 0x20)))) = 0x3FFF;        // load MO0 acceptance 
             -mask register high
  490  4                                      (*((uword volatile far *) (0x20100C | (objectIndex * 0x20)))) = 0xFFFF;        // load MO0 acceptance 
             -mask register low
  491  4                              }
  492  3                              else
  493  3                              {
  494  4                                      (*((uword volatile far *) (0x20100E | (objectIndex * 0x20)))) = 0x2000;        // load MO0 acceptance 
             -mask register high
  495  4                                      (*((uword volatile far *) (0x20100C | (objectIndex * 0x20)))) = 0x0000;        // load MO0 acceptance 
             -mask register low
  496  4                              }
  497  3      
  498  3                              
  499  3                              ///  Configuration of Message Object 0 interrupt pointer:
  500  3                              ///  - use message pending register 0 bit position 0
  501  3                              ///  - receive interrupt node pointer: MultiCAN SRN 0
  502  3                      /*
  503  3                              CAN_MOIPR0H = 0x0000;        // load MO0 interrupt pointer register high
  504  3                              CAN_MOIPR0L = 0x0000;        // load MO0 interrupt pointer register low
  505  3                      */
  506  3                              (*((uword volatile far *) (0x20100A | (objectIndex * 0x20)))) = 0x0000;        // load MO0 interrupt po
             -inter register high
  507  3                              (*((uword volatile far *) (0x201008 | (objectIndex * 0x20)))) = 0x0000 | (objectIndex << 8);        // 
             -load MO0 interrupt pointer register low
  508  3      
  509  3                              ///  Configuration of Message Object 0 FIFO/Gateway pointer:
  510  3                      /*
  511  3                              CAN_MOFGPR0H = 0x0000;       // load MO0 FIFO/gateway pointer register high
  512  3                              CAN_MOFGPR0L = 0x0000;       // load MO0 FIFO/gateway pointer register low
  513  3                      */
  514  3                              (*((uword volatile far *) (0x201006 | (objectIndex * 0x20)))) = 0x0000;       // load MO0 FIFO/gateway 
             -pointer register high
  515  3                              (*((uword volatile far *) (0x201004 | (objectIndex * 0x20)))) = 0x0000;       // load MO0 FIFO/gateway 
             -pointer register low
  516  3      
  517  3      
  518  3                              ///  Configuration of Message Object 0 Function control:
  519  3                              ///  - this object is a STANDARD MESSAGE OBJECT
  520  3                              ///  - 8 valid data bytes
  521  3                              ///  - enable receive interrupt; bit RXPND is set after successful 
  522  3                              ///    reception of a frame
  523  3                      /*
  524  3                              CAN_MOFCR0H = 0x0001 | ((ptr_can0SvcInst[0].msgLen << 8) & 0x0F00); // load MO0 function control regist
             -er high
  525  3                              CAN_MOFCR0L = 0x0000;        // load MO0 function control register low
  526  3                      */
  527  3                              (*((uword volatile far *) (0x201002 | (objectIndex * 0x20)))) = 0x0001 | ((ptr_can0SvcInst[i].msgLen <<
             - 8) & 0x0F00); // load MO0 function control register high
  528  3                              (*((uword volatile far *) (0x201000 | (objectIndex * 0x20)))) = 0x0000;        // load MO0 function con
             -trol register low
  529  3                      }
  530  2              }       
  531  1              
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 10  

  532  1              
  533  1      
  534  1      //------------------------------------------------------------------------------------------------------
  535  1      //              @Function : CAN0 send 
  536  1      //------------------------------------------------------------------------------------------------------
  537  1              for(i = 0; i < can0SendObjectNumber; i++)
  538  1              {
  539  2                      objectIndex = ptr_can0SendInst[i].canObjIndex;
  540  2                      
  541  2                      if((INT32U)0 != (ptr_can0SendInst[i].canId))
  542  2                      {
  543  3                              (*((uword volatile far *) (0x20101E | (objectIndex * 0x20)))) = 0x0EA8;        // load MO16 control reg
             -ister high
  544  3                              (*((uword volatile far *) (0x20101C | (objectIndex * 0x20)))) = 0x0000;        // load MO16 control reg
             -ister low
  545  3                      
  546  3                              if(STANDARD_ID == ptr_can0SendInst[i].canIdType)
  547  3                              {
  548  4                                      (*((uword volatile far *) (0x20101A | (objectIndex * 0x20)))) = 0x8000 | (((INT16U)ptr_can0SendInst[i]
             -.canId & 0x7FF) << 2); // load MO16 arbitration register high
  549  4                                      (*((uword volatile far *) (0x201018 | (objectIndex * 0x20)))) = 0x0000;         // load MO16 arbitrati
             -on register low
  550  4                              }
  551  3                              else
  552  3                              {
  553  4                                      (*((uword volatile far *) (0x20101A | (objectIndex * 0x20)))) = 0xA000 | (INT16U)((ptr_can0SendInst[i]
             -.canId >> 16) & 0x1FFF); // load MO16 arbitration register high
  554  4                                      (*((uword volatile far *) (0x201018 | (objectIndex * 0x20)))) = (INT16U)(ptr_can0SendInst[i].canId);  
             -       // load MO16 arbitration register low
  555  4                              }
  556  3                              
  557  3                              (*((uword volatile far *) (0x201016 | (objectIndex * 0x20)))) = 0x0000;     // load MO16 Data Bytes(DB7
             - & DB6)
  558  3                              (*((uword volatile far *) (0x201014 | (objectIndex * 0x20)))) = 0x0000;     // load MO16 Data Bytes(DB5
             - & DB4)
  559  3                              (*((uword volatile far *) (0x201012 | (objectIndex * 0x20)))) = 0x0000;     // load MO16 Data Bytes(DB3
             - & DB2)
  560  3                              (*((uword volatile far *) (0x201010 | (objectIndex * 0x20)))) = 0x0000;     // load MO16 Data Bytes(DB1
             - & DB0)
  561  3                                                              
  562  3                              (*((uword volatile far *) (0x20100E | (objectIndex * 0x20)))) = 0x3FFF;        // load MO16 acceptance 
             -mask register high
  563  3                              (*((uword volatile far *) (0x20100C | (objectIndex * 0x20)))) = 0xFFFF;        // load MO16 acceptance 
             -mask register low
  564  3                              
  565  3                              (*((uword volatile far *) (0x20100A | (objectIndex * 0x20)))) = 0x0000;        // load MO16 interrupt p
             -ointer register high
  566  3                              (*((uword volatile far *) (0x201008 | (objectIndex * 0x20)))) = 0x0000 | (objectIndex << 8);        // 
             -load MO16 interrupt pointer register low
  567  3      
  568  3                              (*((uword volatile far *) (0x201006 | (objectIndex * 0x20)))) = 0x0000;       // load MO16 FIFO/gateway
             - pointer register high
  569  3                              (*((uword volatile far *) (0x201004 | (objectIndex * 0x20)))) = 0x0000;       // load MO16 FIFO/gateway
             - pointer register low
  570  3                      
  571  3              #if 1
  572  3                              if(16 == objectIndex)
  573  3                              {
  574  4                                      (*((uword volatile far *) (0x201002 | (objectIndex * 0x20)))) = 0x0002 | ((ptr_can0SendInst[i].msgLen 
             -<< 8) & 0x0F00); // load MO16 function control register high
  575  4                                      (*((uword volatile far *) (0x201000 | (objectIndex * 0x20)))) = 0x0000;        // load MO16 function c
             -ontrol register low
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 11  

  576  4                              }
  577  3                              else
  578  3              #endif
  579  3                              {
  580  4                                      (*((uword volatile far *) (0x201002 | (objectIndex * 0x20)))) = 0x0000 | ((ptr_can0SendInst[i].msgLen 
             -<< 8) & 0x0F00); // load MO16 function control register high
  581  4                                      (*((uword volatile far *) (0x201000 | (objectIndex * 0x20)))) = 0x0000;        // load MO16 function c
             -ontrol register low
  582  4                              }
  583  3                      }
  584  2              }
  585  1      
  586  1              
  587  1      
  588  1      //------------------------------------------------------------------------------------------------------
  589  1      //              @Function : CAN1 receive 
  590  1      //------------------------------------------------------------------------------------------------------
  591  1              for(i = 0; i < can1SvcObjectNumber; i++)
  592  1              {
  593  2                      objectIndex = ptr_can1SvcInst[i].canObjIndex;
  594  2                      
  595  2                      if((INT32U)0 != (ptr_can1SvcInst[i].canId))
  596  2                      {
  597  3                              (*((uword volatile far *) (0x20101E | (objectIndex * 0x20)))) = 0x00A0;        // load MO0 control regi
             -ster high
  598  3                              (*((uword volatile far *) (0x20101C | (objectIndex * 0x20)))) = 0x0000;        // load MO0 control regi
             -ster low
  599  3      
  600  3                              if(STANDARD_ID == ptr_can1SvcInst[i].canIdType)
  601  3                              {
  602  4                                      (*((uword volatile far *) (0x20101A | (objectIndex * 0x20)))) = 0x8000 | (((INT16U)ptr_can1SvcInst[i].
             -canId & 0x7FF) << 2); // load MO0 arbitration register high
  603  4                                      (*((uword volatile far *) (0x201018 | (objectIndex * 0x20)))) = 0x0000;         // load MO0 arbitratio
             -n register low
  604  4                              }
  605  3                              else
  606  3                              {
  607  4                                      (*((uword volatile far *) (0x20101A | (objectIndex * 0x20)))) = 0xA000 | (INT16U)((ptr_can1SvcInst[i].
             -canId >> 16) & 0x1FFF); // load MO0 arbitration register high
  608  4                                      (*((uword volatile far *) (0x201018 | (objectIndex * 0x20)))) = (INT16U)(ptr_can1SvcInst[i].canId);   
             -      // load MO0 arbitration register low
  609  4                              }
  610  3      
  611  3                              if(47 != objectIndex)
  612  3                              {
  613  4                                      (*((uword volatile far *) (0x20100E | (objectIndex * 0x20)))) = 0x3FFF;        // load MO0 acceptance 
             -mask register high
  614  4                                      (*((uword volatile far *) (0x20100C | (objectIndex * 0x20)))) = 0xFFFF;        // load MO0 acceptance 
             -mask register low
  615  4                              }
  616  3                              else
  617  3                              {
  618  4                                      (*((uword volatile far *) (0x20100E | (objectIndex * 0x20)))) = 0x2000;        // load MO0 acceptance 
             -mask register high
  619  4                                      (*((uword volatile far *) (0x20100C | (objectIndex * 0x20)))) = 0x0000;        // load MO0 acceptance 
             -mask register low
  620  4                              }
  621  3      
  622  3                              (*((uword volatile far *) (0x20100A | (objectIndex * 0x20)))) = 0x0000;        // load MO0 interrupt po
             -inter register high
  623  3                              (*((uword volatile far *) (0x201008 | (objectIndex * 0x20)))) = 0x0001 | (objectIndex << 8);        // 
             -load MO0 interrupt pointer register low
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 12  

  624  3      
  625  3                              (*((uword volatile far *) (0x201006 | (objectIndex * 0x20)))) = 0x0000;       // load MO0 FIFO/gateway 
             -pointer register high
  626  3                              (*((uword volatile far *) (0x201004 | (objectIndex * 0x20)))) = 0x0000;       // load MO0 FIFO/gateway 
             -pointer register low
  627  3      
  628  3                              (*((uword volatile far *) (0x201002 | (objectIndex * 0x20)))) = 0x0001 | ((ptr_can1SvcInst[i].msgLen <<
             - 8) & 0x0F00); // load MO0 function control register high
  629  3                              (*((uword volatile far *) (0x201000 | (objectIndex * 0x20)))) = 0x0000;        // load MO0 function con
             -trol register low
  630  3                      }
  631  2              }
  632  1      
  633  1              
  634  1      
  635  1      //------------------------------------------------------------------------------------------------------
  636  1      //              @Function : CAN1 send 
  637  1      //------------------------------------------------------------------------------------------------------
  638  1              for(i = 0; i < can1SendObjectNumber; i++)
  639  1              {
  640  2                      objectIndex = ptr_can1SendInst[i].canObjIndex;
  641  2                      
  642  2                      if((INT32U)0 != (ptr_can1SendInst[i].canId))
  643  2                      {
  644  3                              (*((uword volatile far *) (0x20101E | (objectIndex * 0x20)))) = 0x0EA8;        // load MO16 control reg
             -ister high
  645  3                              (*((uword volatile far *) (0x20101C | (objectIndex * 0x20)))) = 0x0000;        // load MO16 control reg
             -ister low
  646  3      
  647  3                              if(STANDARD_ID == ptr_can1SendInst[i].canIdType)
  648  3                              {
  649  4                                      (*((uword volatile far *) (0x20101A | (objectIndex * 0x20)))) = 0x8000 | (((INT16U)ptr_can1SendInst[i]
             -.canId & 0x7FF) << 2); // load MO16 arbitration register high
  650  4                                      (*((uword volatile far *) (0x201018 | (objectIndex * 0x20)))) = 0x0000;         // load MO16 arbitrati
             -on register low
  651  4                              }
  652  3                              else
  653  3                              {
  654  4                                      (*((uword volatile far *) (0x20101A | (objectIndex * 0x20)))) = 0xA000 | (INT16U)((ptr_can1SendInst[i]
             -.canId >> 16) & 0x1FFF); // load MO16 arbitration register high
  655  4                                      (*((uword volatile far *) (0x201018 | (objectIndex * 0x20)))) = (INT16U)(ptr_can1SendInst[i].canId);  
             -       // load MO16 arbitration register low
  656  4                              }
  657  3      
  658  3                              (*((uword volatile far *) (0x201016 | (objectIndex * 0x20)))) = 0x0000;     // load MO16 Data Bytes(DB7
             - & DB6)
  659  3                              (*((uword volatile far *) (0x201014 | (objectIndex * 0x20)))) = 0x0000;     // load MO16 Data Bytes(DB5
             - & DB4)
  660  3                              (*((uword volatile far *) (0x201012 | (objectIndex * 0x20)))) = 0x0000;     // load MO16 Data Bytes(DB3
             - & DB2)
  661  3                              (*((uword volatile far *) (0x201010 | (objectIndex * 0x20)))) = 0x0000;     // load MO16 Data Bytes(DB1
             - & DB0)         
  662  3      
  663  3                              (*((uword volatile far *) (0x20100E | (objectIndex * 0x20)))) = 0x3FFF;        // load MO16 acceptance 
             -mask register high
  664  3                              (*((uword volatile far *) (0x20100C | (objectIndex * 0x20)))) = 0xFFFF;        // load MO16 acceptance 
             -mask register low
  665  3                              
  666  3                              if(48 == objectIndex)
  667  3                              {
  668  4                                      (*((uword volatile far *) (0x20100A | (objectIndex * 0x20)))) = 0x0000;        // load MO16 interrupt 
             -pointer register high
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 13  

  669  4                                      (*((uword volatile far *) (0x201008 | (objectIndex * 0x20)))) = 0x0010 | (objectIndex << 8);        //
             - load MO16 interrupt pointer register low
  670  4                              }
  671  3                              else
  672  3                              {
  673  4                                      (*((uword volatile far *) (0x20100A | (objectIndex * 0x20)))) = 0x0000;        // load MO16 interrupt 
             -pointer register high
  674  4                                      (*((uword volatile far *) (0x201008 | (objectIndex * 0x20)))) = 0x0000 | (objectIndex << 8);        //
             - load MO16 interrupt pointer register low
  675  4                              }
  676  3      
  677  3                              (*((uword volatile far *) (0x201006 | (objectIndex * 0x20)))) = 0x0000;       // load MO16 FIFO/gateway
             - pointer register high
  678  3                              (*((uword volatile far *) (0x201004 | (objectIndex * 0x20)))) = 0x0000;       // load MO16 FIFO/gateway
             - pointer register low
  679  3      
  680  3              #if 1
  681  3                              if(48 == objectIndex)
  682  3                              {
  683  4                                      (*((uword volatile far *) (0x201002 | (objectIndex * 0x20)))) = 0x0002 | ((ptr_can1SendInst[i].msgLen 
             -<< 8) & 0x0F00); // load MO16 function control register high
  684  4                                      (*((uword volatile far *) (0x201000 | (objectIndex * 0x20)))) = 0x0000;        // load MO16 function c
             -ontrol register low
  685  4                              }
  686  3                              else
  687  3              #endif
  688  3                              {
  689  4                                      (*((uword volatile far *) (0x201002 | (objectIndex * 0x20)))) = 0x0000 | ((ptr_can1SendInst[i].msgLen 
             -<< 8) & 0x0F00); // load MO16 function control register high
  690  4                                      (*((uword volatile far *) (0x201000 | (objectIndex * 0x20)))) = 0x0000;        // load MO16 function c
             -ontrol register low
  691  4                              }
  692  3                      }       
  693  2              }
  694  1      
  695  1      
  696  1      
  697  1        ///  -----------------------------------------------------------------------
  698  1        ///  Configuration of Service Request Nodes 0 - 15:
  699  1        ///  -----------------------------------------------------------------------
  700  1        ///  SRN0 service request node configuration:
  701  1        ///  - SRN0 interrupt priority level (ILVL) = 4
  702  1        ///  - SRN0 interrupt group level (GLVL) = 0
  703  1        ///  - SRN0 group priority extension (GPX) = 0
  704  1      
  705  1        CAN_0IC        =  0x0050;     
  706  1      
  707  1        ///  SRN1 service request node configuration:
  708  1        ///  - SRN1 interrupt priority level (ILVL) = 4
  709  1        ///  - SRN1 interrupt group level (GLVL) = 1
  710  1        ///  - SRN1 group priority extension (GPX) = 0
  711  1      
  712  1        CAN_1IC        =  0x0051;     
  713  1      
  714  1        ///  SRN2 service request node configuration:
  715  1        ///  - SRN2 interrupt priority level (ILVL) = 3
  716  1        ///  - SRN2 interrupt group level (GLVL) = 2
  717  1        ///  - SRN2 group priority extension (GPX) = 0
  718  1      
  719  1        CAN_2IC        =  0x004E;     
  720  1      
  721  1        ///  SRN3 service request node configuration:
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 14  

  722  1        ///  - SRN3 interrupt priority level (ILVL) = 3
  723  1        ///  - SRN3 interrupt group level (GLVL) = 1
  724  1        ///  - SRN3 group priority extension (GPX) = 0
  725  1      
  726  1        CAN_3IC        =  0x004D;     
  727  1      
  728  1      
  729  1        //   -----------------------------------------------------------------------
  730  1        //   Start the CAN Nodes:
  731  1        //   -----------------------------------------------------------------------
  732  1      
  733  1        ///  - ------------- CAN_NCR0 ----------------------------------------------
  734  1      
  735  1          CAN_NCR0 &= ~ (uword) 0x0041; // reset INIT and CCE
  736  1        ///  - ------------- CAN_NCR1 ----------------------------------------------
  737  1      
  738  1          CAN_NCR1 &= ~ (uword) 0x0041; // reset INIT and CCE
  739  1      
  740  1      
  741  1      
  742  1        // USER CODE BEGIN (Init,3)
  743  1      
  744  1        // USER CODE END
  745  1      
  746  1      } //  End of function CAN_vInit
  747         
  748         //****************************************************************************
  749         // @Function      void CAN_vTransmit(ubyte ubObjNr) 
  750         //
  751         //----------------------------------------------------------------------------
  752         // @Description   This function triggers the CAN controller to send the 
  753         //                selected message.
  754         //                If the selected message object is a TRANSMIT OBJECT then 
  755         //                this function triggers the sending of a data frame. If 
  756         //                however the selected message object is a RECEIVE OBJECT 
  757         //                this function triggers the sending of a remote frame.
  758         //
  759         //----------------------------------------------------------------------------
  760         // @Returnvalue   None
  761         //
  762         //----------------------------------------------------------------------------
  763         // @Parameters    ubObjNr: 
  764         //                Number of the message object (0-63)
  765         //
  766         //----------------------------------------------------------------------------
  767         // @Date          2020/5/11
  768         //
  769         //****************************************************************************
  770         
  771         // USER CODE BEGIN (Transmit,1)
  772         
  773         // USER CODE END
  774         
  775         void CAN_vTransmit(ubyte ubObjNr)
  776         {
  777  1      
  778  1        CAN_HWOBJ[ubObjNr].uwMOCTRH = 0x0720;  // set TXRQ,TXEN0,TXEN1,MSGVAL
  779  1      
  780  1      } //  End of function CAN_vTransmit
  781         
  782         //****************************************************************************
  783         // @Function      void CAN_vLoadData(ubyte ubObjNr, ubyte *ubpubData) 
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 15  

  784         //
  785         //----------------------------------------------------------------------------
  786         // @Description   If a hardware TRANSMIT OBJECT has to be loaded with data 
  787         //                but not with a new identifier, this function may be used 
  788         //                instead of the function CAN_vConfigMsgObj. The message 
  789         //                object should be accessed by calling the function 
  790         //                CAN_ubRequestMsgObj before calling this function. This 
  791         //                prevents the CAN controller from working with invalid data.
  792         //
  793         //----------------------------------------------------------------------------
  794         // @Returnvalue   None
  795         //
  796         //----------------------------------------------------------------------------
  797         // @Parameters    ubObjNr: 
  798         //                Number of the message object to be configured (0-63)
  799         // @Parameters    *ubpubData: 
  800         //                Pointer on a data buffer
  801         //
  802         //----------------------------------------------------------------------------
  803         // @Date          2020/5/11
  804         //
  805         //****************************************************************************
  806         
  807         // USER CODE BEGIN (LoadData,1)
  808         
  809         // USER CODE END
  810         
  811         void CAN_vLoadData(ubyte ubObjNr, ubyte *ubpubData)
  812         {
  813  1        ubyte i;
  814  1      
  815  1        CAN_HWOBJ[ubObjNr].uwMOCTRH = 0x0008;       // set NEWDAT
  816  1      
  817  1        for(i = 0; i < (CAN_HWOBJ[ubObjNr].uwMOFCRH & 0x0F00) >> 8; i++)
  818  1        {
  819  2          CAN_HWOBJ[ubObjNr].ubData[i] = *(ubpubData++); //load MODATA
  820  2        }
  821  1      
  822  1        CAN_HWOBJ[ubObjNr].uwMOCTRH = 0x0020;       // set MSGVAL
  823  1        CAN_HWOBJ[ubObjNr].uwMOCTRL = 0x0040;       // reset RTSEL
  824  1      
  825  1      } //  End of function CAN_vLoadData
  826         
  827         //****************************************************************************
  828         // @Function      void Can_Init(void) 
  829         //
  830         //----------------------------------------------------------------------------
  831         // @Description   This is the initialization function of the CAN_LLD function 
  832         //                library. It is assumed that the SFRs used by this library 
  833         //                are in reset state. 
  834         //                The Function CAN_vInit() is called to Initialize as per 
  835         //                DAvE Configuration.
  836         //
  837         //----------------------------------------------------------------------------
  838         // @Returnvalue   None
  839         //
  840         //----------------------------------------------------------------------------
  841         // @Parameters    None
  842         //
  843         //----------------------------------------------------------------------------
  844         // @Date          2020/5/11
  845         //
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 16  

  846         //****************************************************************************
  847         
  848         // USER CODE BEGIN (LLDInit,1)
  849         
  850         // USER CODE END
  851         
  852         void Can_Init(void)
  853         {
  854  1      
  855  1      // USER CODE BEGIN (LLDInit,2)
  856  1      
  857  1      // USER CODE END
  858  1      
  859  1        CAN_vInit(); // Call initialization function
  860  1      
  861  1      // USER CODE BEGIN (LLDInit,3)
  862  1      
  863  1      // USER CODE END
  864  1      
  865  1      } //  End of function Can_Init
  866         
  867         //****************************************************************************
  868         // @Function      ubyte Can_SetControllerMode(ubyte Controller, 
  869         //                Can_StateTransitionType Transition) 
  870         //
  871         //----------------------------------------------------------------------------
  872         // @Description   This function performs software triggered state transition 
  873         //                of the CAN Contrller state machine.
  874         //
  875         //----------------------------------------------------------------------------
  876         // @Returnvalue   1 if transition success, else 0
  877         //
  878         //----------------------------------------------------------------------------
  879         // @Parameters    Controller: 
  880         //                CAN Controller for which the state shall be changed 
  881         //                Transition. Number of node ( 0 - 3)
  882         // @Parameters    Transition: 
  883         //                Transition - Transition requested.The following definitions 
  884         //                for TimerNr are available: CAN_T_START, CAN_T_STOP, 
  885         //                CAN_T_SLEEP, CAN_T_WAKEUP
  886         //
  887         //----------------------------------------------------------------------------
  888         // @Date          2020/5/11
  889         //
  890         //****************************************************************************
  891         
  892         // USER CODE BEGIN (SetControllerMode,1)
  893         
  894         // USER CODE END
  895         
  896         ubyte Can_SetControllerMode(ubyte Controller, Can_StateTransitionType Transition)
  897         {
  898  1      ubyte retValue = 0;
  899  1      
  900  1            switch (Transition)
  901  1            {
  902  2              case CAN_T_START:
  903  2      
  904  2                /* Allow participation of the node/controller in the CAN traffic */
  905  2                  CAN_HWNodes[Controller].uwNCR = (CAN_HWNodes[Controller].uwNCR & ~CAN_NCR_INIT);
  906  2      
  907  2                // USER CODE BEGIN (SetControllerMode,2)
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 17  

  908  2      
  909  2                // USER CODE END
  910  2                retValue = 1 ;
  911  2      
  912  2                break ;
  913  2      
  914  2              case CAN_T_STOP:
  915  2      
  916  2                 /* Terminate participation of the node/controller in the CAN traffic */
  917  2                  CAN_HWNodes[Controller].uwNCR = (CAN_HWNodes[Controller].uwNCR | CAN_NCR_INIT);
  918  2      
  919  2                // USER CODE BEGIN (SetControllerMode,3)
  920  2      
  921  2                // USER CODE END
  922  2      
  923  2                retValue = 1 ;
  924  2      
  925  2                break ;
  926  2      
  927  2              case CAN_T_SLEEP:
  928  2      
  929  2                // USER CODE BEGIN (SetControllerMode,4)
  930  2      
  931  2                // USER CODE END
  932  2      
  933  2                break ;
  934  2      
  935  2              case CAN_T_WAKEUP:
  936  2      
  937  2                // USER CODE BEGIN (SetControllerMode,5)
  938  2      
  939  2                // USER CODE END
  940  2                break ;
  941  2      
  942  2              default:
  943  2      
  944  2                // USER CODE BEGIN (SetControllerMode,6)
  945  2      
  946  2                // USER CODE END
  947  2                  break;
  948  2      
  949  2            }
  950  1      
  951  1          // USER CODE BEGIN (SetControllerMode,7)
  952  1      
  953  1          // USER CODE END
  954  1      
  955  1          return retValue ;
  956  1      
  957  1      } //  End of function Can_SetControllerMode
  958         
  959         //****************************************************************************
  960         // @Function      void Can_lInitializeController(const ubyte Controller, 
  961         //                const uword Config) 
  962         //
  963         //----------------------------------------------------------------------------
  964         // @Description   This function (re-)initialization of CAN Controller.
  965         //                NOTE: The generated configurations are as per DAvE Node 
  966         //                Configuration
  967         //
  968         //----------------------------------------------------------------------------
  969         // @Returnvalue   None
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 18  

  970         //
  971         //----------------------------------------------------------------------------
  972         // @Parameters    Controller: 
  973         //                CAN Controller to be initialized. Number of node ( 0 - 3)
  974         // @Parameters    Config: 
  975         //                Config - controller configuration.
  976         //
  977         //----------------------------------------------------------------------------
  978         // @Date          2020/5/11
  979         //
  980         //****************************************************************************
  981         
  982         // USER CODE BEGIN (lInitializeController,1)
  983         
  984         // USER CODE END
  985         
  986         void Can_lInitializeController(const ubyte Controller, const uword Config)
  987         {
  988  1      
  989  1      // USER CODE BEGIN (lInitializeController,2)
  990  1      
  991  1      // USER CODE END
  992  1      
  993  1          CAN_HWNodes[Controller].uwNCR = (CAN_HWNodes[Controller].uwNCR | ( CAN_NCR_INIT | CAN_NCR_CCE ));
  994  1      
  995  1            /* Set Node Bit Timing values from configuration.
  996  1               Note: Masking is done to exclude loop back enable setting. */
  997  1      
  998  1          CAN_HWNodes[Controller].uwNBTRL = Config; // load NBTR0_DIV8, TSEG2, TSEG1, SJW and BRP
  999  1      
 1000  1        switch (Controller)
 1001  1        {
 1002  2          case CAN_CONTROLLER0:
 1003  2      
 1004  2      
 1005  2            CAN_HWNodes[Controller].uwNECNTH = 0x0060; // load NECNT0_EWRNLVL 
 1006  2                                                       // register
 1007  2            CAN_HWNodes[Controller].uwNECNTL = 0x0000;
 1008  2      
 1009  2            /* Disable Configuration Change - NBTR, NPCR, NECNT can only be read */
 1010  2            CAN_HWNodes[Controller].uwNCR = ( CAN_HWNodes[Controller].uwNCR & ~CAN_NCR_CCE) ;
 1011  2      
 1012  2            // USER CODE BEGIN (lInitializeController,   3 )
 1013  2      
 1014  2            // USER CODE END
 1015  2      
 1016  2          break ;
 1017  2      
 1018  2          case CAN_CONTROLLER1:
 1019  2      
 1020  2      
 1021  2            CAN_HWNodes[Controller].uwNECNTH = 0x0060; // load NECNT1_EWRNLVL 
 1022  2                                                       // register
 1023  2            CAN_HWNodes[Controller].uwNECNTL = 0x0000;
 1024  2      
 1025  2            /* Disable Configuration Change - NBTR, NPCR, NECNT can only be read */
 1026  2            CAN_HWNodes[Controller].uwNCR = ( CAN_HWNodes[Controller].uwNCR & ~CAN_NCR_CCE) ;
 1027  2      
 1028  2            // USER CODE BEGIN (lInitializeController,   4 )
 1029  2      
 1030  2            // USER CODE END
 1031  2      
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 19  

 1032  2          break ;
 1033  2      
 1034  2          default:
 1035  2      
 1036  2            // USER CODE BEGIN (lInitializeController,8)
 1037  2      
 1038  2            // USER CODE END
 1039  2      
 1040  2          break;
 1041  2        }
 1042  1      
 1043  1        // USER CODE BEGIN (lInitializeController,9)
 1044  1      
 1045  1        // USER CODE END
 1046  1      
 1047  1      } //  End of function Can_lInitializeController
 1048         
 1049         //****************************************************************************
 1050         // @Function      void Can_EnableControllerInterrupts(ubyte Controller) 
 1051         //
 1052         //----------------------------------------------------------------------------
 1053         // @Description   This function enables CAN Node interrupts which are 
 1054         //                configured in DAvE.
 1055         //
 1056         //----------------------------------------------------------------------------
 1057         // @Returnvalue   None
 1058         //
 1059         //----------------------------------------------------------------------------
 1060         // @Parameters    Controller: 
 1061         //                CAN Controller for which interrupts shall be enabled. 
 1062         //                Number of node ( 0 - 3)
 1063         //
 1064         //----------------------------------------------------------------------------
 1065         // @Date          2020/5/11
 1066         //
 1067         //****************************************************************************
 1068         
 1069         // USER CODE BEGIN (EnableControllerInterrupts,1)
 1070         
 1071         // USER CODE END
 1072         
 1073         void Can_EnableControllerInterrupts(ubyte Controller)
 1074         {
 1075  1      
 1076  1        // USER CODE BEGIN (EnableControllerInterrupts,2)
 1077  1      
 1078  1        // USER CODE END
 1079  1      
 1080  1        switch (Controller)
 1081  1        {
 1082  2          case CAN_CONTROLLER0:
 1083  2      
 1084  2            // - load NODE 0 control register
 1085  2      
 1086  2            CAN_NCR0   =  0x0008;      // load NODE 0 control register
 1087  2      
 1088  2            // USER CODE BEGIN (EnableControllerInterrupts,   3 )
 1089  2      
 1090  2            // USER CODE END
 1091  2      
 1092  2          break ;
 1093  2      
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 20  

 1094  2          case CAN_CONTROLLER1:
 1095  2      
 1096  2            // - load NODE 1 control register
 1097  2      
 1098  2            CAN_NCR1   =  0x0008;      // load NODE 1 control register
 1099  2      
 1100  2            // USER CODE BEGIN (EnableControllerInterrupts,   4 )
 1101  2      
 1102  2            // USER CODE END
 1103  2      
 1104  2          break ;
 1105  2      
 1106  2          default:
 1107  2      
 1108  2            // USER CODE BEGIN (EnableControllerInterrupts,8)
 1109  2      
 1110  2            // USER CODE END
 1111  2      
 1112  2          break;
 1113  2        }
 1114  1      
 1115  1        // USER CODE BEGIN (EnableControllerInterrupts,9)
 1116  1      
 1117  1        // USER CODE END
 1118  1      
 1119  1      } //  End of function Can_EnableControllerInterrupts
 1120         
 1121         //****************************************************************************
 1122         // @Function      void Can_DisableControllerInterrupts(ubyte Controller) 
 1123         //
 1124         //----------------------------------------------------------------------------
 1125         // @Description   This function disables CAN Node interrupts which are 
 1126         //                configured in DAvE.
 1127         //
 1128         //----------------------------------------------------------------------------
 1129         // @Returnvalue   None
 1130         //
 1131         //----------------------------------------------------------------------------
 1132         // @Parameters    Controller: 
 1133         //                CAN Controller for which interrupts shall be disabled. 
 1134         //                Number of node ( 0 - 3)
 1135         //
 1136         //----------------------------------------------------------------------------
 1137         // @Date          2020/5/11
 1138         //
 1139         //****************************************************************************
 1140         
 1141         // USER CODE BEGIN (DisableControllerInterrupts,1)
 1142         
 1143         // USER CODE END
 1144         
 1145         void Can_DisableControllerInterrupts(ubyte Controller)
 1146         {
 1147  1      
 1148  1        // USER CODE BEGIN (DisableControllerInterrupts,2)
 1149  1      
 1150  1        // USER CODE END
 1151  1      
 1152  1        switch (Controller)
 1153  1        {
 1154  2          case CAN_CONTROLLER0:
 1155  2      
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 21  

 1156  2            // - load NODE 0 control register
 1157  2      
 1158  2            CAN_NCR0  &= ~  0x0008;    // load NODE 0 control register
 1159  2      
 1160  2            // USER CODE BEGIN (DisableControllerInterrupts,   3 )
 1161  2      
 1162  2            // USER CODE END
 1163  2      
 1164  2          break ;
 1165  2      
 1166  2          case CAN_CONTROLLER1:
 1167  2      
 1168  2            // - load NODE 1 control register
 1169  2      
 1170  2            CAN_NCR1  &= ~  0x0008;    // load NODE 1 control register
 1171  2      
 1172  2            // USER CODE BEGIN (DisableControllerInterrupts,   4 )
 1173  2      
 1174  2            // USER CODE END
 1175  2      
 1176  2          break ;
 1177  2      
 1178  2          default:
 1179  2      
 1180  2            // USER CODE BEGIN (DisableControllerInterrupts,8)
 1181  2      
 1182  2            // USER CODE END
 1183  2      
 1184  2          break;
 1185  2        }
 1186  1      
 1187  1        // USER CODE BEGIN (DisableControllerInterrupts,9)
 1188  1      
 1189  1        // USER CODE END
 1190  1      
 1191  1      } //  End of function Can_DisableControllerInterrupts
 1192         
 1193         
 1194         
 1195         //****************************************************************************
 1196         // @Macro         CAN_viSRN0() 
 1197         //
 1198         //----------------------------------------------------------------------------
 1199         // @Description   
 1200         //
 1201         //----------------------------------------------------------------------------
 1202         // @Returnvalue   
 1203         //
 1204         //----------------------------------------------------------------------------
 1205         // @Parameters    None
 1206         //
 1207         //----------------------------------------------------------------------------
 1208         // @Date          2020/5/11
 1209         //
 1210         //****************************************************************************
 1211         
 1212         // USER CODE BEGIN (SRN0,1)
 1213         
 1214         // USER CODE END
 1215         
 1216         void CAN_viSRN0(void) interrupt CAN_SRN0INT
 1217         {
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 22  

 1218  1      
 1219  1        uword uwSRN0ObjHandler;
 1220  1        ubyte ubMessagePendingIndex0 = 0u;
 1221  1      
 1222  1        // USER CODE BEGIN (SRN0,2)
 1223  1      
 1224  1        // USER CODE END
 1225  1      
 1226  1        CAN_MSIMASKH = 0x0001;          // set message index mask register
 1227  1        CAN_MSIMASKL = 0xFFFF;
 1228  1      
 1229  1        while (CAN_MSID0 != 0x0020)
 1230  1        {
 1231  2                ubMessagePendingIndex0 = (ubyte)CAN_MSID0;
 1232  2                
 1233  2                if(ubMessagePendingIndex0 <= 15)
 1234  2                {
 1235  3                        uwSRN0ObjHandler = CAN_HWOBJ[ubMessagePendingIndex0].uwMOCTRL;
 1236  3      
 1237  3                        if(uwSRN0ObjHandler & MOSTAT_RXPND)          // if message object 0 receive interrupt
 1238  3                        {
 1239  4                                      // USER CODE BEGIN (SRN0_OBJ0,1)
 1240  4      
 1241  4                                      // USER CODE END
 1242  4      
 1243  4                              if(uwSRN0ObjHandler & MOSTAT_NEWDAT)       // if NEWDAT is set
 1244  4                              {
 1245  5                                      // USER CODE BEGIN (SRN0_OBJ0,2)
 1246  5      
 1247  5                                      // USER CODE END
 1248  5      
 1249  5                                if (uwSRN0ObjHandler & MOSTAT_MSGLST)    // if MSGLST is set
 1250  5                                {
 1251  6                                      // Indicates that the CAN controller has stored a new 
 1252  6                                      // message into this object, while NEWDAT was still set,
 1253  6                                      // ie. the previously stored message is lost.
 1254  6      
 1255  6                                      // USER CODE BEGIN (SRN0_OBJ0,3)
 1256  6      
 1257  6                                      // USER CODE END
 1258  6      
 1259  6                                }
 1260  5                                else
 1261  5                                {
 1262  6                                      // The CAN controller has stored a new message into this object.
 1263  6      
 1264  6                                        //----- get Identifier ------------------------------------------------
 1265  6                                        if(CAN_HWOBJ[ubMessagePendingIndex0].uwMOARH & 0x2000)    // if extended identifier
 1266  6                                        {
 1267  7                                              //----- get Extended Identifier -------------------------------------
 1268  7                                                MessageId_0 = (((ulong)(CAN_HWOBJ[ubMessagePendingIndex0].uwMOARH & 0x1FFF))<<16) + CAN_HWOBJ[ubMes
             -sagePendingIndex0].uwMOARL;
 1269  7                                        }
 1270  6                                        else                                       // standard identifier
 1271  6                                        {
 1272  7                                              //----- get Standard Identifier -------------------------------------
 1273  7                                                MessageId_0 = (ulong)(CAN_HWOBJ[ubMessagePendingIndex0].uwMOARH & 0x1FFF) >> 2;
 1274  7                                        }
 1275  6      
 1276  6                                        DataPointer_0[0] = CAN_HWOBJ[ubMessagePendingIndex0].ubData[0];
 1277  6                                        DataPointer_0[1] = CAN_HWOBJ[ubMessagePendingIndex0].ubData[1];
 1278  6                                        DataPointer_0[2] = CAN_HWOBJ[ubMessagePendingIndex0].ubData[2];
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 23  

 1279  6                                        DataPointer_0[3] = CAN_HWOBJ[ubMessagePendingIndex0].ubData[3];
 1280  6                                        DataPointer_0[4] = CAN_HWOBJ[ubMessagePendingIndex0].ubData[4];
 1281  6                                        DataPointer_0[5] = CAN_HWOBJ[ubMessagePendingIndex0].ubData[5];
 1282  6                                        DataPointer_0[6] = CAN_HWOBJ[ubMessagePendingIndex0].ubData[6];
 1283  6                                        DataPointer_0[7] = CAN_HWOBJ[ubMessagePendingIndex0].ubData[7];
 1284  6      
 1285  6                                CanIf_RxIndication0(ubMessagePendingIndex0, MessageId_0, ((CAN_HWOBJ[ubMessagePendingIndex0].uwMOFCRH
             - & 0x0F00)>>8), DataPointer_0);
 1286  6      
 1287  6      
 1288  6                                      // USER CODE BEGIN (SRN0_OBJ0,4)
 1289  6      
 1290  6                                      // USER CODE END
 1291  6                                }
 1292  5      
 1293  5                              }
 1294  4      
 1295  4                              CAN_HWOBJ[ubMessagePendingIndex0].uwMOCTRL = MOSTAT_RST_MNR;            // reset MSGLST + NEWDAT + RXPN
             -D
 1296  4      
 1297  4                        }  // End of RXPND0
 1298  3      
 1299  3      
 1300  3                        CAN_MSPND0H = ~(uword) 0x0000; // reset PND bit
 1301  3                        CAN_MSPND0L = ~(uword) (0x0001 << ubMessagePendingIndex0);
 1302  3      
 1303  3                        
 1304  3                }
 1305  2                else if(16 == ubMessagePendingIndex0)
 1306  2                {
 1307  3                        uwSRN0ObjHandler = CAN_HWOBJ[16].uwMOCTRL;
 1308  3      
 1309  3                        if(uwSRN0ObjHandler & MOSTAT_TXPND)                      // if message object 16 transmit interrupt
 1310  3                        {
 1311  4      
 1312  4                              // The transmission of the last message object
 1313  4                              // was successful.
 1314  4      
 1315  4                                CanIf_TxConfirmation(16);
 1316  4      
 1317  4      
 1318  4                                      // USER CODE BEGIN (SRN0_OBJ16,6)
 1319  4      
 1320  4                                      // USER CODE END
 1321  4      
 1322  4      
 1323  4                              CAN_HWOBJ[16].uwMOCTRL = MOSTAT_RST_NT;               // reset NEWDAT + TXPND
 1324  4      
 1325  4                        }  // End of TXPND16
 1326  3      
 1327  3                        CAN_MSPND0H = ~(uword) 0x0001; // reset PND bit
 1328  3                        CAN_MSPND0L = ~(uword) 0x0000;
 1329  3                }
 1330  2                
 1331  2      
 1332  2      
 1333  2        }  // end of while CAN_MSID
 1334  1      
 1335  1      
 1336  1      } //  End of function CAN_viSRN0
 1337         
 1338         
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 24  

 1339         //****************************************************************************
 1340         // @Macro         CAN_viSRN1() 
 1341         //
 1342         //----------------------------------------------------------------------------
 1343         // @Description   
 1344         //
 1345         //----------------------------------------------------------------------------
 1346         // @Returnvalue   
 1347         //
 1348         //----------------------------------------------------------------------------
 1349         // @Parameters    None
 1350         //
 1351         //----------------------------------------------------------------------------
 1352         // @Date          2020/5/11
 1353         //
 1354         //****************************************************************************
 1355         
 1356         // USER CODE BEGIN (SRN1,1)
 1357         
 1358         // USER CODE END
 1359         
 1360         void CAN_viSRN1(void) interrupt CAN_SRN1INT
 1361         {
 1362  1      
 1363  1        uword uwSRN1ObjHandler;
 1364  1        ubyte ubMessagePendingIndex1 = 0u;
 1365  1      
 1366  1        // USER CODE BEGIN (SRN1,2)
 1367  1      
 1368  1        // USER CODE END
 1369  1      
 1370  1        CAN_MSIMASKH = 0x0001;          // set message index mask register
 1371  1        CAN_MSIMASKL = 0xFFFF;
 1372  1      
 1373  1        while (CAN_MSID1 != 0x0020)
 1374  1        {
 1375  2                ubMessagePendingIndex1 = (ubyte)CAN_MSID1;
 1376  2                
 1377  2                if(ubMessagePendingIndex1 <= 15)
 1378  2                {
 1379  3                        uwSRN1ObjHandler = CAN_HWOBJ[ubMessagePendingIndex1 + 32].uwMOCTRL;
 1380  3      
 1381  3                        if(uwSRN1ObjHandler & MOSTAT_RXPND)          // if message object 32 receive interrupt
 1382  3                        {
 1383  4                                      // USER CODE BEGIN (SRN1_OBJ32,1)
 1384  4      
 1385  4                                      // USER CODE END
 1386  4      
 1387  4                              if(uwSRN1ObjHandler & MOSTAT_NEWDAT)       // if NEWDAT is set
 1388  4                              {
 1389  5                                      // USER CODE BEGIN (SRN1_OBJ32,2)
 1390  5      
 1391  5                                      // USER CODE END
 1392  5      
 1393  5                                if (uwSRN1ObjHandler & MOSTAT_MSGLST)    // if MSGLST is set
 1394  5                                {
 1395  6                                      // Indicates that the CAN controller has stored a new 
 1396  6                                      // message into this object, while NEWDAT was still set,
 1397  6                                      // ie. the previously stored message is lost.
 1398  6      
 1399  6                                      // USER CODE BEGIN (SRN1_OBJ32,3)
 1400  6      
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 25  

 1401  6                                      // USER CODE END
 1402  6      
 1403  6                                }
 1404  5                                else
 1405  5                                {
 1406  6                                      // The CAN controller has stored a new message into this object.
 1407  6      
 1408  6                                        //----- get Identifier ------------------------------------------------
 1409  6                                        if(CAN_HWOBJ[ubMessagePendingIndex1 + 32].uwMOARH & 0x2000)    // if extended identifier
 1410  6                                        {
 1411  7                                              //----- get Extended Identifier -------------------------------------
 1412  7                                                MessageId_32 = (((ulong)(CAN_HWOBJ[ubMessagePendingIndex1 + 32].uwMOARH & 0x1FFF))<<16) + CAN_HWOBJ
             -[ubMessagePendingIndex1 + 32].uwMOARL;
 1413  7                                        }
 1414  6                                        else                                       // standard identifier
 1415  6                                        {
 1416  7                                              //----- get Standard Identifier -------------------------------------
 1417  7                                                MessageId_32 = (ulong)(CAN_HWOBJ[ubMessagePendingIndex1 + 32].uwMOARH & 0x1FFF) >> 2;
 1418  7                                        }
 1419  6      
 1420  6                                        DataPointer_32[0] = CAN_HWOBJ[ubMessagePendingIndex1 + 32].ubData[0];
 1421  6                                        DataPointer_32[1] = CAN_HWOBJ[ubMessagePendingIndex1 + 32].ubData[1];
 1422  6                                        DataPointer_32[2] = CAN_HWOBJ[ubMessagePendingIndex1 + 32].ubData[2];
 1423  6                                        DataPointer_32[3] = CAN_HWOBJ[ubMessagePendingIndex1 + 32].ubData[3];
 1424  6                                        DataPointer_32[4] = CAN_HWOBJ[ubMessagePendingIndex1 + 32].ubData[4];
 1425  6                                        DataPointer_32[5] = CAN_HWOBJ[ubMessagePendingIndex1 + 32].ubData[5];
 1426  6                                        DataPointer_32[6] = CAN_HWOBJ[ubMessagePendingIndex1 + 32].ubData[6];
 1427  6                                        DataPointer_32[7] = CAN_HWOBJ[ubMessagePendingIndex1 + 32].ubData[7];
 1428  6      
 1429  6                                CanIf_RxIndication1(ubMessagePendingIndex1 + 32, MessageId_32, ((CAN_HWOBJ[ubMessagePendingIndex1 + 3
             -2].uwMOFCRH & 0x0F00)>>8), DataPointer_32);
 1430  6      
 1431  6      
 1432  6                                      // USER CODE BEGIN (SRN1_OBJ32,4)
 1433  6      
 1434  6                                      // USER CODE END
 1435  6                                }
 1436  5      
 1437  5                              }
 1438  4      
 1439  4                              CAN_HWOBJ[ubMessagePendingIndex1 + 32].uwMOCTRL = MOSTAT_RST_MNR;            // reset MSGLST + NEWDAT +
             - RXPND
 1440  4      
 1441  4                        }  // End of RXPND32
 1442  3      
 1443  3      
 1444  3                        CAN_MSPND1H = ~(uword) 0x0000; // reset PND bit
 1445  3                        CAN_MSPND1L = ~(uword) (0x0001 << ubMessagePendingIndex1);
 1446  3                }
 1447  2                else if(16 == ubMessagePendingIndex1)
 1448  2                {
 1449  3                        uwSRN1ObjHandler = CAN_HWOBJ[48].uwMOCTRL;
 1450  3      
 1451  3                        if(uwSRN1ObjHandler & MOSTAT_TXPND)                      // if message object 48 transmit interrupt
 1452  3                        {
 1453  4      
 1454  4                              // The transmission of the last message object
 1455  4                              // was successful.
 1456  4      
 1457  4                                CanIf_TxConfirmation(48);
 1458  4      
 1459  4      
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 26  

 1460  4                                      // USER CODE BEGIN (SRN1_OBJ48,6)
 1461  4      
 1462  4                                      // USER CODE END
 1463  4      
 1464  4      
 1465  4                              CAN_HWOBJ[48].uwMOCTRL = MOSTAT_RST_NT;               // reset NEWDAT + TXPND
 1466  4      
 1467  4                        }  // End of TXPND48
 1468  3      
 1469  3                        CAN_MSPND1H = ~(uword) 0x0001; // reset PND bit
 1470  3                        CAN_MSPND1L = ~(uword) 0x0000;
 1471  3                }
 1472  2        }  // end of while CAN_MSID
 1473  1      
 1474  1      } //  End of function CAN_viSRN1
 1475         
 1476         
 1477         //****************************************************************************
 1478         // @Macro         CAN_viSRN2() 
 1479         //
 1480         //----------------------------------------------------------------------------
 1481         // @Description   
 1482         //
 1483         //----------------------------------------------------------------------------
 1484         // @Returnvalue   
 1485         //
 1486         //----------------------------------------------------------------------------
 1487         // @Parameters    None
 1488         //
 1489         //----------------------------------------------------------------------------
 1490         // @Date          2020/5/15
 1491         //
 1492         //****************************************************************************
 1493         
 1494         // USER CODE BEGIN (SRN2,1)
 1495         
 1496         // USER CODE END
 1497         
 1498         void CAN_viSRN2(void) interrupt CAN_SRN2INT
 1499         {
 1500  1      
 1501  1        uword uwSRN2NodeHandler;
 1502  1      
 1503  1        // USER CODE BEGIN (SRN2,2)
 1504  1      
 1505  1        // USER CODE END
 1506  1      
 1507  1        //   -----------------------------------------------------------------------
 1508  1        //   Interrupts of CAN node 0
 1509  1        //   -----------------------------------------------------------------------
 1510  1      
 1511  1        uwSRN2NodeHandler = CAN_NSR0;
 1512  1      
 1513  1        if (uwSRN2NodeHandler & 0x0020)               // if ALERT
 1514  1        {
 1515  2            if (uwSRN2NodeHandler & 0x0080)           // if BOFF
 1516  2            {
 1517  3              // Indicates when the CAN controller is in busoff state.
 1518  3      
 1519  3                CanIf_ControllerBusOff(0);
 1520  3      
 1521  3              // USER CODE BEGIN (SRN2_NODE0,1)
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 27  

 1522  3      
 1523  3              // USER CODE END
 1524  3            }
 1525  2      
 1526  2            if (uwSRN2NodeHandler & 0x0040)           // if EWRN
 1527  2            {
 1528  3              // One of the error counters REC or TEC reached the
 1529  3              // warning limit of 96.
 1530  3      
 1531  3              // USER CODE BEGIN (SRN2_NODE0,2)
 1532  3      
 1533  3              // USER CODE END
 1534  3            }
 1535  2      
 1536  2            if (uwSRN2NodeHandler & 0x0100)           // if LLE
 1537  2            {
 1538  3              // A list length error has been detected during message
 1539  3              // acceptance filtering. The number of elements in the list
 1540  3              // that belongs to this CAN node differs from the list SIZE 
 1541  3              // given in the list termination pointer
 1542  3      
 1543  3              CAN_NSR0      = 0x023F;        // reset LLE
 1544  3      
 1545  3              // USER CODE BEGIN (SRN2_NODE0,3)
 1546  3      
 1547  3              // USER CODE END
 1548  3            }
 1549  2      
 1550  2            if (uwSRN2NodeHandler & 0x0200)           // if LOE
 1551  2            {
 1552  3              // A list object error has been detected during message
 1553  3              // acceptance filtering. A message object with wrong LIST 
 1554  3              // index entry in the Message Object Control Register has 
 1555  3              // been detected
 1556  3      
 1557  3              CAN_NSR0      = 0x013F;        // reset LOE
 1558  3      
 1559  3              // USER CODE BEGIN (SRN2_NODE0,4)
 1560  3      
 1561  3              // USER CODE END
 1562  3            }
 1563  2      
 1564  2            if (CAN_NCR0 & 0x0001)           // if INIT
 1565  2            {
 1566  3              // Bit INIT has been set by the MultiCAN
 1567  3      
 1568  3              // USER CODE BEGIN (SRN2_NODE0,5)
 1569  3      
 1570  3              // USER CODE END
 1571  3            }
 1572  2      
 1573  2            CAN_NSR0      = 0x031F;          // reset ALERT
 1574  2      
 1575  2            // USER CODE BEGIN (SRN2_NODE0,6)
 1576  2      
 1577  2            // USER CODE END
 1578  2        }
 1579  1      
 1580  1      
 1581  1      
 1582  1        // USER CODE BEGIN (SRN2,15)
 1583  1      
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 28  

 1584  1        // USER CODE END
 1585  1      
 1586  1      } //  End of function CAN_viSRN2
 1587         
 1588         
 1589         //****************************************************************************
 1590         // @Macro         CAN_viSRN3() 
 1591         //
 1592         //----------------------------------------------------------------------------
 1593         // @Description   
 1594         //
 1595         //----------------------------------------------------------------------------
 1596         // @Returnvalue   
 1597         //
 1598         //----------------------------------------------------------------------------
 1599         // @Parameters    None
 1600         //
 1601         //----------------------------------------------------------------------------
 1602         // @Date          2020/5/15
 1603         //
 1604         //****************************************************************************
 1605         
 1606         // USER CODE BEGIN (SRN3,1)
 1607         
 1608         // USER CODE END
 1609         
 1610         void CAN_viSRN3(void) interrupt CAN_SRN3INT
 1611         {
 1612  1      
 1613  1        uword uwSRN3NodeHandler;
 1614  1      
 1615  1        // USER CODE BEGIN (SRN3,2)
 1616  1      
 1617  1        // USER CODE END
 1618  1      
 1619  1        //   -----------------------------------------------------------------------
 1620  1        //   Interrupts of CAN node 1
 1621  1        //   -----------------------------------------------------------------------
 1622  1      
 1623  1        uwSRN3NodeHandler = CAN_NSR1;
 1624  1      
 1625  1        if (uwSRN3NodeHandler & 0x0020)               // if ALERT
 1626  1        {
 1627  2            if (uwSRN3NodeHandler & 0x0080)           // if BOFF
 1628  2            {
 1629  3              // Indicates when the CAN controller is in busoff state.
 1630  3      
 1631  3                CanIf_ControllerBusOff(1);
 1632  3      
 1633  3              // USER CODE BEGIN (SRN3_NODE1,1)
 1634  3      
 1635  3              // USER CODE END
 1636  3            }
 1637  2      
 1638  2            if (uwSRN3NodeHandler & 0x0040)           // if EWRN
 1639  2            {
 1640  3              // One of the error counters REC or TEC reached the
 1641  3              // warning limit of 96.
 1642  3      
 1643  3              // USER CODE BEGIN (SRN3_NODE1,2)
 1644  3      
 1645  3              // USER CODE END
C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 29  

 1646  3            }
 1647  2      
 1648  2            if (uwSRN3NodeHandler & 0x0100)           // if LLE
 1649  2            {
 1650  3              // A list length error has been detected during message
 1651  3              // acceptance filtering. The number of elements in the list
 1652  3              // that belongs to this CAN node differs from the list SIZE 
 1653  3              // given in the list termination pointer
 1654  3      
 1655  3              CAN_NSR1      = 0x023F;        // reset LLE
 1656  3      
 1657  3              // USER CODE BEGIN (SRN3_NODE1,3)
 1658  3      
 1659  3              // USER CODE END
 1660  3            }
 1661  2      
 1662  2            if (uwSRN3NodeHandler & 0x0200)           // if LOE
 1663  2            {
 1664  3              // A list object error has been detected during message
 1665  3              // acceptance filtering. A message object with wrong LIST 
 1666  3              // index entry in the Message Object Control Register has 
 1667  3              // been detected
 1668  3      
 1669  3              CAN_NSR1      = 0x013F;        // reset LOE
 1670  3      
 1671  3              // USER CODE BEGIN (SRN3_NODE1,4)
 1672  3      
 1673  3              // USER CODE END
 1674  3            }
 1675  2      
 1676  2            if (CAN_NCR1 & 0x0001)           // if INIT
 1677  2            {
 1678  3              // Bit INIT has been set by the MultiCAN
 1679  3      
 1680  3              // USER CODE BEGIN (SRN3_NODE1,5)
 1681  3      
 1682  3              // USER CODE END
 1683  3            }
 1684  2      
 1685  2            CAN_NSR1      = 0x031F;          // reset ALERT
 1686  2      
 1687  2            // USER CODE BEGIN (SRN3_NODE1,6)
 1688  2      
 1689  2            // USER CODE END
 1690  2        }
 1691  1      
 1692  1      
 1693  1      
 1694  1        // USER CODE BEGIN (SRN3,15)
 1695  1      
 1696  1        // USER CODE END
 1697  1      
 1698  1      } //  End of function CAN_viSRN3
 1699         
 1700         
 1701         
 1702         // USER CODE BEGIN (CAN_General,10)
 1703         
 1704         // USER CODE END
 1705         


C166 COMPILER V7.57.0, CAN                                                                 01/20/2021 09:50:37 PAGE 30  

MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        7230     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =           8     --------
  FAR-DATA SIZE    =          16     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =    --------     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
