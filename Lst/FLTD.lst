C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 1   


C166 COMPILER V7.57.0, COMPILATION OF MODULE FLTD
OBJECT MODULE PLACED IN .\Obj\FLTD.obj
COMPILER INVOKED BY: C:\Keil_v5\C166\BIN\C166.EXE src\app\diagnostic\FLTD.c MODV2 LARGE BROWSE INCDIR(.\src;.\src\bsw;.\
                    -src\driver;.\src\interaction;.\src\app\adc;.\src\app\alogrithm;.\src\app\can;.\src\app\ccp;.\src\app\diagnostic;.\src\ap
                    -p\mode control;.\src\app\task;.\src\app\Fun;.\src\app\rtos;.\src\bsw\can;.\src\bsw\desc;.\src\bsw\nm;.\src\app\time meas
                    -ure;.\src\app\rte) MODV2 DEBUG PRINT(.\Lst\FLTD.lst) OBJECT(.\Obj\FLTD.obj) 

 stmt lvl     source

    1         /***********************************************************************
    2         *   Copyright (C) JWD Automotive Co., Ltd.                                             * 
    3         *               All Rights Reserved.                                                           *
    4         *   Department : iCAS SW                                                                               *
    5         *   AUTHOR         :                                                                                               *
    6         ************************************************************************
    7         * Object        : 
    8         * Module        : FLTD.c
    9         * Instance      : 
   10         * Description   :  fault diagnosis
   11         *-----------------------------------------------------------------------
   12         * Version: v0.1
   13         * Date   : Nov 12,2019 
   14         * Author : Zhu jinfeng
   15         ***********************************************************************/
   16         /*-History--------------------------------------------------------------
   17         * Version    Date           Name            Changes and comments
   18         ------------------------------------------------------------------------
   19         * 0.1       Nov 12,2019     Zhu jinfeng     Initial version
   20         *=====================================================================*/
   21         
   22         #define  FLTD_C_
   23         #include "string.h"
   24         #include "MAIN.h"
   25         #include "adc_sample.h"
   26         #include "FLTD.h"
   27         #include "rte.h"
   28         #include "pid.h"
   29         #include "pwm.h"
   30         
   31         /**** Definition of variables ****/
   32         static FLTD_faultFlagType FLTD_fltFlg;
   33         static FLTD_faultActType FLTD_fltActFlg;
   34         #include "FLTD_Cfg.h"
   35         
   36         static FLTD_volModeType adcVoltModeSts[FLTD_ADC_MAX] = {0};
   37         
   38         static FLT_U8 u8BrakeSwStsLast = 0;
   39         static FLT_BOOL bPedalReturnFlag = FALSE; /* brake from valid to invalid, set the pedal return flag */
   40         static FLT_BOOL bPedalPushFlag = FALSE; /* brake from invalid to valid, set the pedal push flag */
   41         static FLT_U16 u16PedalInitLocMinValue = 0xFFFF; /* This variable record the minimum value of pedal return
             - */
   42         static FLT_U16 u16PedalReturnMinValue = 0xFFFF; /* This variable record the minimum value of pedal return 
             -*/
   43         static FLT_U16 u16PedalPushMaxValue = 0; /* This variable records the maximum value of the pedal */
   44         static FLT_U16 u16CylinderReturnMinValue = 0xFFFF; /* This variable record the minimum value of cylinder r
             -eturn */
   45         static FLT_U16 u16CylinderPushMaxValue = 0; /* This variable records the maximum value of the cylinder */
   46         
   47         
   48         /**** Declaration of functions ****/
   49         
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 2   

   50         static void FLTD_AdcMonitor(void);
   51         static void FLTD_PedalDetectCondigtJudge(void);
   52         static void FLTD_PedalSigCheckErrorDetect(void);
   53         static void FLTD_PedalInitLocAbnormalDetect(void);
   54         static void FLTD_PedalReturnAbnormalDetect(void);
   55         static void FLTD_PedalActionAbnormalDetect(void);
   56         static void FLTD_CylinderSigCheckErrorDetect(void);
   57         static void FLTD_CylinderInitLocAbnormalDetect(void);
   58         static void FLTD_CylinderSignalAbnormalDetect(void);
   59         static void FLTD_VlinkVoltageAbnormalDetect(void);
   60         static void FLTD_CurrentInitSigAbnormalDetect(void);
   61         static void FLTD_PredriverFaultDetect(void);
   62         static void FLTD_MotorFaultDetect(void);
   63         
   64         
   65         static void FLTD_FaultActionHandle(void);
   66         static FLT_BOOL FLTD_GetAdcCondition(FLTD_adcType adcIndex);
   67         
   68         
   69         //***************************************************************************************
   70         // @Function      void FLTD_Init(void)
   71         //
   72         //---------------------------------------------------------------------------------------
   73         // @Description   FLTD module initialization function.Perform initialization as needed.
   74         //
   75         //---------------------------------------------------------------------------------------
   76         // @Returnvalue   none 
   77         //
   78         //---------------------------------------------------------------------------------------
   79         // @Parameters    none
   80         //
   81         //---------------------------------------------------------------------------------------
   82         // @Date          2019/11/7
   83         //
   84         //***************************************************************************************
   85         void FLTD_Init(void)
   86         {
   87  1              memset(&adcVoltModeSts, 0, FLTD_ADC_MAX);
   88  1      }
   89         
   90         //***************************************************************************************
   91         // @Function      void FLTD_Runnable(void)
   92         //---------------------------------------------------------------------------------------
   93         // @Description   FLTD module cycle task function. AD sampling value range judgment and 
   94         //                                signal fault processing are performed according to the scheduling cycle.
   95         //---------------------------------------------------------------------------------------
   96         // @Returnvalue   none 
   97         //---------------------------------------------------------------------------------------
   98         // @Parameters    none
   99         //---------------------------------------------------------------------------------------
  100         // @Date          2019/11/7
  101         //***************************************************************************************
  102         void FLTD_Runnable(void)
  103         {
  104  1              FLTD_AdcMonitor();
  105  1              
  106  1              //FLTD_PedalDetectCondigtJudge();
  107  1              //FLTD_PedalSigCheckErrorDetect();
  108  1              //FLTD_PedalInitLocAbnormalDetect();
  109  1              //FLTD_PedalReturnAbnormalDetect();
  110  1              //FLTD_PedalActionAbnormalDetect();
  111  1              FLTD_CylinderSigCheckErrorDetect();
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 3   

  112  1              //FLTD_CylinderInitLocAbnormalDetect();
  113  1              //FLTD_CylinderSignalAbnormalDetect();
  114  1              //FLTD_VlinkVoltageAbnormalDetect();
  115  1              //FLTD_CurrentInitSigAbnormalDetect();
  116  1              //FLTD_PredriverFaultDetect();
  117  1              FLTD_MotorFaultDetect();
  118  1              
  119  1              FLTD_FaultActionHandle();
  120  1      }
  121         
  122         
  123         
  124         //***************************************************************************************
  125         // @Function      static void FLTD_AdcMonitor(void) 
  126         //---------------------------------------------------------------------------------------
  127         // @Description   AD samples values is divided into five, in order to stop, low,  
  128         //                                normal, high, over, etc.
  129         //
  130         //---------- stop_t ----------------- low_t ------  high_t ------------------- over_t ---
  131         //             |         |   lowHyst    |                        |        highHyst       |          |   
  132         //                         |         |                      |                    |                               |                  |
  133         //     stop        |   low      low/normal  |  normal    |       normal/high     high   |       over
  134         //---------------------------------------------------------------------------------------
  135         // @Returnvalue   None
  136         //---------------------------------------------------------------------------------------
  137         // @Parameters    None
  138         //---------------------------------------------------------------------------------------
  139         // @Date          2019/11/7
  140         //***************************************************************************************
  141         static void FLTD_AdcMonitor(void)
  142         {
  143  1              FLTD_adcType adcIndex = 0;
  144  1      
  145  1              static FLTD_volModeType adcVoltModeTemp[FLTD_ADC_MAX] = {0};
  146  1              static FLTD_volModeType adcVoltModeStsLast[FLTD_ADC_MAX] = {0};
  147  1              static FLT_U16 g_u16VoltModeFilterCnt[FLTD_ADC_MAX] = {0};
  148  1              FLTD_AdcMonitorCfgType* ptrAdcMonitorCfg;
  149  1      
  150  1              /* For the configured AD channel, According to the sample AD value, determine which range it belongs to *
             -/
  151  1              for (adcIndex = 0; adcIndex < FLTD_ADC_MAX; adcIndex++)
  152  1              {
  153  2                      /* If the channel detection condition is not satisfied, skip */
  154  2                      if(FALSE == FLTD_GetAdcCondition(adcIndex))
  155  2                      {
  156  3                              continue;
  157  3                      }
  158  2                      
  159  2                      ptrAdcMonitorCfg = (FLTD_AdcMonitorCfgType*) &FLTD_AdcMonitorCfg[adcIndex];
  160  2                      
  161  2                      if ((*ptrAdcMonitorCfg->adcValue >= ptrAdcMonitorCfg->lowThreshold)
  162  2                              && (*ptrAdcMonitorCfg->adcValue <= ptrAdcMonitorCfg->highThreshold))/* low ~ high */
  163  2                      {
  164  3                              adcVoltModeTemp[adcIndex] = FLTD_VOL_NORMAL;
  165  3                      }
  166  2                      else
  167  2                      {
  168  3                              if (*ptrAdcMonitorCfg->adcValue > ptrAdcMonitorCfg->highThreshold) /* high ~  */
  169  3                              {
  170  4                                      if (*ptrAdcMonitorCfg->adcValue < (ptrAdcMonitorCfg->highThreshold + ptrAdcMonitorCfg->highHyst)) /* h
             -igh ~ (high + high_hyst) */
  171  4                                      {
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 4   

  172  5                                              adcVoltModeTemp[adcIndex] = FLTD_VOL_HIGH_HYST;
  173  5                                      }
  174  4                                      else if (*ptrAdcMonitorCfg->adcValue <= ptrAdcMonitorCfg->overThreshold) /* (high + highHyst) ~ over *
             -/
  175  4                                      {
  176  5                                              adcVoltModeTemp[adcIndex] = FLTD_VOL_HIGH;
  177  5                                      }
  178  4                                      else                                                                                                                                    /* over ~  */
  179  4                                      {
  180  5                                              adcVoltModeTemp[adcIndex] = FLTD_VOL_OVER;
  181  5                                      }
  182  4                              }
  183  3                              else                                                                                                                            /*  ~ low */
  184  3                              {
  185  4                                      if (*ptrAdcMonitorCfg->adcValue > (ptrAdcMonitorCfg->lowThreshold - ptrAdcMonitorCfg->lowHyst)) /* (lo
             -w - low_hyst) ~ low */
  186  4                                      {
  187  5                                              adcVoltModeTemp[adcIndex] = FLTD_VOL_LOW_HYST;
  188  5                                      }
  189  4                                      else if (*ptrAdcMonitorCfg->adcValue >= ptrAdcMonitorCfg->stopThreshold) /* stop ~ (low - lowHyst)*/
  190  4                                      {
  191  5                                              adcVoltModeTemp[adcIndex] = FLTD_VOL_LOW;
  192  5                                      }
  193  4                                      else                                                                                                                                    /*  ~ stop */
  194  4                                      {
  195  5                                              adcVoltModeTemp[adcIndex] = FLTD_VOL_STOP;
  196  5                                      }
  197  4                              }
  198  3                      }
  199  2      
  200  2                      /* According to the judgment of the above process, filter the judgment result */
  201  2                      if (adcVoltModeTemp[adcIndex] != adcVoltModeSts[adcIndex])
  202  2                      {
  203  3                              if (g_u16VoltModeFilterCnt[adcIndex] < ptrAdcMonitorCfg->filterTime)
  204  3                              {
  205  4                                      g_u16VoltModeFilterCnt[adcIndex]++;
  206  4                              }
  207  3                              else
  208  3                              {
  209  4                                      adcVoltModeSts[adcIndex] = adcVoltModeTemp[adcIndex];
  210  4                                      g_u16VoltModeFilterCnt[adcIndex] = 0;
  211  4                              }
  212  3                      }
  213  2                      else
  214  2                      {
  215  3                              g_u16VoltModeFilterCnt[adcIndex] = 0;
  216  3                      }
  217  2      
  218  2                      /* In both cases in the low or high hysteretic interval, 
  219  2                      *  the result is normal if the entry is from the normal range;
  220  2                      *  If the entry is from the corresponding low or high state, 
  221  2                      *  the low or high state is maintained 
  222  2                      */
  223  2                      if (FLTD_VOL_LOW_HYST == adcVoltModeSts[adcIndex])
  224  2                      {
  225  3                              if ((FLTD_VOL_LOW == adcVoltModeStsLast[adcIndex])
  226  3                                      || (FLTD_VOL_STOP == adcVoltModeStsLast[adcIndex]))
  227  3                              {
  228  4                                      adcVoltModeSts[adcIndex] = FLTD_VOL_LOW;
  229  4                              }
  230  3                              else
  231  3                              {
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 5   

  232  4                                      adcVoltModeSts[adcIndex] = FLTD_VOL_NORMAL;
  233  4                              }
  234  3                      }
  235  2                      else if (FLTD_VOL_HIGH_HYST == adcVoltModeSts[adcIndex])
  236  2                      {
  237  3                              if ((FLTD_VOL_HIGH == adcVoltModeStsLast[adcIndex])
  238  3                                      || (FLTD_VOL_OVER == adcVoltModeStsLast[adcIndex]))
  239  3                              {
  240  4                                      adcVoltModeSts[adcIndex] = FLTD_VOL_HIGH;
  241  4                              }
  242  3                              else
  243  3                              {
  244  4                                      adcVoltModeSts[adcIndex] = FLTD_VOL_NORMAL;
  245  4                              }
  246  3                      }
  247  2                      else
  248  2                      {
  249  3      
  250  3                      }
  251  2      
  252  2                      //set and clear fault flag
  253  2                      if(FLTD_VOL_NORMAL == adcVoltModeSts[adcIndex])
  254  2                      {
  255  3                              *ptrAdcMonitorCfg->faultFlag[0] = FALSE;
  256  3                              *ptrAdcMonitorCfg->faultFlag[1] = FALSE;
  257  3                              *ptrAdcMonitorCfg->faultFlag[2] = FALSE;
  258  3                              *ptrAdcMonitorCfg->faultFlag[3] = FALSE;
  259  3                      }
  260  2                      else
  261  2                      {
  262  3                              *ptrAdcMonitorCfg->faultFlag[0] = FALSE;
  263  3                              *ptrAdcMonitorCfg->faultFlag[1] = FALSE;
  264  3                              *ptrAdcMonitorCfg->faultFlag[2] = FALSE;
  265  3                              *ptrAdcMonitorCfg->faultFlag[3] = FALSE;
  266  3      
  267  3                              *ptrAdcMonitorCfg->faultFlag[adcVoltModeSts[adcIndex] - 1] = TRUE;
  268  3                      }
  269  2      
  270  2                      adcVoltModeStsLast[adcIndex] = adcVoltModeSts[adcIndex];
  271  2              }
  272  1      }
  273         
  274         
  275         //***************************************************************************************
  276         // @Function      FLTD_volModeType FLTD_GetAdcRangeType(FLTD_adcType adctype) 
  277         //---------------------------------------------------------------------------------------
  278         // @Description   Get the range of AD sampling value of each channel.
  279         //---------------------------------------------------------------------------------------
  280         // @Returnvalue   adcVoltModeSts: 
  281         //                                The range of AD values for a particular channel, In the following
  282         //                                FLTD_VOL_NORMAL,FLTD_VOL_STOP,FLTD_VOL_LOW,FLTD_VOL_HIGH.
  283         //---------------------------------------------------------------------------------------
  284         // @Parameters    adctype:
  285         //                                Enumeration of each AD channel.
  286         //---------------------------------------------------------------------------------------
  287         // @Date          2019/11/7
  288         //***************************************************************************************
  289         FLTD_volModeType FLTD_GetAdcRangeType(FLTD_adcType adcType)
  290         {
  291  1              return adcVoltModeSts[adcType];
  292  1      }
  293         
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 6   

  294         
  295         //***************************************************************************************
  296         // @Function      static void FLTD_PedalDetectCondigtJudge(void) 
  297         //---------------------------------------------------------------------------------------
  298         // @Description   Pedal signal abnormal detection needs to be combined with pedal switch signal.
  299         //---------------------------------------------------------------------------------------
  300         // @Returnvalue   None
  301         //---------------------------------------------------------------------------------------
  302         // @Parameters    None
  303         //---------------------------------------------------------------------------------------
  304         // @Date          2019/12/27
  305         //***************************************************************************************
  306         static void FLTD_PedalDetectCondigtJudge(void)
  307         {
  308  1              if((FALSE == g_inBrakeSwValidSts) && (TRUE == u8BrakeSwStsLast))/* brake from valid to invalid, set the p
             -edal return flag */
  309  1              {
  310  2                      bPedalReturnFlag = TRUE;
  311  2                      bPedalPushFlag = FALSE;
  312  2      
  313  2                      u16PedalReturnMinValue = 0xFFFF;
  314  2                      u16PedalInitLocMinValue = 0xFFFF;
  315  2              }
  316  1              else if((TRUE == g_inBrakeSwValidSts) && (FALSE == u8BrakeSwStsLast))/* brake from invalid to valid, set 
             -the pedal push flag */
  317  1              {
  318  2                      bPedalReturnFlag = FALSE;
  319  2                      bPedalPushFlag = TRUE;
  320  2      
  321  2                      u16PedalPushMaxValue = 0;
  322  2              }
  323  1              
  324  1              u8BrakeSwStsLast = g_inBrakeSwValidSts;
  325  1      }
  326         
  327         //***************************************************************************************
  328         // @Function      static void FLTD_PedalSigCheckErrorDetect(void) 
  329         //---------------------------------------------------------------------------------------
  330         // @Description   Pedal two - way signal calibration error detection.
  331         //---------------------------------------------------------------------------------------
  332         // @Returnvalue   None
  333         //---------------------------------------------------------------------------------------
  334         // @Parameters    None
  335         //---------------------------------------------------------------------------------------
  336         // @Date          2019/12/27
  337         //***************************************************************************************
  338         static void FLTD_PedalSigCheckErrorDetect(void)
  339         {
  340  1              const T_ADC *adcPtr = Adc_SampleData();
  341  1              static FLT_U16 u16PedalSignalCheckErrorCnt = 0;
  342  1              static FLT_U16 u16PedalSignalCheckNormalCnt = 0;
  343  1              
  344  1              FLT_U32 u32PedalCheckErrorUpper = 0;
  345  1              FLT_U32 u32PedalCheckErrorLower = 0;
  346  1      
  347  1              /* If the pedal sensor power supply voltage is normal and the signal is not open, 
  348  1               * judge the calibration of two channel signals */
  349  1      
  350  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_VOLTAGE])
  351  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_SIG1]) 
  352  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_SIG2]))
  353  1              {
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 7   

  354  2                      /* pedal sensor signal Check failure 
  355  2                      if((adcPtr->brakePedalTrip_Adc[0] > (2 * (1 + PEDAL_SIGNAL_CHECK_RANG) * adcPtr->brakePedalTrip_Adc[1]))
  356  2                              || (adcPtr->brakePedalTrip_Adc[0] < (2 * (1 - PEDAL_SIGNAL_CHECK_RANG) * adcPtr->brakePedalTrip_Adc[1])
             -))
  357  2                      {
  358  2                              u16PedalSignalCheckNormalCnt = 0;
  359  2                              if(u16PedalSignalCheckErrorCnt < PEDAL_SIGNAL_CHECK_FAILURE_TIME)
  360  2                              {
  361  2                                      u16PedalSignalCheckErrorCnt++;
  362  2                              }
  363  2                              else
  364  2                              {
  365  2                                      FLTD_fltFlg.pedalSensorCheckErrorFlg = TRUE;
  366  2                              }
  367  2                      }
  368  2                      */
  369  2                      
  370  2                      u32PedalCheckErrorUpper = (((100 + PEDAL_SIGNAL_CHECK_RANG) * (INT32U)adcPtr->brakePedalTrip_Adc[1]) + 2
             -5) / 50;
  371  2                      u32PedalCheckErrorLower = (((100 - PEDAL_SIGNAL_CHECK_RANG) * (INT32U)adcPtr->brakePedalTrip_Adc[1]) + 2
             -5) / 50;
  372  2                      
  373  2                      if((adcPtr->brakePedalTrip_Adc[0] > u32PedalCheckErrorUpper)
  374  2                              || (adcPtr->brakePedalTrip_Adc[0] < u32PedalCheckErrorLower))
  375  2                      {
  376  3                              u16PedalSignalCheckNormalCnt = 0;
  377  3                              if(u16PedalSignalCheckErrorCnt < PEDAL_SIGNAL_CHECK_FAILURE_TIME)
  378  3                              {
  379  4                                      u16PedalSignalCheckErrorCnt++;
  380  4                              }
  381  3                              else
  382  3                              {
  383  4                                      FLTD_fltFlg.pedalSensorCheckErrorFlg = TRUE;
  384  4                              }
  385  3                      }
  386  2                      else
  387  2                      {
  388  3                              u16PedalSignalCheckErrorCnt = 0;
  389  3                              if(u16PedalSignalCheckNormalCnt < PEDAL_SIGNAL_CHECK_FAILURE_TIME)
  390  3                              {
  391  4                                      u16PedalSignalCheckNormalCnt++;
  392  4                              }
  393  3                              else
  394  3                              {
  395  4                                      FLTD_fltFlg.pedalSensorCheckErrorFlg = FALSE;
  396  4                              }
  397  3                      }       
  398  2              }
  399  1              else
  400  1              {
  401  2                      u16PedalSignalCheckErrorCnt = 0;
  402  2                      u16PedalSignalCheckNormalCnt = 0;
  403  2              }
  404  1      }
  405         
  406         
  407         //***************************************************************************************
  408         // @Function      static void FLTD_PedalInitLocAbnormalDetect(void) 
  409         //---------------------------------------------------------------------------------------
  410         // @Description   Pedal init location abnormal detection.
  411         //---------------------------------------------------------------------------------------
  412         // @Returnvalue   None
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 8   

  413         //---------------------------------------------------------------------------------------
  414         // @Parameters    None
  415         //---------------------------------------------------------------------------------------
  416         // @Date          2019/12/27
  417         //***************************************************************************************
  418         static void FLTD_PedalInitLocAbnormalDetect(void)
  419         { 
  420  1              const T_ADC *adcPtr = Adc_SampleData();
  421  1              static FLT_U16 u16PedalInitLocDetectDelayCnt = 0;
  422  1              static FLT_U16 u16PedalInitLocAbnormalCnt = 0;
  423  1              static FLT_U16 u16PedalInitLocNormalCnt = 0;
  424  1              
  425  1              /* The brake pedal is not pressed,
  426  1               * 1) If the sample value after delay and the rated initial value are greater than a certain value, 
  427  1               * it is judged as the initial signal abnormal; */
  428  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_VOLTAGE])
  429  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_SIG1])
  430  1                      && (10 == SensorInitFlag)
  431  1                      && (FALSE == g_inBrakeSwValidSts))
  432  1              {
  433  2                      /* Delay for a certain time.  */
  434  2                      if(u16PedalInitLocDetectDelayCnt < PEDAL_DETECT_DELAY_TIME)
  435  2                      {
  436  3                              u16PedalInitLocDetectDelayCnt++;
  437  3                              if(adcPtr->brakePedalTrip_Adc[0] < u16PedalInitLocMinValue)
  438  3                              {
  439  4                                      u16PedalInitLocMinValue = adcPtr->brakePedalTrip_Adc[0];
  440  4                              }
  441  3                      }
  442  2                      else
  443  2                      {
  444  3                              /* detect pedal init location abnormal */
  445  3                              if(ABSOLUTE(adcPtr->brakePedalTrip_Adc[0], PadalInitAD0_Init_EEPM) > PEDAL_INIT_LOCATION_ABNORMAL_RANG)
  446  3                              {
  447  4                                      u16PedalInitLocNormalCnt = 0;
  448  4      
  449  4                                      if(u16PedalInitLocAbnormalCnt < PEDAL_INIT_LOCATION_ABNORMAL_TIME)
  450  4                                      {
  451  5                                              u16PedalInitLocAbnormalCnt++;
  452  5                                      }
  453  4                                      else
  454  4                                      {
  455  5                                              FLTD_fltFlg.pedalSensorInitAbnormalFlg = TRUE;
  456  5                                      }
  457  4                              }
  458  3                              else
  459  3                              {
  460  4                                      u16PedalInitLocAbnormalCnt = 0;
  461  4      
  462  4                                      if(u16PedalInitLocNormalCnt < PEDAL_INIT_LOCATION_ABNORMAL_TIME)
  463  4                                      {
  464  5                                              u16PedalInitLocNormalCnt++;
  465  5                                      }
  466  4                                      else
  467  4                                      {
  468  5                                              FLTD_fltFlg.pedalSensorInitAbnormalFlg = FALSE;
  469  5                                      }
  470  4                              }
  471  3                      }       
  472  2              }
  473  1              else
  474  1              {
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 9   

  475  2                      u16PedalInitLocDetectDelayCnt = 0;
  476  2                      u16PedalInitLocAbnormalCnt = 0;
  477  2                      u16PedalInitLocNormalCnt = 0;
  478  2              }
  479  1      }
  480         
  481         
  482         //***************************************************************************************
  483         // @Function      static void FLTD_PedalReturnAbnormalDetect(void) 
  484         //---------------------------------------------------------------------------------------
  485         // @Description   Pedal return to the init location abnormal detection.
  486         //---------------------------------------------------------------------------------------
  487         // @Returnvalue   None
  488         //---------------------------------------------------------------------------------------
  489         // @Parameters    None
  490         //---------------------------------------------------------------------------------------
  491         // @Date          2019/12/27
  492         //***************************************************************************************
  493         static void FLTD_PedalReturnAbnormalDetect(void)
  494         {
  495  1              const T_ADC *adcPtr = Adc_SampleData();
  496  1              static FLT_U16 u16PedalReturnDetectDelayCnt = 0;
  497  1              static FLT_U16 u16PedalReturnAbnormalCnt = 0;
  498  1              static FLT_U16 u16PedalReturnNormalCnt = 0;
  499  1              
  500  1              /* After the pedal switch signal from valid to invalid, that is after the back. 
  501  1               * 1) If the difference between the minimum value and the initial value is greater than a certain value, 
  502  1               * it is judged as return anomaly; */
  503  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_VOLTAGE])
  504  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_SIG1])
  505  1                      && (10 == SensorInitFlag)
  506  1                      && (TRUE == bPedalReturnFlag))
  507  1              {
  508  2                      /* Delay for a certain time and record the minimum value of the signal.  */
  509  2                      if(u16PedalReturnDetectDelayCnt < PEDAL_DETECT_DELAY_TIME)
  510  2                      {
  511  3                              u16PedalReturnDetectDelayCnt++;
  512  3                              if(adcPtr->brakePedalTrip_Adc[0] < u16PedalReturnMinValue)
  513  3                              {
  514  4                                      u16PedalReturnMinValue = adcPtr->brakePedalTrip_Adc[0];
  515  4                              }
  516  3                      }
  517  2                      else
  518  2                      {
  519  3                              /* detect pedal return abnormal */
  520  3                              if(ABSOLUTE(u16PedalReturnMinValue, PadalInitAD0_Init_EEPM) > PEDAL_RETURN_ABNORMAL_RANG)
  521  3                              {
  522  4                                      u16PedalReturnNormalCnt = 0;
  523  4                                      if(u16PedalReturnAbnormalCnt < PEDAL_RETURN_ABNORMAL_TIME)
  524  4                                      {
  525  5                                              u16PedalReturnAbnormalCnt++;
  526  5                                      }
  527  4                                      else
  528  4                                      {
  529  5                                              FLTD_fltFlg.pedalSensorReturnAbnormalFlg = TRUE;
  530  5                                      }
  531  4                              }
  532  3                              else
  533  3                              {
  534  4                                      u16PedalReturnAbnormalCnt = 0;
  535  4                                      if(u16PedalReturnNormalCnt < PEDAL_RETURN_ABNORMAL_TIME)
  536  4                                      {
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 10  

  537  5                                              u16PedalReturnNormalCnt++;
  538  5                                      }
  539  4                                      else
  540  4                                      {
  541  5                                              FLTD_fltFlg.pedalSensorReturnAbnormalFlg = FALSE;
  542  5                                      }
  543  4                              }
  544  3                      }
  545  2              }
  546  1              else
  547  1              {
  548  2                      u16PedalReturnDetectDelayCnt = 0;
  549  2                      u16PedalReturnAbnormalCnt = 0;
  550  2                      u16PedalReturnNormalCnt = 0;
  551  2              }
  552  1      }
  553         
  554         
  555         //***************************************************************************************
  556         // @Function      static void FLTD_PedalActionAbnormalDetect(void) 
  557         //---------------------------------------------------------------------------------------
  558         // @Description   Pedal action abnormal detection. According to the pedal down, 
  559         //                                      whether there is a significant change in the sample value
  560         //---------------------------------------------------------------------------------------
  561         // @Returnvalue   None
  562         //---------------------------------------------------------------------------------------
  563         // @Parameters    None
  564         //---------------------------------------------------------------------------------------
  565         // @Date          2019/12/27
  566         //***************************************************************************************
  567         static void FLTD_PedalActionAbnormalDetect(void)
  568         {
  569  1              const T_ADC *adcPtr = Adc_SampleData();
  570  1              static FLT_U16 u16PedalActionDetectDelayCnt = 0;
  571  1              static FLT_U16 u16PedalSignalNormalCnt = 0;
  572  1              static FLT_U16 u16PedalSignalAbnormalCnt = 0;
  573  1              
  574  1              /* Pedal switch signal from effective to invalid, judging the pedal is down. 
  575  1               * If the difference between the maximum value and the initial value is less than a certain value, 
  576  1               * it is judged as signal abnormal */
  577  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_VOLTAGE])
  578  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_SIG1])
  579  1                      && (10 == SensorInitFlag)
  580  1                      && (TRUE == bPedalPushFlag))
  581  1              {
  582  2                      /* Delay for a certain time and record the maximum value of the signal.  */
  583  2                      if(u16PedalActionDetectDelayCnt < PEDAL_DETECT_DELAY_TIME)
  584  2                      {
  585  3                              u16PedalActionDetectDelayCnt++;
  586  3                              if(adcPtr->brakePedalTrip_Adc[0] > u16PedalPushMaxValue)
  587  3                              {
  588  4                                      u16PedalPushMaxValue = adcPtr->brakePedalTrip_Adc[0];
  589  4                              }
  590  3                      }
  591  2                      else
  592  2                      {
  593  3                              /* detect pedal signal abnormal */
  594  3                              if(ABSOLUTE(u16PedalPushMaxValue, PadalInitAD0_Init_EEPM) < PEDAL_SIGNAL_ABNORMAL_RANG)
  595  3                              {
  596  4                                      u16PedalSignalNormalCnt = 0;
  597  4                                      if(u16PedalSignalAbnormalCnt < PEDAL_SIGNAL_ABNORMAL_TIME)
  598  4                                      {
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 11  

  599  5                                              u16PedalSignalAbnormalCnt++;
  600  5                                      }
  601  4                                      else
  602  4                                      {
  603  5                                              FLTD_fltFlg.pedalSensorSignalAbnormalFlg = TRUE;
  604  5                                      }
  605  4                              }
  606  3                              else
  607  3                              {
  608  4                                      u16PedalSignalAbnormalCnt = 0;
  609  4                                      if(u16PedalSignalNormalCnt < PEDAL_SIGNAL_ABNORMAL_TIME)
  610  4                                      {
  611  5                                              u16PedalSignalNormalCnt++;
  612  5                                      }
  613  4                                      else
  614  4                                      {
  615  5                                              FLTD_fltFlg.pedalSensorSignalAbnormalFlg = FALSE;
  616  5                                      }
  617  4                              }
  618  3                      }
  619  2              }
  620  1              else
  621  1              {
  622  2                      u16PedalActionDetectDelayCnt = 0;
  623  2                      u16PedalSignalNormalCnt = 0;
  624  2                      u16PedalSignalAbnormalCnt = 0;  
  625  2              }
  626  1      }
  627                 
  628         
  629         //***************************************************************************************
  630         // @Function      static void FLTD_CylinderSigCheckErrorDetect(void) 
  631         //---------------------------------------------------------------------------------------
  632         // @Description   Master cylinder two - way signal calibration error detection.
  633         //---------------------------------------------------------------------------------------
  634         // @Returnvalue   None
  635         //---------------------------------------------------------------------------------------
  636         // @Parameters    None
  637         //---------------------------------------------------------------------------------------
  638         // @Date          2019/12/27
  639         //***************************************************************************************
  640         static void FLTD_CylinderSigCheckErrorDetect(void)
  641         {
  642  1              const T_ADC *adcPtr = Adc_SampleData();
  643  1              static FLT_U16 u16CylinderSignalCheckErrorCnt = 0;
  644  1              static FLT_U16 u16CylinderSignalCheckNormalCnt = 0;
  645  1      
  646  1              FLT_U32 u32CylinderCheckErrorUpper = 0;
  647  1              FLT_U32 u32CylinderCheckErrorLower = 0;
  648  1              
  649  1              /* If the cylinder sensor power supply voltage is normal and the signal is not open, 
  650  1               * judge the calibration of two channel signals */
  651  1      
  652  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_VOLTAGE])
  653  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_SIG1]) 
  654  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_SIG2]))
  655  1              {
  656  2                      /* main cylinder sensor signal Check failure 
  657  2                      if((adcPtr->mainCylinderTrip_Adc[0] > (2 * (1 + CYLINDER_SIGNAL_CHECK_RANG) * adcPtr->mainCylinderTrip_A
             -dc[1]))
  658  2                              || (adcPtr->mainCylinderTrip_Adc[0] < (2 * (1 - CYLINDER_SIGNAL_CHECK_RANG) * adcPtr->mainCylinderTrip_
             -Adc[1])))
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 12  

  659  2                      {
  660  2                              u16CylinderSignalCheckNormalCnt = 0;
  661  2                              if(u16CylinderSignalCheckErrorCnt < CYLINDER_SIGNAL_CHECK_FAILURE_TIME)
  662  2                              {
  663  2                                      u16CylinderSignalCheckErrorCnt++;
  664  2                              }
  665  2                              else
  666  2                              {
  667  2                                      FLTD_fltFlg.cylinderSensorCheckErrorFlg = TRUE;
  668  2                              }
  669  2                      }
  670  2                      */
  671  2                      
  672  2                      u32CylinderCheckErrorUpper = (((100 + CYLINDER_SIGNAL_CHECK_RANG) * (INT32U)adcPtr->mainCylinderTrip_Adc
             -[1]) + 25) / 50;
  673  2                      u32CylinderCheckErrorLower = (((100 - CYLINDER_SIGNAL_CHECK_RANG) * (INT32U)adcPtr->mainCylinderTrip_Adc
             -[1]) + 25) / 50;
  674  2                      
  675  2                      
  676  2                      if((adcPtr->mainCylinderTrip_Adc[0] > u32CylinderCheckErrorUpper)
  677  2                              || (adcPtr->mainCylinderTrip_Adc[0] < u32CylinderCheckErrorLower))
  678  2                      {
  679  3                              u16CylinderSignalCheckNormalCnt = 0;
  680  3                              if(u16CylinderSignalCheckErrorCnt < CYLINDER_SIGNAL_CHECK_FAILURE_TIME)
  681  3                              {
  682  4                                      u16CylinderSignalCheckErrorCnt++;
  683  4                              }
  684  3                              else
  685  3                              {
  686  4                                      FLTD_fltFlg.cylinderSensorCheckErrorFlg = TRUE;
  687  4                              }
  688  3                      }
  689  2                      else
  690  2                      {
  691  3                              u16CylinderSignalCheckErrorCnt = 0;
  692  3                              if(u16CylinderSignalCheckNormalCnt < CYLINDER_SIGNAL_CHECK_FAILURE_TIME)
  693  3                              {
  694  4                                      u16CylinderSignalCheckNormalCnt++;
  695  4                              }
  696  3                              else
  697  3                              {
  698  4                                      FLTD_fltFlg.cylinderSensorCheckErrorFlg = FALSE;
  699  4                              }
  700  3                      }
  701  2              }
  702  1              else
  703  1              {
  704  2                      u16CylinderSignalCheckErrorCnt = 0;
  705  2                      u16CylinderSignalCheckNormalCnt = 0;
  706  2              }
  707  1      }
  708         
  709         //***************************************************************************************
  710         // @Function      static void FLTD_CylinderInitLocAbnormalDetect(void) 
  711         //---------------------------------------------------------------------------------------
  712         // @Description   Cylinder init location abnormal detection.
  713         //---------------------------------------------------------------------------------------
  714         // @Returnvalue   None
  715         //---------------------------------------------------------------------------------------
  716         // @Parameters    None
  717         //---------------------------------------------------------------------------------------
  718         // @Date          2019/12/27
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 13  

  719         //***************************************************************************************
  720         static void FLTD_CylinderInitLocAbnormalDetect(void)
  721         {
  722  1              const T_ADC *adcPtr = Adc_SampleData();
  723  1              
  724  1              static FLT_U16 u16CylinderInitSignalDetectDelayTimeCnt = 0;
  725  1              //variables defined to detect cylinder init location abnormal
  726  1              static FLT_U16 u16CylinderInitLocAbnormalCnt = 0;
  727  1              static FLT_U16 u16CylinderInitLocNormalCnt = 0;
  728  1              
  729  1              /* detect cylinder init signal abnormal.
  730  1               * The brake pedal is not pressed and there is no external brake request, 
  731  1               * if the difference between the cylinder signal and the initial signal is greater than a certain value, 
  732  1               * Judge as abnormal; Otherwise it is normal */
  733  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_VOLTAGE])
  734  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_SIG1])
  735  1                      && (10 == SensorInitFlag)
  736  1                  && (0 == g_ObjPressure)
  737  1                  && (0 == g_exhaustObjPressure)
  738  1                      && (FinalTestDeskMode != BrakeSysMode))
  739  1              {       
  740  2                      /* Delay for a certain time, waiting for motor action */
  741  2                      if(u16CylinderInitSignalDetectDelayTimeCnt < CYLINDER_DETECT_DELAY_TIME)
  742  2                      {
  743  3                              u16CylinderInitSignalDetectDelayTimeCnt++;
  744  3                              if(adcPtr->mainCylinderTrip_Adc[0] < u16CylinderReturnMinValue)
  745  3                              {
  746  4                                      u16CylinderReturnMinValue = adcPtr->mainCylinderTrip_Adc[0];
  747  4                              }
  748  3                      }
  749  2                      else
  750  2                      {
  751  3                              if(ABSOLUTE(adcPtr->mainCylinderTrip_Adc[0], CylinderInitAD0_Init_EEPM) > CYLINDER_INIT_LOCATION_ABNORM
             -AL_RANG)
  752  3                              {
  753  4                                      u16CylinderInitLocNormalCnt = 0;
  754  4                                      if(u16CylinderInitLocAbnormalCnt < CYLINDER_INIT_LOCATION_ABNORMAL_TIME)
  755  4                                      {
  756  5                                              u16CylinderInitLocAbnormalCnt++;
  757  5                                      }
  758  4                                      else
  759  4                                      {
  760  5                                              FLTD_fltFlg.cylinderSensorInitAbnormalFlg = TRUE;
  761  5                                      }
  762  4                              }
  763  3                              else
  764  3                              {
  765  4                                      u16CylinderInitLocAbnormalCnt = 0;
  766  4                                      if(u16CylinderInitLocNormalCnt < CYLINDER_INIT_LOCATION_ABNORMAL_TIME)
  767  4                                      {
  768  5                                              u16CylinderInitLocNormalCnt++;
  769  5                                      }
  770  4                                      else
  771  4                                      {
  772  5                                              FLTD_fltFlg.cylinderSensorInitAbnormalFlg = FALSE;
  773  5                                      }
  774  4                              }
  775  3                      }
  776  2              }
  777  1              else
  778  1              {
  779  2                      u16CylinderInitLocAbnormalCnt = 0;
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 14  

  780  2                      u16CylinderInitLocNormalCnt = 0;
  781  2                      u16CylinderInitSignalDetectDelayTimeCnt = 0;
  782  2                      u16CylinderReturnMinValue = 0xFFFF;
  783  2              }
  784  1      }
  785         
  786         //***************************************************************************************
  787         // @Function      static void FLTD_CylinderSignalAbnormalDetect(void) 
  788         //---------------------------------------------------------------------------------------
  789         // @Description   Cylinder signal abnormal detection.
  790         //---------------------------------------------------------------------------------------
  791         // @Returnvalue   None
  792         //---------------------------------------------------------------------------------------
  793         // @Parameters    None
  794         //---------------------------------------------------------------------------------------
  795         // @Date          2019/12/27
  796         //***************************************************************************************
  797         static void FLTD_CylinderSignalAbnormalDetect(void)
  798         {
  799  1              const T_ADC *adcPtr = Adc_SampleData();
  800  1              const T_PWM* ptr_Pwm = Pwm_ControlData();
  801  1              static FLT_U16 u16CylinderSignalDetectDelayTimeCnt = 0;
  802  1      
  803  1              //variables defined to detect cylinder signal abnormal
  804  1              static FLT_U16 u16CylinderSignalAbnormalCnt = 0;
  805  1              static FLT_U16 u16CylinderSignalNormalCnt = 0;  
  806  1      
  807  1              
  808  1              /* detect cylinder signal abnormal.
  809  1               * When A certain control quantity is reached, that is, the duty cycle difference of A and B phase reache
             -s A certain value,
  810  1               * The deviation between the master cylinder position and the initial position is less than a certain val
             -ue,
  811  1               * judge the signal anomaly of the master cylinder*/
  812  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_VOLTAGE])
  813  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_SIG1])
  814  1                      && (FALSE == FLTD_fltFlg.motorOpenFlg)
  815  1                      && (10 == SensorInitFlag)
  816  1                      && (ptr_Pwm->motorCtrl > PWM_AMPLITUDE_DEFAULT)
  817  1                      && ((ptr_Pwm->motorCtrl - PWM_AMPLITUDE_DEFAULT) > CYLINDER_SIGNAL_ABNORMAL_CTRL_THRESHOLD))
  818  1              {
  819  2                      /* Delay for a certain time, waiting for motor action */
  820  2                      if(u16CylinderSignalDetectDelayTimeCnt < CYLINDER_DETECT_DELAY_TIME)
  821  2                      {
  822  3                              u16CylinderSignalDetectDelayTimeCnt++;
  823  3                              if(adcPtr->mainCylinderTrip_Adc[0] > u16CylinderPushMaxValue)
  824  3                              {
  825  4                                      u16CylinderPushMaxValue = adcPtr->mainCylinderTrip_Adc[0];
  826  4                              }
  827  3                      }
  828  2                      else
  829  2                      {
  830  3                              if(ABSOLUTE(u16CylinderPushMaxValue, CylinderInitAD0_Init_EEPM) < CYLINDER_SIGNAL_ABNORMAL_RANG)
  831  3                              {
  832  4                                      u16CylinderSignalNormalCnt = 0;
  833  4                                      if(u16CylinderSignalAbnormalCnt < CYLINDER_SIGNAL_ABNORMAL_TIME)
  834  4                                      {
  835  5                                              u16CylinderSignalAbnormalCnt++;
  836  5                                      }
  837  4                                      else
  838  4                                      {
  839  5                                              FLTD_fltFlg.cylinderSensorSignalAbnormalFlg = TRUE;
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 15  

  840  5                                      }
  841  4                              }
  842  3                              else
  843  3                              {
  844  4                                      u16CylinderSignalAbnormalCnt = 0;
  845  4                                      if(u16CylinderSignalNormalCnt < CYLINDER_SIGNAL_ABNORMAL_TIME)
  846  4                                      {
  847  5                                              u16CylinderSignalNormalCnt++;
  848  5                                      }
  849  4                                      else
  850  4                                      {
  851  5                                              FLTD_fltFlg.cylinderSensorSignalAbnormalFlg = FALSE;
  852  5                                      }
  853  4                              }
  854  3                      }
  855  2              }
  856  1              else
  857  1              {
  858  2                      u16CylinderSignalAbnormalCnt = 0;
  859  2                      u16CylinderSignalNormalCnt = 0;
  860  2                      u16CylinderSignalDetectDelayTimeCnt = 0;
  861  2                      u16CylinderPushMaxValue = 0u;
  862  2              }
  863  1      }
  864         
  865         
  866         //***************************************************************************************
  867         // @Function      static void FLTD_VlinkVoltageAbnormalDetect(void) 
  868         //---------------------------------------------------------------------------------------
  869         // @Description   Motor vlink voltage abnormal detection.
  870         //---------------------------------------------------------------------------------------
  871         // @Returnvalue   None
  872         //---------------------------------------------------------------------------------------
  873         // @Parameters    None
  874         //---------------------------------------------------------------------------------------
  875         // @Date          2019/12/27
  876         //***************************************************************************************
  877         static void FLTD_VlinkVoltageAbnormalDetect(void)
  878         {
  879  1              const T_ADC *adcPtr = Adc_SampleData();
  880  1      
  881  1              //variables defined to detect vlink voltage fault
  882  1              static FLT_U16 u16VlinkVoltageHighCnt = 0;
  883  1              static FLT_U16 u16VlinkVoltageLowCnt = 0;
  884  1              static FLT_U16 u16VlinkVoltageNormalCnt = 0;
  885  1              
  886  1              /* Vlink voltage abnormal. 
  887  1               * The sample value of vlink is compared with the sample value of power supply voltage 
  888  1               * to judge the high and low vlink voltage */
  889  1              if(FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_ECU_VOLTAGE])
  890  1              {
  891  2                      if(adcPtr->motorVLinkVoltage_Adc > (adcPtr->powerVoltage_Adc + VLINK_VOLTAGE_ABNORMAL_RANG)) /* vlink vo
             -ltage too high */
  892  2                      {
  893  3                              u16VlinkVoltageLowCnt = 0;
  894  3                              u16VlinkVoltageNormalCnt = 0;
  895  3                              
  896  3                              if(u16VlinkVoltageHighCnt <= VLINK_VOLTAGE_ABNORMAL_TIME)
  897  3                              {
  898  4                                      u16VlinkVoltageHighCnt++;
  899  4                              }
  900  3                              else
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 16  

  901  3                              {
  902  4                                      FLTD_fltFlg.motorVlinkVolHighFlg = TRUE;
  903  4                              }
  904  3                      }
  905  2                      else if(adcPtr->motorVLinkVoltage_Adc < (adcPtr->powerVoltage_Adc - VLINK_VOLTAGE_ABNORMAL_RANG)) /* vli
             -nk voltage too low */
  906  2                      {
  907  3                              u16VlinkVoltageHighCnt = 0;
  908  3                              u16VlinkVoltageNormalCnt = 0;
  909  3                              
  910  3                              if(u16VlinkVoltageLowCnt <= VLINK_VOLTAGE_ABNORMAL_TIME)
  911  3                              {
  912  4                                      u16VlinkVoltageLowCnt++;
  913  4                              }
  914  3                              else
  915  3                              {
  916  4                                      FLTD_fltFlg.motorVlinkVolLowFlg = TRUE;
  917  4                              }
  918  3                      }
  919  2                      else /* vlink voltage normal */
  920  2                      {
  921  3                              u16VlinkVoltageHighCnt = 0;
  922  3                              u16VlinkVoltageLowCnt = 0;
  923  3      
  924  3                              if(u16VlinkVoltageNormalCnt <= VLINK_VOLTAGE_ABNORMAL_TIME)
  925  3                              {
  926  4                                      u16VlinkVoltageNormalCnt++;
  927  4                              }
  928  3                              else
  929  3                              {
  930  4                                      FLTD_fltFlg.motorVlinkVolHighFlg = FALSE;
  931  4                                      FLTD_fltFlg.motorVlinkVolLowFlg = FALSE;
  932  4                              }
  933  3                      }
  934  2              }
  935  1              else
  936  1              {
  937  2                      u16VlinkVoltageHighCnt = 0;
  938  2                      u16VlinkVoltageLowCnt = 0;
  939  2                      u16VlinkVoltageNormalCnt = 0;
  940  2              }
  941  1      }
  942         
  943         //***************************************************************************************
  944         // @Function      static void FLTD_CurrentInitSigAbnormalDetect(void) 
  945         //---------------------------------------------------------------------------------------
  946         // @Description   Current init signal abnormal detection.
  947         //---------------------------------------------------------------------------------------
  948         // @Returnvalue   None
  949         //---------------------------------------------------------------------------------------
  950         // @Parameters    None
  951         //---------------------------------------------------------------------------------------
  952         // @Date          2019/12/27
  953         //***************************************************************************************
  954         static void FLTD_CurrentInitSigAbnormalDetect(void)
  955         {
  956  1              const T_ADC *adcPtr = Adc_SampleData();
  957  1              
  958  1              //variables defined to detect current init signal abnormal
  959  1              static FLT_U16 u16CurrentInitSignalDetectDelayTimeCnt = 0;
  960  1              static FLT_U16 u16CurrentInitSignalAbnormalCnt = 0;
  961  1              static FLT_U16 u16CurrentInitSignalNormalCnt = 0;
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 17  

  962  1              static FLT_U16 u16CurrentSigMinValue = 0xFFFF;
  963  1      
  964  1              
  965  1              /* detect current init signal abnormal.
  966  1               * When there is no control quantity, if the difference between the current signal 
  967  1               * and the initial signal is greater than a certain value, 
  968  1               * Judge as abnormal; Otherwise it is normal */
  969  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_CURRENT_SENSOR_SIG])
  970  1                      && (FALSE == g_inBrakeSwValidSts)
  971  1                      && (WireCtrlBrakeMode != BrakeSysMode))
  972  1              {
  973  2                      /* Delay for a certain time, waiting for motor action */
  974  2                      if(u16CurrentInitSignalDetectDelayTimeCnt < CURRENT_SIGNAL_DELAY_TIME)
  975  2                      {
  976  3                              u16CurrentInitSignalDetectDelayTimeCnt++;
  977  3                              if(adcPtr->motorCurrent_Adc < u16CurrentSigMinValue)
  978  3                              {
  979  4                                      u16CurrentSigMinValue = adcPtr->motorCurrent_Adc;
  980  4                              }
  981  3                      }
  982  2                      else
  983  2                      {
  984  3                              if(ABSOLUTE(adcPtr->motorCurrent_Adc, MOTOR_CURRENT_THRESHOLD) > CURRENT_INIT_SIGNAL_ABNORMAL_RANG)
  985  3                              {
  986  4                                      u16CurrentInitSignalNormalCnt = 0;
  987  4                                      if(u16CurrentInitSignalAbnormalCnt < CURRENT_INIT_SIGNAL_ABNORMAL_TIME)
  988  4                                      {
  989  5                                              u16CurrentInitSignalAbnormalCnt++;
  990  5                                      }
  991  4                                      else
  992  4                                      {
  993  5                                              FLTD_fltFlg.currentSensorAbnormalFlg = TRUE;
  994  5                                      }
  995  4                              }
  996  3                              else
  997  3                              {
  998  4                                      u16CurrentInitSignalAbnormalCnt = 0;
  999  4                                      if(u16CurrentInitSignalNormalCnt < CURRENT_INIT_SIGNAL_ABNORMAL_TIME)
 1000  4                                      {
 1001  5                                              u16CurrentInitSignalNormalCnt++;
 1002  5                                      }
 1003  4                                      else
 1004  4                                      {
 1005  5                                              FLTD_fltFlg.currentSensorAbnormalFlg = FALSE;
 1006  5                                      }
 1007  4                              }
 1008  3                      }
 1009  2              }
 1010  1              else
 1011  1              {
 1012  2                      u16CurrentInitSignalDetectDelayTimeCnt = 0;
 1013  2                      u16CurrentInitSignalAbnormalCnt = 0;
 1014  2                      u16CurrentInitSignalNormalCnt = 0;
 1015  2                      u16CurrentSigMinValue = 0xFFFF;
 1016  2              }
 1017  1      }
 1018         
 1019         //***************************************************************************************
 1020         // @Function      static void FLTD_PredriverFaultDetect(void) 
 1021         //---------------------------------------------------------------------------------------
 1022         // @Description   Motor pre-drive fault detection.
 1023         //---------------------------------------------------------------------------------------
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 18  

 1024         // @Returnvalue   None
 1025         //---------------------------------------------------------------------------------------
 1026         // @Parameters    None
 1027         //---------------------------------------------------------------------------------------
 1028         // @Date          2019/12/27
 1029         //***************************************************************************************
 1030         static void FLTD_PredriverFaultDetect(void)
 1031         {
 1032  1              //variables defined to detect pre Driver fault
 1033  1              static FLT_U16 u16PredriverDetectWaitTimeCnt = PREDRIVER_FAULT_DELAY_TIME;      
 1034  1              static FLT_U16 u16PredriveFaultTimeCnt = 0;
 1035  1              static FLT_U16 u16PredriveRecoverTimeCnt = 0;
 1036  1              static FLT_U8 u8PredriveFaultCnt = 0;
 1037  1              static FLT_BOOL bResetFlag = FALSE;
 1038  1              
 1039  1              /* detect predriver fault. 
 1040  1               * 1) When the detection level of predrive is low, After meeting the time requirement, 
 1041  1               * reset the predrive, and retest the interval at 200ms with a maximum of 3 times reset. 
 1042  1               * if it is still low, the fault is judged: 
 1043  1               * 2) If the level is high enough to meet the time requirement, it is considered normal */
 1044  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_ECU_VOLTAGE])
 1045  1                      && (FALSE == FLTD_fltFlg.motorVlinkVolHighFlg)
 1046  1                      && ((FALSE == FLTD_fltFlg.motorVlinkVolLowFlg)))
 1047  1              {
 1048  2                      if(u16PredriverDetectWaitTimeCnt < PREDRIVER_FAULT_DELAY_TIME)
 1049  2                      {
 1050  3                              u16PredriverDetectWaitTimeCnt++;
 1051  3                              
 1052  3                              if(TRUE == bResetFlag)
 1053  3                              {
 1054  4                                      bResetFlag = FALSE;
 1055  4                                      IO_vSetPin(IO_P0_7); /* open pre driver */
 1056  4                              }
 1057  3                      }
 1058  2                      else
 1059  2                      {
 1060  3                              if(0 == g_inPreDriverSts) /* fault */
 1061  3                              {
 1062  4                                      u16PredriveRecoverTimeCnt = 0;
 1063  4                                      
 1064  4                                      if(u16PredriveFaultTimeCnt < PREDRIVER_FAULT_TIME)
 1065  4                                      {
 1066  5                                              u16PredriveFaultTimeCnt++;
 1067  5                                      }
 1068  4                                      else
 1069  4                                      {
 1070  5                                              if(u8PredriveFaultCnt < PREDRIVER_RESET_COUNT)
 1071  5                                              {
 1072  6                                                      u8PredriveFaultCnt++;
 1073  6                                                      
 1074  6                                                      IO_vResetPin(IO_P0_7); /* close pre driver */
 1075  6                                                      bResetFlag = TRUE;
 1076  6                                                      u16PredriveFaultTimeCnt = 0;
 1077  6                                                      u16PredriverDetectWaitTimeCnt = 0;
 1078  6                                              }
 1079  5                                              else
 1080  5                                              {
 1081  6                                                      FLTD_fltFlg.motorPredriveFaultFlg = TRUE;
 1082  6                                              }
 1083  5                                      }
 1084  4                              }
 1085  3                              else /* normal */
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 19  

 1086  3                              {
 1087  4                                      u16PredriveFaultTimeCnt = 0;
 1088  4      
 1089  4                                      if(u16PredriveRecoverTimeCnt < PREDRIVER_FAULT_TIME)
 1090  4                                      {
 1091  5                                              u16PredriveRecoverTimeCnt++;
 1092  5                                      }
 1093  4                                      else
 1094  4                                      {
 1095  5                                              FLTD_fltFlg.motorPredriveFaultFlg = FALSE;
 1096  5      
 1097  5                                              u8PredriveFaultCnt = 0;
 1098  5                                              u16PredriverDetectWaitTimeCnt = PREDRIVER_FAULT_DELAY_TIME;
 1099  5                                      }
 1100  4                              }
 1101  3                      }               
 1102  2              }
 1103  1              else
 1104  1              {
 1105  2                      u16PredriverDetectWaitTimeCnt = 0;      
 1106  2                      u16PredriveFaultTimeCnt = 0;
 1107  2                      u16PredriveRecoverTimeCnt = 0;
 1108  2                      u8PredriveFaultCnt = 0;
 1109  2              }
 1110  1      }
 1111         
 1112         //***************************************************************************************
 1113         // @Function      static void FLTD_MotorFaultDetect(void) 
 1114         //---------------------------------------------------------------------------------------
 1115         // @Description   Motor open circuit and short circuit fault detection.
 1116         //---------------------------------------------------------------------------------------
 1117         // @Returnvalue   None
 1118         //---------------------------------------------------------------------------------------
 1119         // @Parameters    None
 1120         //---------------------------------------------------------------------------------------
 1121         // @Date          2019/12/27
 1122         //***************************************************************************************
 1123         static void FLTD_MotorFaultDetect(void)
 1124         {
 1125  1              const T_ADC_APP *ptr_adcApp = AdcApp_SampleData();
 1126  1              const T_PWM* ptr_Pwm = Pwm_ControlData();
 1127  1              //variables defined to detect motor current fault
 1128  1              static FLT_U16 u16MotorOpenFaultTimeCnt = 0;
 1129  1              static FLT_U16 u16MotorOpenRecoverTimeCnt = 0;
 1130  1              static FLT_U16 u16MotorShortFaultTimeCnt = 0;
 1131  1              static FLT_U16 u16MotorShortRecoverTimeCnt = 0;
 1132  1              
 1133  1              /* detect Motor fault.
 1134  1               * When a certain control quantity is reached, 
 1135  1               * Judge whether the motor is open or short according to the current */
 1136  1              if(FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_CURRENT_SENSOR_SIG])
 1137  1              {
 1138  2                      if((ptr_Pwm->motorCtrl > PWM_AMPLITUDE_DEFAULT)
 1139  2                              && ((ptr_Pwm->motorCtrl - PWM_AMPLITUDE_DEFAULT) > MOTOR_OPEN_CTRL_THRESHOLD))
 1140  2                      {
 1141  3                              /* motor open fault */
 1142  3                              if(ptr_adcApp->brakeMotorCurrent < MOTOR_CURRENT_OPEN_THRESHOLD)                        
 1143  3                              {
 1144  4                                      u16MotorOpenRecoverTimeCnt = 0;
 1145  4                                      if(u16MotorOpenFaultTimeCnt < MOTOR_CURRENT_OPEN_TIME)
 1146  4                                      {
 1147  5                                              u16MotorOpenFaultTimeCnt++;
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 20  

 1148  5                                      }
 1149  4                                      else
 1150  4                                      {
 1151  5                                              FLTD_fltFlg.motorOpenFlg = TRUE;
 1152  5                                      }
 1153  4                              }
 1154  3                              else
 1155  3                              {
 1156  4                                      u16MotorOpenFaultTimeCnt = 0;
 1157  4                                      if(u16MotorOpenRecoverTimeCnt < MOTOR_CURRENT_OPEN_TIME)
 1158  4                                      {
 1159  5                                              u16MotorOpenRecoverTimeCnt++;
 1160  5                                      }
 1161  4                                      else
 1162  4                                      {
 1163  5                                              FLTD_fltFlg.motorOpenFlg = FALSE;
 1164  5                                      }       
 1165  4                              }
 1166  3                      }
 1167  2                      else
 1168  2                      {
 1169  3                              u16MotorOpenFaultTimeCnt = 0;
 1170  3                              u16MotorOpenRecoverTimeCnt = 0;
 1171  3                      }
 1172  2      
 1173  2                      
 1174  2                      /* motor short fault */
 1175  2                      if(ptr_adcApp->brakeMotorCurrent > MOTOR_CURRENT_SHORT_THRESHOLD)
 1176  2                      {
 1177  3                              u16MotorShortRecoverTimeCnt = 0;
 1178  3                              if(u16MotorShortFaultTimeCnt < MOTOR_CURRENT_SHORT_TIME)
 1179  3                              {
 1180  4                                      u16MotorShortFaultTimeCnt++;
 1181  4                              }
 1182  3                              else
 1183  3                              {
 1184  4                                      FLTD_fltFlg.motorShortFlg = TRUE;
 1185  4                              }
 1186  3                      }
 1187  2                      else
 1188  2                      {
 1189  3                              u16MotorShortFaultTimeCnt = 0;
 1190  3                              if(u16MotorShortRecoverTimeCnt < MOTOR_CURRENT_SHORT_TIME)
 1191  3                              {
 1192  4                                      u16MotorShortRecoverTimeCnt++;
 1193  4                              }
 1194  3                              else
 1195  3                              {
 1196  4                                      FLTD_fltFlg.motorShortFlg = FALSE;
 1197  4                              }
 1198  3                      }       
 1199  2              }
 1200  1              else
 1201  1              {
 1202  2                      u16MotorOpenFaultTimeCnt = 0;
 1203  2                      u16MotorOpenRecoverTimeCnt = 0;
 1204  2                      u16MotorShortFaultTimeCnt = 0;
 1205  2                      u16MotorShortRecoverTimeCnt = 0;
 1206  2              }
 1207  1      }
 1208         
 1209         
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 21  

 1210         //***************************************************************************************
 1211         // @Function      static FLT_BOOL FLTD_GetAdcCondition(FLTD_adcType adcIndex) 
 1212         //---------------------------------------------------------------------------------------
 1213         // @Description   Gets whether the AD sample value detection condition are meet. 
 1214         //---------------------------------------------------------------------------------------
 1215         // @Returnvalue   adcIndex:
 1216         //                                              adc sampling channel
 1217         //---------------------------------------------------------------------------------------
 1218         // @Parameters    TRUE  : detect conditions meet
 1219         //                                FALSE : detect conditions not meet
 1220         //---------------------------------------------------------------------------------------
 1221         // @Date          2019/12/27
 1222         //***************************************************************************************
 1223         static FLT_BOOL FLTD_GetAdcCondition(FLTD_adcType adcIndex)
 1224         {       
 1225  1              switch(adcIndex)
 1226  1              {
 1227  2                      case FLTD_ADC_ECU_VOLTAGE:
 1228  2                      {
 1229  3                              if(TRUE == g_cylinderExhaustEnFlag)
 1230  3                              {
 1231  4                                      return FALSE;
 1232  4                              }
 1233  3                              break;
 1234  3                      }
 1235  2                      
 1236  2                      case FLTD_ADC_ENV_TEMPERATURE:
 1237  2                      {
 1238  3                              break;
 1239  3                      }
 1240  2                      
 1241  2                      case FLTD_ADC_PEDAL_SENSOR_VOLTAGE:
 1242  2                      {
 1243  3                              return FALSE;
 1244  3                              break;
 1245  3                      }
 1246  2                      
 1247  2                      case FLTD_ADC_PEDAL_SENSOR_SIG1:
 1248  2                      case FLTD_ADC_PEDAL_SENSOR_SIG2:
 1249  2                      {
 1250  3                              //if(FLTD_VOL_NORMAL != adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_VOLTAGE])
 1251  3                              {
 1252  4                                      return FALSE;
 1253  4                              }
 1254  3                              break;
 1255  3                      }
 1256  2                      
 1257  2                      case FLTD_ADC_MAIN_CYLINDER_VOLTAGE:
 1258  2                      {
 1259  3                              break;
 1260  3                      }
 1261  2                      
 1262  2                      case FLTD_ADC_MAIN_CYLINDER_SIG1:
 1263  2                      case FLTD_ADC_MAIN_CYLINDER_SIG2:
 1264  2                      {
 1265  3                              if(FLTD_VOL_NORMAL != adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_VOLTAGE])
 1266  3                              {
 1267  4                                      return FALSE;
 1268  4                              }
 1269  3                              break;
 1270  3                      }
 1271  2                      
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 22  

 1272  2                      case FLTD_ADC_CURRENT_SENSOR_SIG:
 1273  2                      {
 1274  3                              break;
 1275  3                      }
 1276  2                      
 1277  2                      default:
 1278  2                              break;
 1279  2              }
 1280  1      
 1281  1              return TRUE;
 1282  1      }
 1283         
 1284         
 1285         //***************************************************************************************
 1286         // @Function      static void FLTD_FaultActionHandle(void) 
 1287         //---------------------------------------------------------------------------------------
 1288         // @Description   Fault handling function. Set different processing marks according to 
 1289         //                                      different fault types for upper-layer applications. 
 1290         //---------------------------------------------------------------------------------------
 1291         // @Returnvalue   None
 1292         //---------------------------------------------------------------------------------------
 1293         // @Parameters    None
 1294         //---------------------------------------------------------------------------------------
 1295         // @Date          2019/12/27
 1296         //***************************************************************************************
 1297         static void FLTD_FaultActionHandle(void)
 1298         {
 1299  1              /* close predriver */
 1300  1              if((TRUE == FLTD_fltFlg.ecuVoltageHighFlg)
 1301  1                      || (TRUE == FLTD_fltFlg.motorShortFlg)
 1302  1                      || (TRUE == FLTD_fltFlg.motorPredriveFaultFlg))
 1303  1              {
 1304  2                      FLTD_fltActFlg.closePredriverFlg = TRUE;
 1305  2              }
 1306  1              else
 1307  1              {
 1308  2                      FLTD_fltActFlg.closePredriverFlg = FALSE;
 1309  2              }
 1310  1      
 1311  1              /* close main relay */
 1312  1              if((TRUE == FLTD_fltFlg.ecuVoltageHighFlg)
 1313  1                      || (TRUE == FLTD_fltFlg.motorVlinkVolHighFlg)
 1314  1                      || (TRUE == FLTD_fltFlg.motorVlinkVolLowFlg))
 1315  1              {
 1316  2                      FLTD_fltActFlg.closeMainRelayFlg = TRUE;
 1317  2              }
 1318  1              else
 1319  1              {
 1320  2                      FLTD_fltActFlg.closeMainRelayFlg = FALSE;
 1321  2              }
 1322  1      
 1323  1              /* close pedal sensor power */
 1324  1              if((TRUE == FLTD_fltFlg.ecuVoltageHighFlg)
 1325  1                      || (TRUE == FLTD_fltFlg.pedalSensorVoltageHighFlg)
 1326  1                      || (TRUE == FLTD_fltFlg.pedalSensorVoltageLowFlg)
 1327  1                      || (TRUE == FLTD_fltFlg.pedalSensorShortFlg))
 1328  1              {
 1329  2                      FLTD_fltActFlg.closePedalPowerFlg = TRUE;
 1330  2              }
 1331  1              else
 1332  1              {
 1333  2                      FLTD_fltActFlg.closePedalPowerFlg = FALSE;
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 23  

 1334  2              }
 1335  1      
 1336  1              /* close cylinder sensor power */
 1337  1              if((TRUE == FLTD_fltFlg.ecuVoltageHighFlg)
 1338  1                      || (TRUE == FLTD_fltFlg.cylinderSensorVolHighFlg)
 1339  1                      || (TRUE == FLTD_fltFlg.cylinderSensorVolLowFlg)
 1340  1                      || (TRUE == FLTD_fltFlg.cylinderSensorShortFlg))
 1341  1              {
 1342  2                      FLTD_fltActFlg.closeCylinderPowerFlg = TRUE;
 1343  2              }
 1344  1              else
 1345  1              {
 1346  2                      FLTD_fltActFlg.closeCylinderPowerFlg = FALSE;
 1347  2              }
 1348  1      
 1349  1              /* close energy recovery */
 1350  1              if(0)
 1351  1              {
 1352  2                      FLTD_fltActFlg.closeEnergyRecoveryFlg = TRUE;
 1353  2              }
 1354  1              else
 1355  1              {
 1356  2                      FLTD_fltActFlg.closeEnergyRecoveryFlg = FALSE;
 1357  2              }
 1358  1      
 1359  1              /* reduce motor power */
 1360  1              if(TRUE == FLTD_fltFlg.temperatureHighFlg)
 1361  1              {
 1362  2                      FLTD_fltActFlg.reduceMotorPowerFlg = TRUE;
 1363  2              }
 1364  1              else
 1365  1              {
 1366  2                      FLTD_fltActFlg.reduceMotorPowerFlg = FALSE;
 1367  2              }
 1368  1      
 1369  1      
 1370  1              /* fixed Deceleration */
 1371  1              if((TRUE == FLTD_fltFlg.pedalSensorVoltageHighFlg)
 1372  1                      || (TRUE == FLTD_fltFlg.pedalSensorVoltageLowFlg)
 1373  1                      || (TRUE == FLTD_fltFlg.pedalSensorShortFlg)
 1374  1                      || (TRUE == FLTD_fltFlg.pedalSensor1OpenFlg)
 1375  1                      || (TRUE == FLTD_fltFlg.pedalSensor1OverRangFlg)
 1376  1                      || (TRUE == FLTD_fltFlg.pedalSensor2OpenFlg)
 1377  1                      || (TRUE == FLTD_fltFlg.pedalSensor2OverRangFlg)
 1378  1                      || (TRUE == FLTD_fltFlg.pedalSensorCheckErrorFlg)
 1379  1                      || (TRUE == FLTD_fltFlg.pedalSensorInitAbnormalFlg)
 1380  1                      || (TRUE == FLTD_fltFlg.pedalSensorSignalAbnormalFlg)
 1381  1                      || (TRUE == FLTD_fltFlg.pedalSensorReturnAbnormalFlg))
 1382  1              {
 1383  2                      FLTD_fltActFlg.fixedDecelerationFlg = TRUE;
 1384  2              }
 1385  1              else
 1386  1              {
 1387  2                      FLTD_fltActFlg.fixedDecelerationFlg = FALSE;
 1388  2              }
 1389  1      
 1390  1              /* braking Depends On Current */
 1391  1              if((TRUE == FLTD_fltFlg.cylinderSensorVolHighFlg)
 1392  1                      || (TRUE == FLTD_fltFlg.cylinderSensorVolLowFlg)
 1393  1                      || (TRUE == FLTD_fltFlg.cylinderSensorShortFlg)
 1394  1                      || (TRUE == FLTD_fltFlg.cylinderSensor1OpenFlg)
 1395  1                      || (TRUE == FLTD_fltFlg.cylinderSensor1OverRangFlg)
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 24  

 1396  1                      || (TRUE == FLTD_fltFlg.cylinderSensor2OpenFlg)
 1397  1                      || (TRUE == FLTD_fltFlg.cylinderSensor2OverRangFlg)
 1398  1                      || (TRUE == FLTD_fltFlg.cylinderSensorCheckErrorFlg)
 1399  1                      || (TRUE == FLTD_fltFlg.cylinderSensorInitAbnormalFlg)
 1400  1                      || (TRUE == FLTD_fltFlg.cylinderSensorSignalAbnormalFlg))
 1401  1              {
 1402  2                      FLTD_fltActFlg.brakingDependsOnCurrentFlg = TRUE;
 1403  2              }
 1404  1              else
 1405  1              {
 1406  2                      FLTD_fltActFlg.brakingDependsOnCurrentFlg = FALSE;
 1407  2              }
 1408  1      
 1409  1              /* braking Depends On Cylinder */
 1410  1              if((TRUE == FLTD_fltFlg.currentSensorOverRangFlg)
 1411  1                      || (TRUE == FLTD_fltFlg.currentSensorAbnormalFlg))
 1412  1              {
 1413  2                      FLTD_fltActFlg.brakingDependsOnCylinderFlg = TRUE;
 1414  2              }
 1415  1              else
 1416  1              {
 1417  2                      FLTD_fltActFlg.brakingDependsOnCylinderFlg = FALSE;
 1418  2              }
 1419  1      }
 1420         
 1421         
 1422         
 1423         const FLTD_faultFlagType* FLTD_FltFlgData(void)
 1424         {
 1425  1              return (&FLTD_fltFlg);
 1426  1      }
 1427         
 1428         //***************************************************************************************
 1429         // @Function      const FLTD_faultActType* FLTD_FltActFlgData(void) 
 1430         //---------------------------------------------------------------------------------------
 1431         // @Description   Fault action interface.  
 1432         //---------------------------------------------------------------------------------------
 1433         // @Returnvalue   fault action structure access address
 1434         //---------------------------------------------------------------------------------------
 1435         // @Parameters    None
 1436         //---------------------------------------------------------------------------------------
 1437         // @Date          2019/12/27
 1438         //***************************************************************************************
 1439         const FLTD_faultActType* FLTD_FltActFlgData(void)
 1440         {
 1441  1              return (&FLTD_fltActFlg);
 1442  1      }
 1443         
*** WARNING C174 IN LINE 493 OF src\app\diagnostic\FLTD.c: 'FLTD_PedalReturnAbnormalDetect': unreferenced 'static' funct
             -ion
*** WARNING C174 IN LINE 720 OF src\app\diagnostic\FLTD.c: 'FLTD_CylinderInitLocAbnormalDetect': unreferenced 'static' f
             -unction
*** WARNING C174 IN LINE 306 OF src\app\diagnostic\FLTD.c: 'FLTD_PedalDetectCondigtJudge': unreferenced 'static' functio
             -n
*** WARNING C174 IN LINE 1030 OF src\app\diagnostic\FLTD.c: 'FLTD_PredriverFaultDetect': unreferenced 'static' function
*** WARNING C174 IN LINE 418 OF src\app\diagnostic\FLTD.c: 'FLTD_PedalInitLocAbnormalDetect': unreferenced 'static' func
             -tion
*** WARNING C174 IN LINE 797 OF src\app\diagnostic\FLTD.c: 'FLTD_CylinderSignalAbnormalDetect': unreferenced 'static' fu
             -nction
*** WARNING C174 IN LINE 954 OF src\app\diagnostic\FLTD.c: 'FLTD_CurrentInitSigAbnormalDetect': unreferenced 'static' fu
             -nction
*** WARNING C174 IN LINE 567 OF src\app\diagnostic\FLTD.c: 'FLTD_PedalActionAbnormalDetect': unreferenced 'static' funct
C166 COMPILER V7.57.0, FLTD                                                                11/13/2020 15:09:26 PAGE 25  

             -ion
*** WARNING C174 IN LINE 338 OF src\app\diagnostic\FLTD.c: 'FLTD_PedalSigCheckErrorDetect': unreferenced 'static' functi
             -on
*** WARNING C174 IN LINE 877 OF src\app\diagnostic\FLTD.c: 'FLTD_VlinkVoltageAbnormalDetect': unreferenced 'static' func
             -tion


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        1868     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          81     --------
  FAR-DATA SIZE    =         424     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =         666     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  10 WARNING(S),  0 ERROR(S)
