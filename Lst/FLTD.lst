C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 1   


C166 COMPILER V7.57.0, COMPILATION OF MODULE FLTD
OBJECT MODULE PLACED IN .\Obj\FLTD.obj
COMPILER INVOKED BY: C:\Keil_v5\C166\BIN\C166.EXE src\app\diagnostic\FLTD.c MODV2 LARGE BROWSE INCDIR(.\src;.\src\bsw;.\
                    -src\driver;.\src\interaction;.\src\app\adc;.\src\app\alogrithm;.\src\app\can;.\src\app\ccp;.\src\app\diagnostic;.\src\ap
                    -p\mode control;.\src\app\task;.\src\app\Fun;.\src\app\rtos;.\src\bsw\can;.\src\bsw\desc;.\src\bsw\nm;.\src\app\time meas
                    -ure;.\src\app\rte) MODV2 DEBUG PRINT(.\Lst\FLTD.lst) OBJECT(.\Obj\FLTD.obj) 

 stmt lvl     source

    1         /***********************************************************************
    2         *   Copyright (C) JWD Automotive Co., Ltd.                                             * 
    3         *               All Rights Reserved.                                                           *
    4         *   Department : iCAS SW                                                                               *
    5         *   AUTHOR         :                                                                                               *
    6         ************************************************************************
    7         * Object        : 
    8         * Module        : FLTD.c
    9         * Instance      : 
   10         * Description   :  fault diagnosis
   11         *-----------------------------------------------------------------------
   12         * Version: v0.1
   13         * Date   : Nov 12,2019 
   14         * Author : Zhu jinfeng
   15         ***********************************************************************/
   16         /*-History--------------------------------------------------------------
   17         * Version    Date           Name            Changes and comments
   18         ------------------------------------------------------------------------
   19         * 0.1       Nov 12,2019     Zhu jinfeng     Initial version
   20         *=====================================================================*/
   21         
   22         #define  FLTD_C_
   23         #include "string.h"
   24         #include "MAIN.h"
   25         #include "adc_sample.h"
   26         #include "FLTD.h"
   27         #include "rte.h"
   28         #include "pid.h"
   29         #include "pwm.h"
   30         #include "booster.h"
   31         
   32         /**** Definition of variables ****/
   33         static FLTD_faultFlagType FLTD_fltFlg = {0};
   34         static FLTD_faultActType FLTD_fltActFlg = {0};
   35         #include "FLTD_Cfg.h"
   36         
   37         static FLTD_volModeType adcVoltModeSts[FLTD_ADC_MAX] = {0};
   38         
   39         static FLT_U8 u8BrakeSwStsLast = 0;
   40         static FLT_BOOL bPedalReturnFlag = FALSE; /* brake from valid to invalid, set the pedal return flag */
   41         static FLT_BOOL bPedalPushFlag = FALSE; /* brake from invalid to valid, set the pedal push flag */
   42         static FLT_U16 u16PedalInitLocMinValue = 0xFFFF; /* This variable record the minimum value of pedal return
             - */
   43         static FLT_U16 u16PedalReturnMinValue = 0xFFFF; /* This variable record the minimum value of pedal return 
             -*/
   44         static FLT_U16 u16PedalPushMaxValue = 0; /* This variable records the maximum value of the pedal */
   45         static FLT_U16 u16CylinderReturnMinValue = 0xFFFF; /* This variable record the minimum value of cylinder r
             -eturn */
   46         static FLT_U16 u16CylinderPushMaxValue = 0; /* This variable records the maximum value of the cylinder */
   47         
   48         
   49         /**** Declaration of functions ****/
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 2   

   50         
   51         static void FLTD_AdcMonitor(void);
   52         static void FLTD_PedalDetectCondigtJudge(void);
   53         static void FLTD_PedalSigCheckErrorDetect(void);
   54         static void FLTD_PedalInitLocAbnormalDetect(void);
   55         static void FLTD_PedalReturnAbnormalDetect(void);
   56         static void FLTD_PedalActionAbnormalDetect(void);
   57         static void FLTD_CylinderSigCheckErrorDetect(void);
   58         static void FLTD_CylinderInitLocAbnormalDetect(void);
   59         static void FLTD_CylinderSignalAbnormalDetect(void);
   60         static void FLTD_VlinkVoltageAbnormalDetect(void);
   61         static void FLTD_CurrentInitSigAbnormalDetect(void);
   62         static void FLTD_PredriverFaultDetect(void);
   63         static void FLTD_MotorFaultDetect(void);
   64         
   65         
   66         static void FLTD_FaultActionHandle(void);
   67         static FLT_BOOL FLTD_GetAdcCondition(FLTD_adcType adcIndex);
   68         
   69         
   70         //***************************************************************************************
   71         // @Function      void FLTD_Init(void)
   72         //
   73         //---------------------------------------------------------------------------------------
   74         // @Description   FLTD module initialization function.Perform initialization as needed.
   75         //
   76         //---------------------------------------------------------------------------------------
   77         // @Returnvalue   none 
   78         //
   79         //---------------------------------------------------------------------------------------
   80         // @Parameters    none
   81         //
   82         //---------------------------------------------------------------------------------------
   83         // @Date          2019/11/7
   84         //
   85         //***************************************************************************************
   86         void FLTD_Init(void)
   87         {
   88  1              memset(&adcVoltModeSts, 0, FLTD_ADC_MAX);
   89  1      }
   90         
   91         //***************************************************************************************
   92         // @Function      void FLTD_Runnable(void)
   93         //---------------------------------------------------------------------------------------
   94         // @Description   FLTD module cycle task function. AD sampling value range judgment and 
   95         //                                signal fault processing are performed according to the scheduling cycle.
   96         //---------------------------------------------------------------------------------------
   97         // @Returnvalue   none 
   98         //---------------------------------------------------------------------------------------
   99         // @Parameters    none
  100         //---------------------------------------------------------------------------------------
  101         // @Date          2019/11/7
  102         //***************************************************************************************
  103         void FLTD_Runnable(void)
  104         {
  105  1              FLTD_AdcMonitor();
  106  1              
  107  1      #if ((2 == BRAKE_SIGNAL_SOURCE) || (3 == BRAKE_SIGNAL_SOURCE))
                      FLTD_PedalDetectCondigtJudge();
                      FLTD_PedalInitLocAbnormalDetect();
                      FLTD_PedalReturnAbnormalDetect();
                      FLTD_PedalActionAbnormalDetect();
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 3   

                      FLTD_CylinderInitLocAbnormalDetect();
                      
              #endif
  115  1              
  116  1              FLTD_CurrentInitSigAbnormalDetect(); //muYuan
  117  1              
  118  1              FLTD_PedalSigCheckErrorDetect();
  119  1              FLTD_CylinderSigCheckErrorDetect();
  120  1              FLTD_CylinderSignalAbnormalDetect();
  121  1              FLTD_VlinkVoltageAbnormalDetect();
  122  1              FLTD_PredriverFaultDetect();
  123  1              FLTD_MotorFaultDetect();
  124  1              
  125  1              FLTD_FaultActionHandle();
  126  1      }
  127         
  128         
  129         
  130         //***************************************************************************************
  131         // @Function      static void FLTD_AdcMonitor(void) 
  132         //---------------------------------------------------------------------------------------
  133         // @Description   AD samples values is divided into five, in order to stop, low,  
  134         //                                normal, high, over, etc.
  135         //
  136         //---------- stop_t ----------------- low_t ------  high_t ------------------- over_t ---
  137         //             |         |   lowHyst    |                        |        highHyst       |          |   
  138         //                         |         |                      |                    |                               |                  |
  139         //     stop        |   low      low/normal  |  normal    |       normal/high     high   |       over
  140         //---------------------------------------------------------------------------------------
  141         // @Returnvalue   None
  142         //---------------------------------------------------------------------------------------
  143         // @Parameters    None
  144         //---------------------------------------------------------------------------------------
  145         // @Date          2019/11/7
  146         //***************************************************************************************
  147         static void FLTD_AdcMonitor(void)
  148         {
  149  1              FLTD_adcType adcIndex = 0;
  150  1      
  151  1              static FLTD_volModeType adcVoltModeTemp[FLTD_ADC_MAX] = {0};
  152  1              static FLTD_volModeType adcVoltModeStsLast[FLTD_ADC_MAX] = {0};
  153  1              static FLT_U16 g_u16VoltModeFilterCnt[FLTD_ADC_MAX] = {0};
  154  1              FLTD_AdcMonitorCfgType* ptrAdcMonitorCfg = NULL;
  155  1      
  156  1              /* For the configured AD channel, According to the sample AD value, determine which range it belongs to *
             -/
  157  1              for (adcIndex = 0; adcIndex < FLTD_ADC_MAX; adcIndex++)
  158  1              {
  159  2                      /* If the channel detection condition is not satisfied, skip */
  160  2                      if(FALSE == FLTD_GetAdcCondition(adcIndex))
  161  2                      {
  162  3                              g_u16VoltModeFilterCnt[adcIndex] = 0;
  163  3                              continue;
  164  3                      }
  165  2                      
  166  2                      ptrAdcMonitorCfg = (FLTD_AdcMonitorCfgType*) &FLTD_AdcMonitorCfg[adcIndex];
  167  2                      
  168  2                      if ((*ptrAdcMonitorCfg->adcValue >= ptrAdcMonitorCfg->lowThreshold)
  169  2                              && (*ptrAdcMonitorCfg->adcValue <= ptrAdcMonitorCfg->highThreshold))/* low ~ high */
  170  2                      {
  171  3                              adcVoltModeTemp[adcIndex] = FLTD_VOL_NORMAL;
  172  3                      }
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 4   

  173  2                      else
  174  2                      {
  175  3                              if (*ptrAdcMonitorCfg->adcValue > ptrAdcMonitorCfg->highThreshold) /* high ~  */
  176  3                              {
  177  4                                      if (*ptrAdcMonitorCfg->adcValue < (ptrAdcMonitorCfg->highThreshold + ptrAdcMonitorCfg->highHyst)) /* h
             -igh ~ (high + high_hyst) */
  178  4                                      {
  179  5                                              adcVoltModeTemp[adcIndex] = FLTD_VOL_HIGH_HYST;
  180  5                                      }
  181  4                                      else if (*ptrAdcMonitorCfg->adcValue <= ptrAdcMonitorCfg->overThreshold) /* (high + highHyst) ~ over *
             -/
  182  4                                      {
  183  5                                              adcVoltModeTemp[adcIndex] = FLTD_VOL_HIGH;
  184  5                                      }
  185  4                                      else                                                                                                                                    /* over ~  */
  186  4                                      {
  187  5                                              adcVoltModeTemp[adcIndex] = FLTD_VOL_OVER;
  188  5                                      }
  189  4                              }
  190  3                              else                                                                                                                            /*  ~ low */
  191  3                              {
  192  4                                      if (*ptrAdcMonitorCfg->adcValue > (ptrAdcMonitorCfg->lowThreshold - ptrAdcMonitorCfg->lowHyst)) /* (lo
             -w - low_hyst) ~ low */
  193  4                                      {
  194  5                                              adcVoltModeTemp[adcIndex] = FLTD_VOL_LOW_HYST;
  195  5                                      }
  196  4                                      else if (*ptrAdcMonitorCfg->adcValue >= ptrAdcMonitorCfg->stopThreshold) /* stop ~ (low - lowHyst)*/
  197  4                                      {
  198  5                                              adcVoltModeTemp[adcIndex] = FLTD_VOL_LOW;
  199  5                                      }
  200  4                                      else                                                                                                                                    /*  ~ stop */
  201  4                                      {
  202  5                                              adcVoltModeTemp[adcIndex] = FLTD_VOL_STOP;
  203  5                                      }
  204  4                              }
  205  3                      }
  206  2      
  207  2                      /* According to the judgment of the above process, filter the judgment result */
  208  2                      if (adcVoltModeTemp[adcIndex] != adcVoltModeSts[adcIndex])
  209  2                      {
  210  3                              if (g_u16VoltModeFilterCnt[adcIndex] < ptrAdcMonitorCfg->filterTime)
  211  3                              {
  212  4                                      g_u16VoltModeFilterCnt[adcIndex]++;
  213  4                              }
  214  3                              else
  215  3                              {
  216  4                                      adcVoltModeSts[adcIndex] = adcVoltModeTemp[adcIndex];
  217  4                                      g_u16VoltModeFilterCnt[adcIndex] = 0;
  218  4                              }
  219  3                      }
  220  2                      else
  221  2                      {
  222  3                              g_u16VoltModeFilterCnt[adcIndex] = 0;
  223  3                      }
  224  2      
  225  2                      /* In both cases in the low or high hysteretic interval, 
  226  2                      *  the result is normal if the entry is from the normal range;
  227  2                      *  If the entry is from the corresponding low or high state, 
  228  2                      *  the low or high state is maintained 
  229  2                      */
  230  2                      if (FLTD_VOL_LOW_HYST == adcVoltModeSts[adcIndex])
  231  2                      {
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 5   

  232  3                              if ((FLTD_VOL_LOW == adcVoltModeStsLast[adcIndex])
  233  3                                      || (FLTD_VOL_STOP == adcVoltModeStsLast[adcIndex]))
  234  3                              {
  235  4                                      adcVoltModeSts[adcIndex] = FLTD_VOL_LOW;
  236  4                              }
  237  3                              else
  238  3                              {
  239  4                                      adcVoltModeSts[adcIndex] = FLTD_VOL_NORMAL;
  240  4                              }
  241  3                      }
  242  2                      else if (FLTD_VOL_HIGH_HYST == adcVoltModeSts[adcIndex])
  243  2                      {
  244  3                              if ((FLTD_VOL_HIGH == adcVoltModeStsLast[adcIndex])
  245  3                                      || (FLTD_VOL_OVER == adcVoltModeStsLast[adcIndex]))
  246  3                              {
  247  4                                      adcVoltModeSts[adcIndex] = FLTD_VOL_HIGH;
  248  4                              }
  249  3                              else
  250  3                              {
  251  4                                      adcVoltModeSts[adcIndex] = FLTD_VOL_NORMAL;
  252  4                              }
  253  3                      }
  254  2                      else
  255  2                      {
  256  3      
  257  3                      }
  258  2      
  259  2                      //set and clear fault flag
  260  2                      if(FLTD_VOL_NORMAL == adcVoltModeSts[adcIndex])
  261  2                      {
  262  3                              *ptrAdcMonitorCfg->faultFlag[0] = FALSE;
  263  3                              *ptrAdcMonitorCfg->faultFlag[1] = FALSE;
  264  3                              *ptrAdcMonitorCfg->faultFlag[2] = FALSE;
  265  3                              *ptrAdcMonitorCfg->faultFlag[3] = FALSE;
  266  3                      }
  267  2                      else
  268  2                      {
  269  3                              *ptrAdcMonitorCfg->faultFlag[0] = FALSE;
  270  3                              *ptrAdcMonitorCfg->faultFlag[1] = FALSE;
  271  3                              *ptrAdcMonitorCfg->faultFlag[2] = FALSE;
  272  3                              *ptrAdcMonitorCfg->faultFlag[3] = FALSE;
  273  3      
  274  3                              *ptrAdcMonitorCfg->faultFlag[adcVoltModeSts[adcIndex] - 1] = TRUE;
  275  3                      }
  276  2      
  277  2                      adcVoltModeStsLast[adcIndex] = adcVoltModeSts[adcIndex];
  278  2              }
  279  1      }
  280         
  281         
  282         //***************************************************************************************
  283         // @Function      FLTD_volModeType FLTD_GetAdcRangeType(FLTD_adcType adctype) 
  284         //---------------------------------------------------------------------------------------
  285         // @Description   Get the range of AD sampling value of each channel.
  286         //---------------------------------------------------------------------------------------
  287         // @Returnvalue   adcVoltModeSts: 
  288         //                                The range of AD values for a particular channel, In the following
  289         //                                FLTD_VOL_NORMAL,FLTD_VOL_STOP,FLTD_VOL_LOW,FLTD_VOL_HIGH.
  290         //---------------------------------------------------------------------------------------
  291         // @Parameters    adctype:
  292         //                                Enumeration of each AD channel.
  293         //---------------------------------------------------------------------------------------
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 6   

  294         // @Date          2019/11/7
  295         //***************************************************************************************
  296         FLTD_volModeType FLTD_GetAdcRangeType(FLTD_adcType adcType)
  297         {
  298  1              return adcVoltModeSts[adcType];
  299  1      }
  300         
  301         
  302         //***************************************************************************************
  303         // @Function      static void FLTD_PedalDetectCondigtJudge(void) 
  304         //---------------------------------------------------------------------------------------
  305         // @Description   Pedal signal abnormal detection needs to be combined with pedal switch signal.
  306         //---------------------------------------------------------------------------------------
  307         // @Returnvalue   None
  308         //---------------------------------------------------------------------------------------
  309         // @Parameters    None
  310         //---------------------------------------------------------------------------------------
  311         // @Date          2019/12/27
  312         //***************************************************************************************
  313         static void FLTD_PedalDetectCondigtJudge(void)
  314         {
  315  1              if((FALSE == g_inBrakeSwValidSts) && (TRUE == u8BrakeSwStsLast))/* brake from valid to invalid, set the p
             -edal return flag */
  316  1              {
  317  2                      bPedalReturnFlag = TRUE;
  318  2                      bPedalPushFlag = FALSE;
  319  2      
  320  2                      u16PedalReturnMinValue = 0xFFFF;
  321  2                      u16PedalInitLocMinValue = 0xFFFF;
  322  2              }
  323  1              else if((TRUE == g_inBrakeSwValidSts) && (FALSE == u8BrakeSwStsLast))/* brake from invalid to valid, set 
             -the pedal push flag */
  324  1              {
  325  2                      bPedalReturnFlag = FALSE;
  326  2                      bPedalPushFlag = TRUE;
  327  2      
  328  2                      u16PedalPushMaxValue = 0;
  329  2              }
  330  1              
  331  1              u8BrakeSwStsLast = g_inBrakeSwValidSts;
  332  1      }
  333         
  334         //***************************************************************************************
  335         // @Function      static void FLTD_PedalSigCheckErrorDetect(void) 
  336         //---------------------------------------------------------------------------------------
  337         // @Description   Pedal two - way signal calibration error detection.
  338         //---------------------------------------------------------------------------------------
  339         // @Returnvalue   None
  340         //---------------------------------------------------------------------------------------
  341         // @Parameters    None
  342         //---------------------------------------------------------------------------------------
  343         // @Date          2019/12/27
  344         //***************************************************************************************
  345         static void FLTD_PedalSigCheckErrorDetect(void)
  346         {
  347  1              const T_ADC *adcPtr = Adc_SampleData();
  348  1              static FLT_U16 u16PedalSignalCheckErrorCnt = 0;
  349  1              static FLT_U16 u16PedalSignalCheckNormalCnt = 0;
  350  1              
  351  1              FLT_U32 u32PedalCheckErrorUpper = 0;
  352  1              FLT_U32 u32PedalCheckErrorLower = 0;
  353  1      
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 7   

  354  1              /* If the pedal sensor power supply voltage is normal and the signal is not open, 
  355  1               * judge the calibration of two channel signals */
  356  1      
  357  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_VOLTAGE])
  358  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_SIG1]) 
  359  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_SIG2]))
  360  1              {
  361  2                      /* pedal sensor signal Check failure 
  362  2                      if((adcPtr->brakePedalTrip_Adc[0] > (2 * (1 + PEDAL_SIGNAL_CHECK_RANG) * adcPtr->brakePedalTrip_Adc[1]))
  363  2                              || (adcPtr->brakePedalTrip_Adc[0] < (2 * (1 - PEDAL_SIGNAL_CHECK_RANG) * adcPtr->brakePedalTrip_Adc[1])
             -))
  364  2                      {
  365  2                              u16PedalSignalCheckNormalCnt = 0;
  366  2                              if(u16PedalSignalCheckErrorCnt < PEDAL_SIGNAL_CHECK_FAILURE_TIME)
  367  2                              {
  368  2                                      u16PedalSignalCheckErrorCnt++;
  369  2                              }
  370  2                              else
  371  2                              {
  372  2                                      FLTD_fltFlg.pedalSensorCheckErrorFlg = TRUE;
  373  2                              }
  374  2                      }
  375  2                      */
  376  2                      
  377  2                      u32PedalCheckErrorUpper = (((100 + PEDAL_SIGNAL_CHECK_RANG) * (INT32U)adcPtr->brakePedalTrip_Adc[1]) + 2
             -5) / 50;
  378  2                      u32PedalCheckErrorLower = (((100 - PEDAL_SIGNAL_CHECK_RANG) * (INT32U)adcPtr->brakePedalTrip_Adc[1]) + 2
             -5) / 50;
  379  2                      
  380  2                      if((adcPtr->brakePedalTrip_Adc[0] > u32PedalCheckErrorUpper)
  381  2                              || (adcPtr->brakePedalTrip_Adc[0] < u32PedalCheckErrorLower))
  382  2                      {
  383  3                              u16PedalSignalCheckNormalCnt = 0;
  384  3                              if(u16PedalSignalCheckErrorCnt < PEDAL_SIGNAL_CHECK_FAILURE_TIME)
  385  3                              {
  386  4                                      u16PedalSignalCheckErrorCnt++;
  387  4                              }
  388  3                              else
  389  3                              {
  390  4                                      FLTD_fltFlg.pedalSensorCheckErrorFlg = TRUE;
  391  4                              }
  392  3                      }
  393  2                      else
  394  2                      {
  395  3                              u16PedalSignalCheckErrorCnt = 0;
  396  3                              if(u16PedalSignalCheckNormalCnt < PEDAL_SIGNAL_CHECK_FAILURE_TIME)
  397  3                              {
  398  4                                      u16PedalSignalCheckNormalCnt++;
  399  4                              }
  400  3                              else
  401  3                              {
  402  4                                      FLTD_fltFlg.pedalSensorCheckErrorFlg = FALSE;
  403  4                              }
  404  3                      }       
  405  2              }
  406  1              else
  407  1              {
  408  2                      u16PedalSignalCheckErrorCnt = 0;
  409  2                      u16PedalSignalCheckNormalCnt = 0;
  410  2              }
  411  1      }
  412         
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 8   

  413         
  414         //***************************************************************************************
  415         // @Function      static void FLTD_PedalInitLocAbnormalDetect(void) 
  416         //---------------------------------------------------------------------------------------
  417         // @Description   Pedal init location abnormal detection.
  418         //---------------------------------------------------------------------------------------
  419         // @Returnvalue   None
  420         //---------------------------------------------------------------------------------------
  421         // @Parameters    None
  422         //---------------------------------------------------------------------------------------
  423         // @Date          2019/12/27
  424         //***************************************************************************************
  425         static void FLTD_PedalInitLocAbnormalDetect(void)
  426         { 
  427  1              const T_ADC *adcPtr = Adc_SampleData();
  428  1              static FLT_U16 u16PedalInitLocDetectDelayCnt = 0;
  429  1              static FLT_U16 u16PedalInitLocAbnormalCnt = 0;
  430  1              static FLT_U16 u16PedalInitLocNormalCnt = 0;
  431  1              
  432  1              /* The brake pedal is not pressed,
  433  1               * 1) If the sample value after delay and the rated initial value are greater than a certain value, 
  434  1               * it is judged as the initial signal abnormal; */
  435  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_VOLTAGE])
  436  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_SIG1])
  437  1                      && (FALSE == g_inBrakeSwValidSts))
  438  1              {
  439  2                      /* Delay for a certain time.  */
  440  2                      if(u16PedalInitLocDetectDelayCnt < PEDAL_DETECT_DELAY_TIME)
  441  2                      {
  442  3                              u16PedalInitLocDetectDelayCnt++;
  443  3                              if(adcPtr->brakePedalTrip_Adc[0] < u16PedalInitLocMinValue)
  444  3                              {
  445  4                                      u16PedalInitLocMinValue = adcPtr->brakePedalTrip_Adc[0];
  446  4                              }
  447  3                      }
  448  2                      else
  449  2                      {
  450  3                              /* detect pedal init location abnormal */
  451  3                              if(ABSOLUTE(adcPtr->brakePedalTrip_Adc[0], gRTE_pedalInitValue[0]) > PEDAL_INIT_LOCATION_ABNORMAL_RANG)
  452  3                              {
  453  4                                      u16PedalInitLocNormalCnt = 0;
  454  4      
  455  4                                      if(u16PedalInitLocAbnormalCnt < PEDAL_INIT_LOCATION_ABNORMAL_TIME)
  456  4                                      {
  457  5                                              u16PedalInitLocAbnormalCnt++;
  458  5                                      }
  459  4                                      else
  460  4                                      {
  461  5                                              FLTD_fltFlg.pedalSensorInitAbnormalFlg = TRUE;
  462  5                                      }
  463  4                              }
  464  3                              else
  465  3                              {
  466  4                                      u16PedalInitLocAbnormalCnt = 0;
  467  4      
  468  4                                      if(u16PedalInitLocNormalCnt < PEDAL_INIT_LOCATION_ABNORMAL_TIME)
  469  4                                      {
  470  5                                              u16PedalInitLocNormalCnt++;
  471  5                                      }
  472  4                                      else
  473  4                                      {
  474  5                                              FLTD_fltFlg.pedalSensorInitAbnormalFlg = FALSE;
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 9   

  475  5                                      }
  476  4                              }
  477  3                      }       
  478  2              }
  479  1              else
  480  1              {
  481  2                      u16PedalInitLocDetectDelayCnt = 0;
  482  2                      u16PedalInitLocAbnormalCnt = 0;
  483  2                      u16PedalInitLocNormalCnt = 0;
  484  2              }
  485  1      }
  486         
  487         
  488         //***************************************************************************************
  489         // @Function      static void FLTD_PedalReturnAbnormalDetect(void) 
  490         //---------------------------------------------------------------------------------------
  491         // @Description   Pedal return to the init location abnormal detection.
  492         //---------------------------------------------------------------------------------------
  493         // @Returnvalue   None
  494         //---------------------------------------------------------------------------------------
  495         // @Parameters    None
  496         //---------------------------------------------------------------------------------------
  497         // @Date          2019/12/27
  498         //***************************************************************************************
  499         static void FLTD_PedalReturnAbnormalDetect(void)
  500         {
  501  1              const T_ADC *adcPtr = Adc_SampleData();
  502  1              static FLT_U16 u16PedalReturnDetectDelayCnt = 0;
  503  1              static FLT_U16 u16PedalReturnAbnormalCnt = 0;
  504  1              static FLT_U16 u16PedalReturnNormalCnt = 0;
  505  1              
  506  1              /* After the pedal switch signal from valid to invalid, that is after the back. 
  507  1               * 1) If the difference between the minimum value and the initial value is greater than a certain value, 
  508  1               * it is judged as return anomaly; */
  509  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_VOLTAGE])
  510  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_SIG1])
  511  1                      && (TRUE == bPedalReturnFlag))
  512  1              {
  513  2                      /* Delay for a certain time and record the minimum value of the signal.  */
  514  2                      if(u16PedalReturnDetectDelayCnt < PEDAL_DETECT_DELAY_TIME)
  515  2                      {
  516  3                              u16PedalReturnDetectDelayCnt++;
  517  3                              if(adcPtr->brakePedalTrip_Adc[0] < u16PedalReturnMinValue)
  518  3                              {
  519  4                                      u16PedalReturnMinValue = adcPtr->brakePedalTrip_Adc[0];
  520  4                              }
  521  3                      }
  522  2                      else
  523  2                      {
  524  3                              /* detect pedal return abnormal */
  525  3                              if(ABSOLUTE(u16PedalReturnMinValue, gRTE_pedalInitValue[0]) > PEDAL_RETURN_ABNORMAL_RANG)
  526  3                              {
  527  4                                      u16PedalReturnNormalCnt = 0;
  528  4                                      if(u16PedalReturnAbnormalCnt < PEDAL_RETURN_ABNORMAL_TIME)
  529  4                                      {
  530  5                                              u16PedalReturnAbnormalCnt++;
  531  5                                      }
  532  4                                      else
  533  4                                      {
  534  5                                              FLTD_fltFlg.pedalSensorReturnAbnormalFlg = TRUE;
  535  5                                      }
  536  4                              }
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 10  

  537  3                              else
  538  3                              {
  539  4                                      u16PedalReturnAbnormalCnt = 0;
  540  4                                      if(u16PedalReturnNormalCnt < PEDAL_RETURN_ABNORMAL_TIME)
  541  4                                      {
  542  5                                              u16PedalReturnNormalCnt++;
  543  5                                      }
  544  4                                      else
  545  4                                      {
  546  5                                              FLTD_fltFlg.pedalSensorReturnAbnormalFlg = FALSE;
  547  5                                      }
  548  4                              }
  549  3                      }
  550  2              }
  551  1              else
  552  1              {
  553  2                      u16PedalReturnDetectDelayCnt = 0;
  554  2                      u16PedalReturnAbnormalCnt = 0;
  555  2                      u16PedalReturnNormalCnt = 0;
  556  2              }
  557  1      }
  558         
  559         
  560         //***************************************************************************************
  561         // @Function      static void FLTD_PedalActionAbnormalDetect(void) 
  562         //---------------------------------------------------------------------------------------
  563         // @Description   Pedal action abnormal detection. According to the pedal down, 
  564         //                                      whether there is a significant change in the sample value
  565         //---------------------------------------------------------------------------------------
  566         // @Returnvalue   None
  567         //---------------------------------------------------------------------------------------
  568         // @Parameters    None
  569         //---------------------------------------------------------------------------------------
  570         // @Date          2019/12/27
  571         //***************************************************************************************
  572         static void FLTD_PedalActionAbnormalDetect(void)
  573         {
  574  1              const T_ADC *adcPtr = Adc_SampleData();
  575  1              static FLT_U16 u16PedalActionDetectDelayCnt = 0;
  576  1              static FLT_U16 u16PedalSignalNormalCnt = 0;
  577  1              static FLT_U16 u16PedalSignalAbnormalCnt = 0;
  578  1              
  579  1              /* Pedal switch signal from effective to invalid, judging the pedal is down. 
  580  1               * If the difference between the maximum value and the initial value is less than a certain value, 
  581  1               * it is judged as signal abnormal */
  582  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_VOLTAGE])
  583  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_SIG1])
  584  1                      && (TRUE == bPedalPushFlag))
  585  1              {
  586  2                      /* Delay for a certain time and record the maximum value of the signal.  */
  587  2                      if(u16PedalActionDetectDelayCnt < PEDAL_DETECT_DELAY_TIME)
  588  2                      {
  589  3                              u16PedalActionDetectDelayCnt++;
  590  3                              if(adcPtr->brakePedalTrip_Adc[0] > u16PedalPushMaxValue)
  591  3                              {
  592  4                                      u16PedalPushMaxValue = adcPtr->brakePedalTrip_Adc[0];
  593  4                              }
  594  3                      }
  595  2                      else
  596  2                      {
  597  3                              /* detect pedal signal abnormal */
  598  3                              if(ABSOLUTE(u16PedalPushMaxValue, gRTE_pedalInitValue[0]) < PEDAL_SIGNAL_ABNORMAL_RANG)
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 11  

  599  3                              {
  600  4                                      u16PedalSignalNormalCnt = 0;
  601  4                                      if(u16PedalSignalAbnormalCnt < PEDAL_SIGNAL_ABNORMAL_TIME)
  602  4                                      {
  603  5                                              u16PedalSignalAbnormalCnt++;
  604  5                                      }
  605  4                                      else
  606  4                                      {
  607  5                                              FLTD_fltFlg.pedalSensorSignalAbnormalFlg = TRUE;
  608  5                                      }
  609  4                              }
  610  3                              else
  611  3                              {
  612  4                                      u16PedalSignalAbnormalCnt = 0;
  613  4                                      if(u16PedalSignalNormalCnt < PEDAL_SIGNAL_ABNORMAL_TIME)
  614  4                                      {
  615  5                                              u16PedalSignalNormalCnt++;
  616  5                                      }
  617  4                                      else
  618  4                                      {
  619  5                                              FLTD_fltFlg.pedalSensorSignalAbnormalFlg = FALSE;
  620  5                                      }
  621  4                              }
  622  3                      }
  623  2              }
  624  1              else
  625  1              {
  626  2                      u16PedalActionDetectDelayCnt = 0;
  627  2                      u16PedalSignalNormalCnt = 0;
  628  2                      u16PedalSignalAbnormalCnt = 0;  
  629  2              }
  630  1      }
  631                 
  632         
  633         //***************************************************************************************
  634         // @Function      static void FLTD_CylinderSigCheckErrorDetect(void) 
  635         //---------------------------------------------------------------------------------------
  636         // @Description   Master cylinder two - way signal calibration error detection.
  637         //---------------------------------------------------------------------------------------
  638         // @Returnvalue   None
  639         //---------------------------------------------------------------------------------------
  640         // @Parameters    None
  641         //---------------------------------------------------------------------------------------
  642         // @Date          2019/12/27
  643         //***************************************************************************************
  644         static void FLTD_CylinderSigCheckErrorDetect(void)
  645         {
  646  1              const T_ADC *adcPtr = Adc_SampleData();
  647  1              static FLT_U16 u16CylinderSignalCheckErrorCnt = 0;
  648  1              static FLT_U16 u16CylinderSignalCheckNormalCnt = 0;
  649  1      
  650  1              FLT_U32 u32CylinderCheckErrorUpper = 0;
  651  1              FLT_U32 u32CylinderCheckErrorLower = 0;
  652  1              
  653  1              /* If the cylinder sensor power supply voltage is normal and the signal is not open, 
  654  1               * judge the calibration of two channel signals */
  655  1      
  656  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_VOLTAGE])
  657  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_SIG1]) 
  658  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_SIG2]))
  659  1              {
  660  2                      /* main cylinder sensor signal Check failure 
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 12  

  661  2                      if((adcPtr->mainCylinderTrip_Adc[0] > (2 * (1 + CYLINDER_SIGNAL_CHECK_RANG) * adcPtr->mainCylinderTrip_A
             -dc[1]))
  662  2                              || (adcPtr->mainCylinderTrip_Adc[0] < (2 * (1 - CYLINDER_SIGNAL_CHECK_RANG) * adcPtr->mainCylinderTrip_
             -Adc[1])))
  663  2                      {
  664  2                              u16CylinderSignalCheckNormalCnt = 0;
  665  2                              if(u16CylinderSignalCheckErrorCnt < CYLINDER_SIGNAL_CHECK_FAILURE_TIME)
  666  2                              {
  667  2                                      u16CylinderSignalCheckErrorCnt++;
  668  2                              }
  669  2                              else
  670  2                              {
  671  2                                      FLTD_fltFlg.cylinderSensorCheckErrorFlg = TRUE;
  672  2                              }
  673  2                      }
  674  2                      */
  675  2                      
  676  2                      u32CylinderCheckErrorUpper = (((100 + CYLINDER_SIGNAL_CHECK_RANG) * (INT32U)adcPtr->mainCylinderTrip_Adc
             -[1]) + 25) / 50;
  677  2                      u32CylinderCheckErrorLower = (((100 - CYLINDER_SIGNAL_CHECK_RANG) * (INT32U)adcPtr->mainCylinderTrip_Adc
             -[1]) + 25) / 50;
  678  2                      
  679  2                      
  680  2                      if((adcPtr->mainCylinderTrip_Adc[0] > u32CylinderCheckErrorUpper)
  681  2                              || (adcPtr->mainCylinderTrip_Adc[0] < u32CylinderCheckErrorLower))
  682  2                      {
  683  3                              u16CylinderSignalCheckNormalCnt = 0;
  684  3                              if(u16CylinderSignalCheckErrorCnt < CYLINDER_SIGNAL_CHECK_FAILURE_TIME)
  685  3                              {
  686  4                                      u16CylinderSignalCheckErrorCnt++;
  687  4                              }
  688  3                              else
  689  3                              {
  690  4                                      FLTD_fltFlg.cylinderSensorCheckErrorFlg = TRUE;
  691  4                              }
  692  3                      }
  693  2                      else
  694  2                      {
  695  3                              u16CylinderSignalCheckErrorCnt = 0;
  696  3                              if(u16CylinderSignalCheckNormalCnt < CYLINDER_SIGNAL_CHECK_FAILURE_TIME)
  697  3                              {
  698  4                                      u16CylinderSignalCheckNormalCnt++;
  699  4                              }
  700  3                              else
  701  3                              {
  702  4                                      FLTD_fltFlg.cylinderSensorCheckErrorFlg = FALSE;
  703  4                              }
  704  3                      }
  705  2              }
  706  1              else
  707  1              {
  708  2                      u16CylinderSignalCheckErrorCnt = 0;
  709  2                      u16CylinderSignalCheckNormalCnt = 0;
  710  2              }
  711  1      }
  712         
  713         //***************************************************************************************
  714         // @Function      static void FLTD_CylinderInitLocAbnormalDetect(void) 
  715         //---------------------------------------------------------------------------------------
  716         // @Description   Cylinder init location abnormal detection.
  717         //---------------------------------------------------------------------------------------
  718         // @Returnvalue   None
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 13  

  719         //---------------------------------------------------------------------------------------
  720         // @Parameters    None
  721         //---------------------------------------------------------------------------------------
  722         // @Date          2019/12/27
  723         //***************************************************************************************
  724         static void FLTD_CylinderInitLocAbnormalDetect(void)
  725         {
  726  1              const T_ADC *adcPtr = Adc_SampleData();
  727  1              const T_PWM* ptr_Pwm = Pwm_ControlData();
  728  1              static FLT_U16 u16CylinderInitSignalDetectDelayTimeCnt = 0;
  729  1              //variables defined to detect cylinder init location abnormal
  730  1              static FLT_U16 u16CylinderInitLocAbnormalCnt = 0;
  731  1              static FLT_U16 u16CylinderInitLocNormalCnt = 0;
  732  1              
  733  1              /* detect cylinder init signal abnormal.
  734  1               * The brake pedal is not pressed and there is no external brake request, 
  735  1               * if the difference between the cylinder signal and the initial signal is greater than a certain value, 
  736  1               * Judge as abnormal; Otherwise it is normal */
  737  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_VOLTAGE])
  738  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_SIG1])
  739  1                      && (FALSE == g_inBrakeSwValidSts)
  740  1                      && (PWM_AMPLITUDE_DEFAULT == ptr_Pwm->motorCtrl))
  741  1              {       
  742  2                      /* Delay for a certain time, waiting for motor action */
  743  2                      if(u16CylinderInitSignalDetectDelayTimeCnt < CYLINDER_DETECT_DELAY_TIME)
  744  2                      {
  745  3                              u16CylinderInitSignalDetectDelayTimeCnt++;
  746  3                              if(adcPtr->mainCylinderTrip_Adc[0] < u16CylinderReturnMinValue)
  747  3                              {
  748  4                                      u16CylinderReturnMinValue = adcPtr->mainCylinderTrip_Adc[0];
  749  4                              }
  750  3                      }
  751  2                      else
  752  2                      {
  753  3                              if(ABSOLUTE(adcPtr->mainCylinderTrip_Adc[0], gRTE_cylinderInitValue[0]) > CYLINDER_INIT_LOCATION_ABNORM
             -AL_RANG)
  754  3                              {
  755  4                                      u16CylinderInitLocNormalCnt = 0;
  756  4                                      if(u16CylinderInitLocAbnormalCnt < CYLINDER_INIT_LOCATION_ABNORMAL_TIME)
  757  4                                      {
  758  5                                              u16CylinderInitLocAbnormalCnt++;
  759  5                                      }
  760  4                                      else
  761  4                                      {
  762  5                                              FLTD_fltFlg.cylinderSensorInitAbnormalFlg = TRUE;
  763  5                                      }
  764  4                              }
  765  3                              else
  766  3                              {
  767  4                                      u16CylinderInitLocAbnormalCnt = 0;
  768  4                                      if(u16CylinderInitLocNormalCnt < CYLINDER_INIT_LOCATION_ABNORMAL_TIME)
  769  4                                      {
  770  5                                              u16CylinderInitLocNormalCnt++;
  771  5                                      }
  772  4                                      else
  773  4                                      {
  774  5                                              FLTD_fltFlg.cylinderSensorInitAbnormalFlg = FALSE;
  775  5                                      }
  776  4                              }
  777  3                      }
  778  2              }
  779  1              else
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 14  

  780  1              {
  781  2                      u16CylinderInitLocAbnormalCnt = 0;
  782  2                      u16CylinderInitLocNormalCnt = 0;
  783  2                      u16CylinderInitSignalDetectDelayTimeCnt = 0;
  784  2                      u16CylinderReturnMinValue = 0xFFFF;
  785  2              }
  786  1      }
  787         
  788         //***************************************************************************************
  789         // @Function      static void FLTD_CylinderSignalAbnormalDetect(void) 
  790         //---------------------------------------------------------------------------------------
  791         // @Description   Cylinder signal abnormal detection.
  792         //---------------------------------------------------------------------------------------
  793         // @Returnvalue   None
  794         //---------------------------------------------------------------------------------------
  795         // @Parameters    None
  796         //---------------------------------------------------------------------------------------
  797         // @Date          2019/12/27
  798         //***************************************************************************************
  799         static void FLTD_CylinderSignalAbnormalDetect(void)
  800         {
  801  1              const T_ADC *adcPtr = Adc_SampleData();
  802  1              const T_PWM* ptr_Pwm = Pwm_ControlData();
  803  1              static FLT_U16 u16CylinderSignalDetectDelayTimeCnt = 0;
  804  1      
  805  1              //variables defined to detect cylinder signal abnormal
  806  1              static FLT_U16 u16CylinderSignalAbnormalCnt = 0;
  807  1              static FLT_U16 u16CylinderSignalNormalCnt = 0;  
  808  1      
  809  1              
  810  1              /* detect cylinder signal abnormal.
  811  1               * When A certain control quantity is reached, that is, the duty cycle difference of A and B phase reache
             -s A certain value,
  812  1               * The deviation between the master cylinder position and the initial position is less than a certain val
             -ue,
  813  1               * judge the signal anomaly of the master cylinder*/
  814  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_VOLTAGE])
  815  1                      && (FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_SIG1])
  816  1                      && (FALSE == FLTD_fltFlg.motorOpenFlg)
  817  1                      && (ptr_Pwm->motorCtrl > PWM_AMPLITUDE_DEFAULT)
  818  1                      && ((ptr_Pwm->motorCtrl - PWM_AMPLITUDE_DEFAULT) > CYLINDER_SIGNAL_ABNORMAL_CTRL_THRESHOLD))
  819  1              {
  820  2                      /* Delay for a certain time, waiting for motor action */
  821  2                      if(u16CylinderSignalDetectDelayTimeCnt < CYLINDER_DETECT_DELAY_TIME)
  822  2                      {
  823  3                              u16CylinderSignalDetectDelayTimeCnt++;
  824  3                              if(adcPtr->mainCylinderTrip_Adc[0] > u16CylinderPushMaxValue)
  825  3                              {
  826  4                                      u16CylinderPushMaxValue = adcPtr->mainCylinderTrip_Adc[0];
  827  4                              }
  828  3                      }
  829  2                      else
  830  2                      {
  831  3                              if(ABSOLUTE(u16CylinderPushMaxValue, gRTE_cylinderInitValue[0]) < CYLINDER_SIGNAL_ABNORMAL_RANG)
  832  3                              {
  833  4                                      u16CylinderSignalNormalCnt = 0;
  834  4                                      if(u16CylinderSignalAbnormalCnt < CYLINDER_SIGNAL_ABNORMAL_TIME)
  835  4                                      {
  836  5                                              u16CylinderSignalAbnormalCnt++;
  837  5                                      }
  838  4                                      else
  839  4                                      {
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 15  

  840  5                                              FLTD_fltFlg.cylinderSensorSignalAbnormalFlg = TRUE;
  841  5                                      }
  842  4                              }
  843  3                              else
  844  3                              {
  845  4                                      u16CylinderSignalAbnormalCnt = 0;
  846  4                                      if(u16CylinderSignalNormalCnt < CYLINDER_SIGNAL_ABNORMAL_TIME)
  847  4                                      {
  848  5                                              u16CylinderSignalNormalCnt++;
  849  5                                      }
  850  4                                      else
  851  4                                      {
  852  5                                              FLTD_fltFlg.cylinderSensorSignalAbnormalFlg = FALSE;
  853  5                                      }
  854  4                              }
  855  3                      }
  856  2              }
  857  1              else
  858  1              {
  859  2                      u16CylinderSignalAbnormalCnt = 0;
  860  2                      u16CylinderSignalNormalCnt = 0;
  861  2                      u16CylinderSignalDetectDelayTimeCnt = 0;
  862  2                      u16CylinderPushMaxValue = 0u;
  863  2              }
  864  1      }
  865         
  866         
  867         //***************************************************************************************
  868         // @Function      static void FLTD_VlinkVoltageAbnormalDetect(void) 
  869         //---------------------------------------------------------------------------------------
  870         // @Description   Motor vlink voltage abnormal detection.
  871         //---------------------------------------------------------------------------------------
  872         // @Returnvalue   None
  873         //---------------------------------------------------------------------------------------
  874         // @Parameters    None
  875         //---------------------------------------------------------------------------------------
  876         // @Date          2019/12/27
  877         //***************************************************************************************
  878         static void FLTD_VlinkVoltageAbnormalDetect(void)
  879         {
  880  1              const T_ADC *adcPtr = Adc_SampleData();
  881  1      
  882  1              //variables defined to detect vlink voltage fault
  883  1              static FLT_U16 u16VlinkVoltageHighCnt = 0;
  884  1              static FLT_U16 u16VlinkVoltageLowCnt = 0;
  885  1              static FLT_U16 u16VlinkVoltageNormalCnt = 0;
  886  1              
  887  1              /* Vlink voltage abnormal. 
  888  1               * The sample value of vlink is compared with the sample value of power supply voltage 
  889  1               * to judge the high and low vlink voltage */
  890  1              if(FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_ECU_VOLTAGE])
  891  1              {
  892  2                      if(adcPtr->motorVLinkVoltage_Adc > (adcPtr->powerVoltage_Adc + VLINK_VOLTAGE_ABNORMAL_RANG)) /* vlink vo
             -ltage too high */
  893  2                      {
  894  3                              u16VlinkVoltageLowCnt = 0;
  895  3                              u16VlinkVoltageNormalCnt = 0;
  896  3                              
  897  3                              if(u16VlinkVoltageHighCnt <= VLINK_VOLTAGE_ABNORMAL_TIME)
  898  3                              {
  899  4                                      u16VlinkVoltageHighCnt++;
  900  4                              }
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 16  

  901  3                              else
  902  3                              {
  903  4                                      FLTD_fltFlg.motorVlinkVolHighFlg = TRUE;
  904  4                              }
  905  3                      }
  906  2                      else if(adcPtr->motorVLinkVoltage_Adc < (adcPtr->powerVoltage_Adc - VLINK_VOLTAGE_ABNORMAL_RANG)) /* vli
             -nk voltage too low */
  907  2                      {
  908  3                              u16VlinkVoltageHighCnt = 0;
  909  3                              u16VlinkVoltageNormalCnt = 0;
  910  3                              
  911  3                              if(u16VlinkVoltageLowCnt <= VLINK_VOLTAGE_ABNORMAL_TIME)
  912  3                              {
  913  4                                      u16VlinkVoltageLowCnt++;
  914  4                              }
  915  3                              else
  916  3                              {
  917  4                                      FLTD_fltFlg.motorVlinkVolLowFlg = TRUE;
  918  4                              }
  919  3                      }
  920  2                      else /* vlink voltage normal */
  921  2                      {
  922  3                              u16VlinkVoltageHighCnt = 0;
  923  3                              u16VlinkVoltageLowCnt = 0;
  924  3      
  925  3                              if(u16VlinkVoltageNormalCnt <= VLINK_VOLTAGE_ABNORMAL_TIME)
  926  3                              {
  927  4                                      u16VlinkVoltageNormalCnt++;
  928  4                              }
  929  3                              else
  930  3                              {
  931  4                                      FLTD_fltFlg.motorVlinkVolHighFlg = FALSE;
  932  4                                      FLTD_fltFlg.motorVlinkVolLowFlg = FALSE;
  933  4                              }
  934  3                      }
  935  2              }
  936  1              else
  937  1              {
  938  2                      u16VlinkVoltageHighCnt = 0;
  939  2                      u16VlinkVoltageLowCnt = 0;
  940  2                      u16VlinkVoltageNormalCnt = 0;
  941  2              }
  942  1      }
  943         
  944         //***************************************************************************************
  945         // @Function      static void FLTD_CurrentInitSigAbnormalDetect(void) 
  946         //---------------------------------------------------------------------------------------
  947         // @Description   Current init signal abnormal detection.
  948         //---------------------------------------------------------------------------------------
  949         // @Returnvalue   None
  950         //---------------------------------------------------------------------------------------
  951         // @Parameters    None
  952         //---------------------------------------------------------------------------------------
  953         // @Date          2019/12/27
  954         //***************************************************************************************
  955         static void FLTD_CurrentInitSigAbnormalDetect(void)
  956         {
  957  1              const T_ADC *adcPtr = Adc_SampleData();
  958  1              const T_PWM* ptr_Pwm = Pwm_ControlData();
  959  1              //variables defined to detect current init signal abnormal
  960  1              static FLT_U16 u16CurrentInitSignalDetectDelayTimeCnt = 0;
  961  1              static FLT_U16 u16CurrentInitSignalAbnormalCnt = 0;
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 17  

  962  1              static FLT_U16 u16CurrentInitSignalNormalCnt = 0;
  963  1              static FLT_U16 u16CurrentSigMinValue = 0xFFFF;
  964  1      
  965  1              
  966  1              /* detect current init signal abnormal.
  967  1               * When there is no control quantity, if the difference between the current signal 
  968  1               * and the initial signal is greater than a certain value, 
  969  1               * Judge as abnormal; Otherwise it is normal */
  970  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_CURRENT_SENSOR_SIG])
  971  1                      //&& ((FALSE == g_inBrakeSwValidSts) || (WireCtrlBrakeMode == BrakeSysMode)) //muYuan
  972  1                      && (PWM_AMPLITUDE_DEFAULT == ptr_Pwm->motorCtrl))
  973  1              {
  974  2                      /* Delay for a certain time, waiting for motor action */
  975  2                      if(u16CurrentInitSignalDetectDelayTimeCnt < CURRENT_SIGNAL_DELAY_TIME)
  976  2                      {
  977  3                              u16CurrentInitSignalDetectDelayTimeCnt++;
  978  3                              if(adcPtr->motorCurrent_Adc < u16CurrentSigMinValue)
  979  3                              {
  980  4                                      u16CurrentSigMinValue = adcPtr->motorCurrent_Adc;
  981  4                              }
  982  3                      }
  983  2                      else
  984  2                      {
  985  3                              if(ABSOLUTE(adcPtr->motorCurrent_Adc, MOTOR_CURRENT_THRESHOLD) > CURRENT_INIT_SIGNAL_ABNORMAL_RANG)
  986  3                              {
  987  4                                      u16CurrentInitSignalNormalCnt = 0;
  988  4                                      if(u16CurrentInitSignalAbnormalCnt < CURRENT_INIT_SIGNAL_ABNORMAL_TIME)
  989  4                                      {
  990  5                                              u16CurrentInitSignalAbnormalCnt++;
  991  5                                      }
  992  4                                      else
  993  4                                      {
  994  5                                              FLTD_fltFlg.currentSensorAbnormalFlg = TRUE;
  995  5                                      }
  996  4                              }
  997  3                              else
  998  3                              {
  999  4                                      u16CurrentInitSignalAbnormalCnt = 0;
 1000  4                                      if(u16CurrentInitSignalNormalCnt < CURRENT_INIT_SIGNAL_ABNORMAL_TIME)
 1001  4                                      {
 1002  5                                              u16CurrentInitSignalNormalCnt++;
 1003  5                                      }
 1004  4                                      else
 1005  4                                      {
 1006  5                                              FLTD_fltFlg.currentSensorAbnormalFlg = FALSE;
 1007  5                                      }
 1008  4                              }
 1009  3                      }
 1010  2              }
 1011  1              else
 1012  1              {
 1013  2                      u16CurrentInitSignalDetectDelayTimeCnt = 0;
 1014  2                      u16CurrentInitSignalAbnormalCnt = 0;
 1015  2                      u16CurrentInitSignalNormalCnt = 0;
 1016  2                      u16CurrentSigMinValue = 0xFFFF;
 1017  2              }
 1018  1      }
 1019         
 1020         //***************************************************************************************
 1021         // @Function      static void FLTD_PredriverFaultDetect(void) 
 1022         //---------------------------------------------------------------------------------------
 1023         // @Description   Motor pre-drive fault detection.
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 18  

 1024         //---------------------------------------------------------------------------------------
 1025         // @Returnvalue   None
 1026         //---------------------------------------------------------------------------------------
 1027         // @Parameters    None
 1028         //---------------------------------------------------------------------------------------
 1029         // @Date          2019/12/27
 1030         //***************************************************************************************
 1031         static void FLTD_PredriverFaultDetect(void)
 1032         {
 1033  1              //variables defined to detect pre Driver fault
 1034  1              static FLT_U16 u16PredriverDetectWaitTimeCnt = PREDRIVER_FAULT_DELAY_TIME;      
 1035  1              static FLT_U16 u16PredriveFaultTimeCnt = 0;
 1036  1              static FLT_U16 u16PredriveRecoverTimeCnt = 0;
 1037  1              static FLT_U8 u8PredriveFaultCnt = 0;
 1038  1              static FLT_BOOL bResetFlag = FALSE;
 1039  1              
 1040  1              /* detect predriver fault. 
 1041  1               * 1) When the detection level of predrive is low, After meeting the time requirement, 
 1042  1               * reset the predrive, and retest the interval at 200ms with a maximum of 3 times reset. 
 1043  1               * if it is still low, the fault is judged: 
 1044  1               * 2) If the level is high enough to meet the time requirement, it is considered normal */
 1045  1              if((FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_ECU_VOLTAGE])
 1046  1                      && (FALSE == FLTD_fltFlg.motorVlinkVolHighFlg)
 1047  1                      && ((FALSE == FLTD_fltFlg.motorVlinkVolLowFlg)))
 1048  1              {
 1049  2                      if(u16PredriverDetectWaitTimeCnt < PREDRIVER_FAULT_DELAY_TIME)
 1050  2                      {
 1051  3                              u16PredriverDetectWaitTimeCnt++;
 1052  3                              
 1053  3                              if(TRUE == bResetFlag)
 1054  3                              {
 1055  4                                      bResetFlag = FALSE;
 1056  4                                      IO_vSetPin(IO_P0_7); /* open pre driver */
 1057  4                              }
 1058  3                      }
 1059  2                      else
 1060  2                      {
 1061  3                              if(0 == g_inPreDriverErrorSts) /* fault */
 1062  3                              {
 1063  4                                      u16PredriveRecoverTimeCnt = 0;
 1064  4                                      
 1065  4                                      if(u16PredriveFaultTimeCnt < PREDRIVER_FAULT_TIME)
 1066  4                                      {
 1067  5                                              u16PredriveFaultTimeCnt++;
 1068  5                                      }
 1069  4                                      else
 1070  4                                      {
 1071  5                                              if(u8PredriveFaultCnt < PREDRIVER_RESET_COUNT)
 1072  5                                              {
 1073  6                                                      u8PredriveFaultCnt++;
 1074  6                                                      
 1075  6                                                      IO_vResetPin(IO_P0_7); /* close pre driver */
 1076  6                                                      bResetFlag = TRUE;
 1077  6                                                      u16PredriveFaultTimeCnt = 0;
 1078  6                                                      u16PredriverDetectWaitTimeCnt = 0;
 1079  6                                              }
 1080  5                                              else
 1081  5                                              {
 1082  6                                                      FLTD_fltFlg.motorPredriveFaultFlg = TRUE;
 1083  6                                              }
 1084  5                                      }
 1085  4                              }
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 19  

 1086  3                              else /* normal */
 1087  3                              {
 1088  4                                      u16PredriveFaultTimeCnt = 0;
 1089  4      
 1090  4                                      if(u16PredriveRecoverTimeCnt < PREDRIVER_FAULT_TIME)
 1091  4                                      {
 1092  5                                              u16PredriveRecoverTimeCnt++;
 1093  5                                      }
 1094  4                                      else
 1095  4                                      {
 1096  5                                              FLTD_fltFlg.motorPredriveFaultFlg = FALSE;
 1097  5      
 1098  5                                              u8PredriveFaultCnt = 0;
 1099  5                                              u16PredriverDetectWaitTimeCnt = PREDRIVER_FAULT_DELAY_TIME;
 1100  5                                      }
 1101  4                              }
 1102  3                      }               
 1103  2              }
 1104  1              else
 1105  1              {
 1106  2                      u16PredriverDetectWaitTimeCnt = 0;      
 1107  2                      u16PredriveFaultTimeCnt = 0;
 1108  2                      u16PredriveRecoverTimeCnt = 0;
 1109  2                      u8PredriveFaultCnt = 0;
 1110  2              }
 1111  1      }
 1112         
 1113         //***************************************************************************************
 1114         // @Function      static void FLTD_MotorFaultDetect(void) 
 1115         //---------------------------------------------------------------------------------------
 1116         // @Description   Motor open circuit and short circuit fault detection.
 1117         //---------------------------------------------------------------------------------------
 1118         // @Returnvalue   None
 1119         //---------------------------------------------------------------------------------------
 1120         // @Parameters    None
 1121         //---------------------------------------------------------------------------------------
 1122         // @Date          2019/12/27
 1123         //***************************************************************************************
 1124         static void FLTD_MotorFaultDetect(void)
 1125         {
 1126  1              const T_ADC_APP *ptr_adcApp = AdcApp_SampleData();
 1127  1              const T_PWM* ptr_Pwm = Pwm_ControlData();
 1128  1              //variables defined to detect motor current fault
 1129  1              static FLT_U16 u16MotorOpenFaultTimeCnt = 0;
 1130  1              static FLT_U16 u16MotorOpenRecoverTimeCnt = 0;
 1131  1              static FLT_U16 u16MotorShortFaultTimeCnt = 0;
 1132  1              static FLT_U16 u16MotorShortRecoverTimeCnt = 0;
 1133  1              
 1134  1              /* detect Motor fault.
 1135  1               * When a certain control quantity is reached, 
 1136  1               * Judge whether the motor is open or short according to the current */
 1137  1              if(FLTD_VOL_NORMAL == adcVoltModeSts[FLTD_ADC_CURRENT_SENSOR_SIG])
 1138  1              {
 1139  2                      if((ptr_Pwm->motorCtrl > PWM_AMPLITUDE_DEFAULT)
 1140  2                              && ((ptr_Pwm->motorCtrl - PWM_AMPLITUDE_DEFAULT) > MOTOR_OPEN_CTRL_THRESHOLD))
 1141  2                      {
 1142  3                              /* motor open fault */
 1143  3                              if(ptr_adcApp->brakeMotorCurrent < MOTOR_CURRENT_OPEN_THRESHOLD)                        
 1144  3                              {
 1145  4                                      u16MotorOpenRecoverTimeCnt = 0;
 1146  4                                      if(u16MotorOpenFaultTimeCnt < MOTOR_CURRENT_OPEN_TIME)
 1147  4                                      {
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 20  

 1148  5                                              u16MotorOpenFaultTimeCnt++;
 1149  5                                      }
 1150  4                                      else
 1151  4                                      {
 1152  5                                              FLTD_fltFlg.motorOpenFlg = TRUE;
 1153  5                                      }
 1154  4                              }
 1155  3                              else
 1156  3                              {
 1157  4                                      u16MotorOpenFaultTimeCnt = 0;
 1158  4                                      if(u16MotorOpenRecoverTimeCnt < MOTOR_CURRENT_OPEN_TIME)
 1159  4                                      {
 1160  5                                              u16MotorOpenRecoverTimeCnt++;
 1161  5                                      }
 1162  4                                      else
 1163  4                                      {
 1164  5                                              FLTD_fltFlg.motorOpenFlg = FALSE;
 1165  5                                      }       
 1166  4                              }
 1167  3                      }
 1168  2                      else
 1169  2                      {
 1170  3                              u16MotorOpenFaultTimeCnt = 0;
 1171  3                              u16MotorOpenRecoverTimeCnt = 0;
 1172  3                      }
 1173  2      
 1174  2                      
 1175  2                      /* motor short fault */
 1176  2                      if(ptr_adcApp->brakeMotorCurrent > MOTOR_CURRENT_SHORT_THRESHOLD)
 1177  2                      {
 1178  3                              u16MotorShortRecoverTimeCnt = 0;
 1179  3                              if(u16MotorShortFaultTimeCnt < MOTOR_CURRENT_SHORT_TIME)
 1180  3                              {
 1181  4                                      u16MotorShortFaultTimeCnt++;
 1182  4                              }
 1183  3                              else
 1184  3                              {
 1185  4                                      FLTD_fltFlg.motorShortFlg = TRUE;
 1186  4                              }
 1187  3                      }
 1188  2                      else
 1189  2                      {
 1190  3                              u16MotorShortFaultTimeCnt = 0;
 1191  3                              if(u16MotorShortRecoverTimeCnt < MOTOR_CURRENT_SHORT_TIME)
 1192  3                              {
 1193  4                                      u16MotorShortRecoverTimeCnt++;
 1194  4                              }
 1195  3                              else
 1196  3                              {
 1197  4                                      FLTD_fltFlg.motorShortFlg = FALSE;
 1198  4                              }
 1199  3                      }       
 1200  2              }
 1201  1              else
 1202  1              {
 1203  2                      u16MotorOpenFaultTimeCnt = 0;
 1204  2                      u16MotorOpenRecoverTimeCnt = 0;
 1205  2                      u16MotorShortFaultTimeCnt = 0;
 1206  2                      u16MotorShortRecoverTimeCnt = 0;
 1207  2              }
 1208  1      }
 1209         
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 21  

 1210         
 1211         //***************************************************************************************
 1212         // @Function      static FLT_BOOL FLTD_GetAdcCondition(FLTD_adcType adcIndex) 
 1213         //---------------------------------------------------------------------------------------
 1214         // @Description   Gets whether the AD sample value detection condition are meet. 
 1215         //---------------------------------------------------------------------------------------
 1216         // @Returnvalue   adcIndex:
 1217         //                                              adc sampling channel
 1218         //---------------------------------------------------------------------------------------
 1219         // @Parameters    TRUE  : detect conditions meet
 1220         //                                FALSE : detect conditions not meet
 1221         //---------------------------------------------------------------------------------------
 1222         // @Date          2019/12/27
 1223         //***************************************************************************************
 1224         static FLT_BOOL FLTD_GetAdcCondition(FLTD_adcType adcIndex)
 1225         {       
 1226  1              const T_BOOSTER* ptr_booster = Booster_AlogrithmData();
 1227  1      
 1228  1              switch(adcIndex)
 1229  1              {
 1230  2                      case FLTD_ADC_ECU_VOLTAGE:
 1231  2                      {
 1232  3                              if(ptr_booster->cylinderRate < -20)
 1233  3                              {
 1234  4                                      return FALSE;
 1235  4                              }
 1236  3                              break;
 1237  3                      }
 1238  2                      
 1239  2                      case FLTD_ADC_ENV_TEMPERATURE:
 1240  2                      {
 1241  3                              break;
 1242  3                      }
 1243  2                      
 1244  2                      case FLTD_ADC_PEDAL_SENSOR_VOLTAGE:
 1245  2                      {
 1246  3                              break;
 1247  3                      }
 1248  2                      
 1249  2                      case FLTD_ADC_PEDAL_SENSOR_SIG1:
 1250  2                      case FLTD_ADC_PEDAL_SENSOR_SIG2:
 1251  2                      {
 1252  3                              if(FLTD_VOL_NORMAL != adcVoltModeSts[FLTD_ADC_PEDAL_SENSOR_VOLTAGE])
 1253  3                              {
 1254  4                                      return FALSE;
 1255  4                              }
 1256  3                              break;
 1257  3                      }
 1258  2                      
 1259  2                      case FLTD_ADC_MAIN_CYLINDER_VOLTAGE:
 1260  2                      {
 1261  3                              break;
 1262  3                      }
 1263  2                      
 1264  2                      case FLTD_ADC_MAIN_CYLINDER_SIG1:
 1265  2                      case FLTD_ADC_MAIN_CYLINDER_SIG2:
 1266  2                      {
 1267  3                              if(FLTD_VOL_NORMAL != adcVoltModeSts[FLTD_ADC_MAIN_CYLINDER_VOLTAGE])
 1268  3                              {
 1269  4                                      return FALSE;
 1270  4                              }
 1271  3                              break;
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 22  

 1272  3                      }
 1273  2                      
 1274  2                      case FLTD_ADC_CURRENT_SENSOR_SIG:
 1275  2                      {
 1276  3                              break;
 1277  3                      }
 1278  2                      
 1279  2                      default:
 1280  2                              break;
 1281  2              }
 1282  1      
 1283  1              return TRUE;
 1284  1      }
 1285         
 1286         
 1287         //***************************************************************************************
 1288         // @Function      static void FLTD_FaultActionHandle(void) 
 1289         //---------------------------------------------------------------------------------------
 1290         // @Description   Fault handling function. Set different processing marks according to 
 1291         //                                      different fault types for upper-layer applications. 
 1292         //---------------------------------------------------------------------------------------
 1293         // @Returnvalue   None
 1294         //---------------------------------------------------------------------------------------
 1295         // @Parameters    None
 1296         //---------------------------------------------------------------------------------------
 1297         // @Date          2019/12/27
 1298         //***************************************************************************************
 1299         static void FLTD_FaultActionHandle(void)
 1300         {
 1301  1              /* close predriver */
 1302  1              if((TRUE == FLTD_fltFlg.ecuVoltageHighFlg)
 1303  1                      || (TRUE == FLTD_fltFlg.motorShortFlg)
 1304  1                      || (TRUE == FLTD_fltFlg.motorPredriveFaultFlg))
 1305  1              {
 1306  2                      FLTD_fltActFlg.closePredriverFlg = TRUE;
 1307  2              }
 1308  1              else
 1309  1              {
 1310  2                      FLTD_fltActFlg.closePredriverFlg = FALSE;
 1311  2              }
 1312  1      
 1313  1              /* close main relay */
 1314  1              if((TRUE == FLTD_fltFlg.ecuVoltageHighFlg)
 1315  1                      || (TRUE == FLTD_fltFlg.motorVlinkVolHighFlg)
 1316  1                      || (TRUE == FLTD_fltFlg.motorVlinkVolLowFlg))
 1317  1              {
 1318  2                      FLTD_fltActFlg.closeMainRelayFlg = TRUE;
 1319  2              }
 1320  1              else
 1321  1              {
 1322  2                      FLTD_fltActFlg.closeMainRelayFlg = FALSE;
 1323  2              }
 1324  1      
 1325  1              /* close pedal sensor power */
 1326  1              if((TRUE == FLTD_fltFlg.ecuVoltageHighFlg)
 1327  1                      || (TRUE == FLTD_fltFlg.pedalSensorVoltageHighFlg)
 1328  1                      || (TRUE == FLTD_fltFlg.pedalSensorVoltageLowFlg)
 1329  1                      || (TRUE == FLTD_fltFlg.pedalSensorShortFlg))
 1330  1              {
 1331  2                      FLTD_fltActFlg.closePedalPowerFlg = TRUE;
 1332  2              }
 1333  1              else
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 23  

 1334  1              {
 1335  2                      FLTD_fltActFlg.closePedalPowerFlg = FALSE;
 1336  2              }
 1337  1      
 1338  1              /* close cylinder sensor power */
 1339  1              if((TRUE == FLTD_fltFlg.ecuVoltageHighFlg)
 1340  1                      || (TRUE == FLTD_fltFlg.cylinderSensorVolHighFlg)
 1341  1                      || (TRUE == FLTD_fltFlg.cylinderSensorVolLowFlg)
 1342  1                      || (TRUE == FLTD_fltFlg.cylinderSensorShortFlg))
 1343  1              {
 1344  2                      FLTD_fltActFlg.closeCylinderPowerFlg = TRUE;
 1345  2              }
 1346  1              else
 1347  1              {
 1348  2                      FLTD_fltActFlg.closeCylinderPowerFlg = FALSE;
 1349  2              }
 1350  1      
 1351  1      
 1352  1              /* braking Depends On Current */
 1353  1              if((TRUE == FLTD_fltFlg.cylinderSensorVolHighFlg)
 1354  1                      || (TRUE == FLTD_fltFlg.cylinderSensorVolLowFlg)
 1355  1                      || (TRUE == FLTD_fltFlg.cylinderSensorShortFlg)
 1356  1                      || (TRUE == FLTD_fltFlg.cylinderSensor1OpenFlg)
 1357  1                      || (TRUE == FLTD_fltFlg.cylinderSensor1OverRangFlg)
 1358  1              //      || (TRUE == FLTD_fltFlg.cylinderSensor2OpenFlg)
 1359  1              //      || (TRUE == FLTD_fltFlg.cylinderSensor2OverRangFlg)
 1360  1              //      || (TRUE == FLTD_fltFlg.cylinderSensorCheckErrorFlg)
 1361  1              //      || (TRUE == FLTD_fltFlg.cylinderSensorInitAbnormalFlg)
 1362  1              //      || (TRUE == FLTD_fltFlg.cylinderSensorSignalAbnormalFlg)
 1363  1              )
 1364  1              {
 1365  2                      FLTD_fltActFlg.brakingDependsOnCurrentFlg = TRUE;
 1366  2              }
 1367  1              else
 1368  1              {
 1369  2                      FLTD_fltActFlg.brakingDependsOnCurrentFlg = FALSE;
 1370  2              }
 1371  1      
 1372  1              /* braking Depends On Cylinder */
 1373  1              if((TRUE == FLTD_fltFlg.currentSensorOverRangFlg)
 1374  1                      || (TRUE == FLTD_fltFlg.currentSensorAbnormalFlg))
 1375  1              {
 1376  2                      FLTD_fltActFlg.brakingDependsOnCylinderFlg = TRUE;
 1377  2              }
 1378  1              else
 1379  1              {
 1380  2                      FLTD_fltActFlg.brakingDependsOnCylinderFlg = FALSE;
 1381  2              }
 1382  1              
 1383  1              
 1384  1              /* fixed Deceleration */
 1385  1              if(BoosterBrakeMode == BrakeSysMode)
 1386  1              {
 1387  2                      if((TRUE == FLTD_fltFlg.pedalSensorVoltageHighFlg)
 1388  2                              || (TRUE == FLTD_fltFlg.pedalSensorVoltageLowFlg)
 1389  2                              || (TRUE == FLTD_fltFlg.pedalSensorShortFlg)
 1390  2                              || (TRUE == FLTD_fltFlg.pedalSensor1OpenFlg)
 1391  2                              || (TRUE == FLTD_fltFlg.pedalSensor1OverRangFlg)
 1392  2                      //      || (TRUE == FLTD_fltFlg.pedalSensor2OpenFlg)
 1393  2                      //      || (TRUE == FLTD_fltFlg.pedalSensor2OverRangFlg)
 1394  2                      //      || (TRUE == FLTD_fltFlg.pedalSensorCheckErrorFlg)
 1395  2                      //      || (TRUE == FLTD_fltFlg.pedalSensorInitAbnormalFlg)
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 24  

 1396  2                      //      || (TRUE == FLTD_fltFlg.pedalSensorSignalAbnormalFlg)
 1397  2                      //      || (TRUE == FLTD_fltFlg.pedalSensorReturnAbnormalFlg)
 1398  2                      )
 1399  2                      {
 1400  3                              FLTD_fltActFlg.fixedDecelerationFlg = TRUE;
 1401  3                      }
 1402  2                      else
 1403  2                      {
 1404  3                              FLTD_fltActFlg.fixedDecelerationFlg = FALSE;
 1405  3                      }
 1406  2              }
 1407  1              else if(WireCtrlBrakeMode == BrakeSysMode)
 1408  1              {
 1409  2      #if 0
                              if((TRUE == FLTD_fltActFlg.brakingDependsOnCurrentFlg) //cylinder sensor fault
                                      && (TRUE == FLTD_fltActFlg.brakingDependsOnCylinderFlg) //current sensor fault
                              )
              #else
 1414  2                      if(TRUE == FLTD_fltActFlg.brakingDependsOnCylinderFlg) //current sensor fault
 1415  2      #endif
 1416  2                      {
 1417  3                              FLTD_fltActFlg.fixedDecelerationFlg = TRUE;
 1418  3                      }
 1419  2                      else
 1420  2                      {
 1421  3                              FLTD_fltActFlg.fixedDecelerationFlg = FALSE;
 1422  3                      }
 1423  2              }       
 1424  1      }
 1425         
 1426         
 1427         
 1428         const FLTD_faultFlagType* FLTD_FltFlgData(void)
 1429         {
 1430  1              return (&FLTD_fltFlg);
 1431  1      }
 1432         
 1433         //***************************************************************************************
 1434         // @Function      const FLTD_faultActType* FLTD_FltActFlgData(void) 
 1435         //---------------------------------------------------------------------------------------
 1436         // @Description   Fault action interface.  
 1437         //---------------------------------------------------------------------------------------
 1438         // @Returnvalue   fault action structure access address
 1439         //---------------------------------------------------------------------------------------
 1440         // @Parameters    None
 1441         //---------------------------------------------------------------------------------------
 1442         // @Date          2019/12/27
 1443         //***************************************************************************************
 1444         const FLTD_faultActType* FLTD_FltActFlgData(void)
 1445         {
 1446  1              return (&FLTD_fltActFlg);
 1447  1      }
 1448         
*** WARNING C174 IN LINE 499 OF src\app\diagnostic\FLTD.c: 'FLTD_PedalReturnAbnormalDetect': unreferenced 'static' funct
             -ion
*** WARNING C174 IN LINE 724 OF src\app\diagnostic\FLTD.c: 'FLTD_CylinderInitLocAbnormalDetect': unreferenced 'static' f
             -unction
*** WARNING C174 IN LINE 313 OF src\app\diagnostic\FLTD.c: 'FLTD_PedalDetectCondigtJudge': unreferenced 'static' functio
             -n
*** WARNING C174 IN LINE 425 OF src\app\diagnostic\FLTD.c: 'FLTD_PedalInitLocAbnormalDetect': unreferenced 'static' func
             -tion
*** WARNING C174 IN LINE 572 OF src\app\diagnostic\FLTD.c: 'FLTD_PedalActionAbnormalDetect': unreferenced 'static' funct
C166 COMPILER V7.57.0, FLTD                                                                01/20/2021 09:50:47 PAGE 25  

             -ion


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        2820     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          81     --------
  FAR-DATA SIZE    =         422     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =         722     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
